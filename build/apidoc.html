<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/postwait/node-amqp#readme"

    >amqp (v0.2.6)</a>
</h1>
<h4>AMQP driver for node</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp">module amqp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection">
            function <span class="apidocSignatureSpan">amqp.</span>Connection
            <span class="apidocSignatureSpan">(connectionArgs, options, readyCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._bodyToBuffer
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._chooseHost">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._chooseHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._createSocket">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._createSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._getSSLOptions">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._getSSLOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._inboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._onMethod">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._onMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._outboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._parseURLOptions">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._parseURLOptions
            <span class="apidocSignatureSpan">(connectionString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._saslResponse">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._saslResponse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendBody">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendBody
            <span class="apidocSignatureSpan">(channel, body, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendHeader">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendHeader
            <span class="apidocSignatureSpan">(channel, size, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendMethod">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._startHandshake">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._startHandshake
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.addAllListeners">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.addAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.connect">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.disconnect">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.end">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchange">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.exchange
            <span class="apidocSignatureSpan">(name, options, openCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchangeClosed">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.exchangeClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.generateChannelId">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.generateChannelId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.heartbeat">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.publish">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.publish
            <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queue">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.queue
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queueClosed">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.queueClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.reconnect">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.reconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setImplOptions">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.setImplOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setOptions">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.setOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel">
            function <span class="apidocSignatureSpan">amqp.</span>channel
            <span class="apidocSignatureSpan">(connection, channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.createConnection">
            function <span class="apidocSignatureSpan">amqp.</span>createConnection
            <span class="apidocSignatureSpan">(options, implOptions, readyCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange">
            function <span class="apidocSignatureSpan">amqp.</span>exchange
            <span class="apidocSignatureSpan">(connection, channel, name, options, openCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.message">
            function <span class="apidocSignatureSpan">amqp.</span>message
            <span class="apidocSignatureSpan">(queue, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser">
            function <span class="apidocSignatureSpan">amqp.</span>parser
            <span class="apidocSignatureSpan">(version, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue">
            function <span class="apidocSignatureSpan">amqp.</span>queue
            <span class="apidocSignatureSpan">(connection, channel, name, options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>Connection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>channel.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>exchange.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>jspack</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>message.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>promise</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>queue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>serializer</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection">module amqp.Connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.Connection">
            function <span class="apidocSignatureSpan">amqp.</span>Connection
            <span class="apidocSignatureSpan">(connectionArgs, options, readyCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.super_">
            function <span class="apidocSignatureSpan">amqp.Connection.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype">module amqp.Connection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_bodyToBuffer
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._chooseHost">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_chooseHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._createSocket">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_createSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._getSSLOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_getSSLOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_inboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._onMethod">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_onMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_outboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._parseURLOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_parseURLOptions
            <span class="apidocSignatureSpan">(connectionString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._saslResponse">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_saslResponse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendBody">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendBody
            <span class="apidocSignatureSpan">(channel, body, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendHeader">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendHeader
            <span class="apidocSignatureSpan">(channel, size, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendMethod">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._startHandshake">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_startHandshake
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.addAllListeners">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>addAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.connect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.disconnect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.end">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchange">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchange
            <span class="apidocSignatureSpan">(name, options, openCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchangeClosed">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchangeClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.generateChannelId">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>generateChannelId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.heartbeat">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.publish">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>publish
            <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queue">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queue
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queueClosed">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queueClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.reconnect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>reconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setImplOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setImplOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._bodyToBuffer">module amqp.Connection.prototype._bodyToBuffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer._bodyToBuffer">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_bodyToBuffer
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._chooseHost">module amqp.Connection.prototype._chooseHost</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._chooseHost._chooseHost">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_chooseHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._createSocket">module amqp.Connection.prototype._createSocket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._createSocket._createSocket">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_createSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._getSSLOptions">module amqp.Connection.prototype._getSSLOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._getSSLOptions._getSSLOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_getSSLOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._inboundHeartbeatTimerReset">module amqp.Connection.prototype._inboundHeartbeatTimerReset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset._inboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_inboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._onMethod">module amqp.Connection.prototype._onMethod</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._onMethod._onMethod">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_onMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._outboundHeartbeatTimerReset">module amqp.Connection.prototype._outboundHeartbeatTimerReset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset._outboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_outboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._parseURLOptions">module amqp.Connection.prototype._parseURLOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._parseURLOptions._parseURLOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_parseURLOptions
            <span class="apidocSignatureSpan">(connectionString)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._saslResponse">module amqp.Connection.prototype._saslResponse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._saslResponse._saslResponse">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_saslResponse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._sendBody">module amqp.Connection.prototype._sendBody</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendBody._sendBody">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendBody
            <span class="apidocSignatureSpan">(channel, body, properties)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._sendHeader">module amqp.Connection.prototype._sendHeader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendHeader._sendHeader">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendHeader
            <span class="apidocSignatureSpan">(channel, size, properties)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._sendMethod">module amqp.Connection.prototype._sendMethod</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendMethod._sendMethod">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._startHandshake">module amqp.Connection.prototype._startHandshake</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._startHandshake._startHandshake">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_startHandshake
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.addAllListeners">module amqp.Connection.prototype.addAllListeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.addAllListeners.addAllListeners">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>addAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.connect">module amqp.Connection.prototype.connect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.connect.connect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.disconnect">module amqp.Connection.prototype.disconnect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.disconnect.disconnect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.end">module amqp.Connection.prototype.end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.end.end">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.exchange">module amqp.Connection.prototype.exchange</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchange.exchange">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchange
            <span class="apidocSignatureSpan">(name, options, openCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.exchangeClosed">module amqp.Connection.prototype.exchangeClosed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchangeClosed.exchangeClosed">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchangeClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.generateChannelId">module amqp.Connection.prototype.generateChannelId</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.generateChannelId.generateChannelId">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>generateChannelId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.heartbeat">module amqp.Connection.prototype.heartbeat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.heartbeat.heartbeat">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.publish">module amqp.Connection.prototype.publish</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.publish.publish">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>publish
            <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.queue">module amqp.Connection.prototype.queue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queue.queue">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queue
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.queueClosed">module amqp.Connection.prototype.queueClosed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queueClosed.queueClosed">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queueClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.reconnect">module amqp.Connection.prototype.reconnect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.reconnect.reconnect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>reconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.setImplOptions">module amqp.Connection.prototype.setImplOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setImplOptions.setImplOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setImplOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.setOptions">module amqp.Connection.prototype.setOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setOptions.setOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.channel">module amqp.channel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.channel">
            function <span class="apidocSignatureSpan">amqp.</span>channel
            <span class="apidocSignatureSpan">(connection, channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.super_">
            function <span class="apidocSignatureSpan">amqp.channel.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.channel.prototype">module amqp.channel.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype._handleTaskReply">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_handleTaskReply
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype._onChannelMethod">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_onChannelMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype._taskPush">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_taskPush
            <span class="apidocSignatureSpan">(reply, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype._tasksFlush">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_tasksFlush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype.close">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>close
            <span class="apidocSignatureSpan">(reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype.closeOK">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>closeOK
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype.reconnect">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>reconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.createConnection">module amqp.createConnection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.createConnection.createConnection">
            function <span class="apidocSignatureSpan">amqp.</span>createConnection
            <span class="apidocSignatureSpan">(options, implOptions, readyCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.exchange">module amqp.exchange</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.exchange">
            function <span class="apidocSignatureSpan">amqp.</span>exchange
            <span class="apidocSignatureSpan">(connection, channel, name, options, openCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.super_">
            function <span class="apidocSignatureSpan">amqp.exchange.</span>super_
            <span class="apidocSignatureSpan">(connection, channel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.exchange.prototype">module amqp.exchange.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype._awaitConfirm">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_awaitConfirm
            <span class="apidocSignatureSpan">(task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype._confirmSelect">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_confirmSelect
            <span class="apidocSignatureSpan">(channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype._onMethod">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_onMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype._readyToPublishWithConfirms">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_readyToPublishWithConfirms
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.bind">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>bind
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.bind_headers">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>bind_headers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.cleanup">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>cleanup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.destroy">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>destroy
            <span class="apidocSignatureSpan">(ifUnused)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.publish">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>publish
            <span class="apidocSignatureSpan">(routingKey, data, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.unbind">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>unbind
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.jspack">module amqp.jspack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.jspack.jspack">
            function <span class="apidocSignatureSpan">amqp.</span>jspack
            <span class="apidocSignatureSpan">(bigEndian)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.message">module amqp.message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.message.message">
            function <span class="apidocSignatureSpan">amqp.</span>message
            <span class="apidocSignatureSpan">(queue, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.message.super_">
            function <span class="apidocSignatureSpan">amqp.message.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.message.prototype">module amqp.message.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.message.prototype.acknowledge">
            function <span class="apidocSignatureSpan">amqp.message.prototype.</span>acknowledge
            <span class="apidocSignatureSpan">(all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.message.prototype.reject">
            function <span class="apidocSignatureSpan">amqp.message.prototype.</span>reject
            <span class="apidocSignatureSpan">(requeue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.parser">module amqp.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.parser">
            function <span class="apidocSignatureSpan">amqp.</span>parser
            <span class="apidocSignatureSpan">(version, type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.parser.prototype">module amqp.parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.prototype._parseHeaderFrame">
            function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>_parseHeaderFrame
            <span class="apidocSignatureSpan">(channel, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.prototype._parseMethodFrame">
            function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>_parseMethodFrame
            <span class="apidocSignatureSpan">(channel, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.prototype.execute">
            function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>execute
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.prototype.setMaxFrameBuffer">
            function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>setMaxFrameBuffer
            <span class="apidocSignatureSpan">(maxFrameBuffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.prototype.throwError">
            function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>throwError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.promise">module amqp.promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.promise.Promise">
            function <span class="apidocSignatureSpan">amqp.promise.</span>Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.queue">module amqp.queue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.queue">
            function <span class="apidocSignatureSpan">amqp.</span>queue
            <span class="apidocSignatureSpan">(connection, channel, name, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.super_">
            function <span class="apidocSignatureSpan">amqp.queue.</span>super_
            <span class="apidocSignatureSpan">(connection, channel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.queue.prototype">module amqp.queue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype._onContent">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onContent
            <span class="apidocSignatureSpan">(channel, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype._onContentHeader">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onContentHeader
            <span class="apidocSignatureSpan">(channel, classInfo, weight, properties, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype._onMethod">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.bind">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>bind
            <span class="apidocSignatureSpan">(exchange, routingKey, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.bind_headers">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>bind_headers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.destroy">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>destroy
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.flow">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>flow
            <span class="apidocSignatureSpan">(active)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.purge">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>purge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.shift">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>shift
            <span class="apidocSignatureSpan">(reject, requeue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.subscribe">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(options, messageListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.subscribeJSON">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribeJSON
            <span class="apidocSignatureSpan">(options, messageListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.subscribeRaw">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribeRaw
            <span class="apidocSignatureSpan">(options, messageListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.unbind">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unbind
            <span class="apidocSignatureSpan">(exchange, routingKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.unbind_headers">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unbind_headers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.unsubscribe">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unsubscribe
            <span class="apidocSignatureSpan">(consumerTag)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.serializer">module amqp.serializer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.getCode">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>getCode
            <span class="apidocSignatureSpan">(dec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.isBigInt">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>isBigInt
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.isFloat">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>isFloat
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeArray">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeArray
            <span class="apidocSignatureSpan">(b, arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeBase64">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeBase64
            <span class="apidocSignatureSpan">(b, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeBuffer">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeBuffer
            <span class="apidocSignatureSpan">(b, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeDate">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeDate
            <span class="apidocSignatureSpan">(b, date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeFields">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeFields
            <span class="apidocSignatureSpan">(buffer, fields, args, strict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeFloat">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeFloat
            <span class="apidocSignatureSpan">(b, size, value, bigEndian)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeInt">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeInt
            <span class="apidocSignatureSpan">(b, size, int)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeLongString">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeLongString
            <span class="apidocSignatureSpan">(b, string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeShortString">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeShortString
            <span class="apidocSignatureSpan">(b, string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeTable">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeTable
            <span class="apidocSignatureSpan">(b, object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeValue">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeValue
            <span class="apidocSignatureSpan">(b, value)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp" id="apidoc.module.amqp">module amqp</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection" id="apidoc.element.amqp.Connection">
        function <span class="apidocSignatureSpan">amqp.</span>Connection
        <span class="apidocSignatureSpan">(connectionArgs, options, readyCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(connectionArgs, options, readyCallback) {
  EventEmitter.call(this);
  this.setOptions(connectionArgs);
  this.setImplOptions(options);

  if (typeof readyCallback === &#x27;function&#x27;) {
    this._readyCallback = readyCallback;
  }

  this.connectionAttemptScheduled = false;
  this._defaultExchange = null;
  this.channelCounter = 0;
  this._sendBuffer = new Buffer(maxFrameBuffer);

  this._blocked = false;
  this._blockedReason = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      });
  });
});
```

## Connection

`new amqp.<span class="apidocCodeKeywordSpan">Connection</span>()` Instantiates a new connection. Use
`connection.connect()` to connect to a server.

`amqp.createConnection()` returns an instance of `amqp.Connection`, which contains
an instance of `net.Socket` at its `socket` property. All events and methods which work on
`net.Socket` can also be used on an `amqp.Connection` instance. (e.g., the
events `&#x27;connect&#x27;` and `&#x27;close&#x27;`.)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer" id="apidoc.element.amqp.Connection.prototype._bodyToBuffer">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._bodyToBuffer
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._bodyToBuffer = function (body) {
  // Handles 3 cases
  // - body is utf8 string
  // - body is instance of Buffer
  // - body is an object and its JSON representation is sent
  // Does not handle the case for streaming bodies.
  // Returns buffer.
  if (typeof(body) == &#x27;string&#x27;) {
    return [null, new Buffer(body, &#x27;utf8&#x27;)];
  } else if (body instanceof Buffer) {
    return [null, body];
  } else {
    var jsonBody = JSON.stringify(body);

    debug &#x26;&#x26; debug(&#x27;sending json: &#x27; + jsonBody);

    var props = {contentType: &#x27;application/json&#x27;};
    return [props, new Buffer(jsonBody, &#x27;utf8&#x27;)];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._chooseHost" id="apidoc.element.amqp.Connection.prototype._chooseHost">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._chooseHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._chooseHost = function () {
  if(Array.isArray(this.options.host)){
    if(this.hosti == null){
      if(typeof this.options.hostPreference == &#x27;number&#x27;) {
        this.hosti = (this.options.hostPreference &#x3c; this.options.host.length) ?
          this.options.hostPreference : this.options.host.length-1;
      } else {
        this.hosti = parseInt(Math.random() * this.options.host.length, 10);
      }
    } else {
      // If this is already set, it looks like we want to choose another one.
      // Add one to hosti but don&#x27;t overflow it.
      this.hosti = (this.hosti + 1) % this.options.host.length;
    }
    return this.options.host[this.hosti];
  } else {
    return this.options.host;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._createSocket" id="apidoc.element.amqp.Connection.prototype._createSocket">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._createSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._createSocket = function () {
  var hostName = this._chooseHost(), self = this, port = this.options.port;
  var parsedHost = URL.parse(hostName);
  if(parsedHost.port){
    hostName = parsedHost.hostname;
    port = parsedHost.port;
  }

  var options = {
    port: port,
    host: hostName
  };

  // Disable tcp nagle&#x27;s algo
  // Default: true, makes small messages faster
  var noDelay = this.options.noDelay || true;

  var resetConnectionTimeout = function () {
    debug &#x26;&#x26; debug(&#x27;connected so resetting connection timeout&#x27;);
    this.setTimeout(0);
  };

  // Connect socket
  if (this.options.ssl.enabled) {
    debug &#x26;&#x26; debug(&#x27;making ssl connection&#x27;);
    options = _.assignIn(options, this._getSSLOptions());
    this.socket = tls.connect(options, resetConnectionTimeout);
  } else {
    debug &#x26;&#x26; debug(&#x27;making non-ssl connection&#x27;);
    this.socket = net.connect(options, resetConnectionTimeout);
  }
  var connTimeout = this.options.connectionTimeout;
  if (connTimeout) {
    debug &#x26;&#x26; debug(&#x27;setting connection timeout to &#x27; + connTimeout);
    this.socket.setTimeout(connTimeout, function () {
      debug &#x26;&#x26; debug(&#x27;connection timeout&#x27;);
      this.destroy();
      var e = new Error(&#x27;connection timeout&#x27;);
      e.name = &#x27;TimeoutError&#x27;;
      self.emit(&#x27;error&#x27;, e);
    });
  }

  this.socket.setNoDelay(noDelay);

  // Proxy events.
  // Note that if we don&#x27;t attach a &#x27;data&#x27; event, no data will flow.
  var events = [&#x27;close&#x27;, &#x27;connect&#x27;, &#x27;data&#x27;, &#x27;drain&#x27;, &#x27;error&#x27;, &#x27;end&#x27;, &#x27;secureConnect&#x27;, &#x27;timeout&#x27;];
  _.forEach(events, function(event){
    self.socket.on(event, self.emit.bind(self, event));
  });

  // Proxy a few methods that we use / previously used.
  var methods = [&#x27;destroy&#x27;, &#x27;write&#x27;, &#x27;pause&#x27;, &#x27;resume&#x27;, &#x27;setEncoding&#x27;, &#x27;ref&#x27;, &#x27;unref&#x27;, &#x27;address&#x27;];
  _.forEach(methods, function(method){
    self[method] = function(){
      self.socket[method].apply(self.socket, arguments);
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._getSSLOptions" id="apidoc.element.amqp.Connection.prototype._getSSLOptions">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._getSSLOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._getSSLOptions = function () {
  if (this.sslConnectionOptions) return this.sslConnectionOptions;
  this.sslConnectionOptions = {};

  if (this.options.ssl.pfxFile) {
    this.sslConnectionOptions.pfx = fs.readFileSync(this.options.ssl.pfxFile);
  }
  if (this.options.ssl.keyFile) {
    this.sslConnectionOptions.key = fs.readFileSync(this.options.ssl.keyFile);
  }
  if (this.options.ssl.certFile) {
    this.sslConnectionOptions.cert = fs.readFileSync(this.options.ssl.certFile);
  }
  if (this.options.ssl.caFile) {
    if (Array.isArray(this.options.ssl.caFile)) {
      this.sslConnectionOptions.ca = this.options.ssl.caFile.map(function(f){
        return fs.readFileSync(f);
      });
    } else {
      this.sslConnectionOptions.ca = fs.readFileSync(this.options.ssl.caFile);
    }
  }

  this.sslConnectionOptions.rejectUnauthorized = this.options.ssl.rejectUnauthorized;
  this.sslConnectionOptions.passphrase = this.options.ssl.passphrase;

  return this.sslConnectionOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._inboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._inboundHeartbeatTimerReset = function () {
  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }
  if (this.options.heartbeat) {
    var self = this;
    var gracePeriod = 2 * this.options.heartbeat;
    this._inboundHeartbeatTimer = setTimeout(function () {
      if(self.socket.readable || self.options.heartbeatForceReconnect){
        self.emit(&#x27;error&#x27;, new Error(&#x27;no heartbeat or data in last &#x27; + gracePeriod + &#x27; seconds&#x27;));
      }
    }, gracePeriod * 1000);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._onMethod" id="apidoc.element.amqp.Connection.prototype._onMethod">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._onMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._onMethod = function (channel, method, args) {
  debug &#x26;&#x26; debug(channel + &#x22; &#x3e; &#x22; + method.name + &#x22; &#x22; + JSON.stringify(args));

  // Channel 0 is the control channel. If not zero then delegate to
  // one of the channel objects.

  if (channel &#x3e; 0) {
    if (!this.channels[channel]) {
      debug &#x26;&#x26; debug(&#x22;Received message on untracked channel.&#x22;);
      return;
    }
    if (!this.channels[channel]._onChannelMethod) {
      throw new Error(&#x27;Channel &#x27; + channel + &#x27; has no _onChannelMethod method.&#x27;);
    }
    this.channels[channel]._onChannelMethod(channel, method, args);
    return;
  }

  // channel 0

  switch (method) {
    // 2. The server responds, after the version string, with the
    // &#x27;connectionStart&#x27; method (contains various useless information)
    case methods.connectionStart:
      // We check that they&#x27;re serving us AMQP 0-9
      if (args.versionMajor !== 0 &#x26;&#x26; args.versionMinor != 9) {
        this.socket.end();
        this.emit(&#x27;error&#x27;, new Error(&#x22;Bad server version&#x22;));
        return;
      }
      this.serverProperties = args.serverProperties;
      // 3. Then we reply with StartOk, containing our useless information.
      this._sendMethod(0, methods.connectionStartOk, {
        clientProperties: this.options.clientProperties,
        mechanism: this.options.authMechanism,
        response: this._saslResponse(),
        locale: &#x27;en_US&#x27;
      });
      break;

    // 4. The server responds with a connectionTune request
    case methods.connectionTune:
      if (args.frameMax) {
          debug &#x26;&#x26; debug(&#x22;tweaking maxFrameBuffer to &#x22; + args.frameMax);
          maxFrameBuffer = args.frameMax;
          this._sendBuffer = new Buffer(maxFrameBuffer);
          this.parser.setMaxFrameBuffer(maxFrameBuffer);
      }
      if (args.channelMax) {
          debug &#x26;&#x26; debug(&#x22;tweaking channelMax to &#x22; + args.channelMax);
          channelMax = args.channelMax;
      }
      // 5. We respond with connectionTuneOk
      this._sendMethod(0, methods.connectionTuneOk, {
        channelMax: channelMax,
        frameMax: maxFrameBuffer,
        heartbeat: this.options.heartbeat || 0
      });
      // 6. Then we have to send a connectionOpen request
      this._sendMethod(0, methods.connectionOpen, {
        virtualHost: this.options.vhost
        // , capabilities: &#x27;&#x27;
        // , insist: true
        ,
        reserved1: &#x27;&#x27;,
        reserved2: true
      });
      break;


    case methods.connectionOpenOk:
      // 7. Finally they respond with connectionOpenOk
      // Whew! That&#x27;s why they call it the Advanced MQP.
      if (this._readyCallback) {
        this._readyCallback(this);
        this._readyCallback = null;
      }
      this.emit(&#x27;ready&#x27;);
      break;

    case methods.connectionClose:
      var e = new Error(args.replyText);
      e.code = args.replyCode;
      if (!this.listeners(&#x27;close&#x27;).length) {
        console.log(&#x27;Unhandled connection error: &#x27; + args.replyText);
      }
      this.socket.destroy(e);
      break;

    case methods.connectionCloseOk:
      debug &#x26;&#x26; debug(&#x22;Received close-ok from server, closing socket&#x22;);
      this.socket.end();
      break;

    case methods.connectionBlocked:
      debug &#x26;&#x26; debug(&#x27;Received connection.blocked from server with reason: &#x27; + args.reason);
      this._blocked = true;
      this._blockedReason = args.reason;
      this.emit(&#x27;blocked&#x27;);
      break;

    case methods.connectionUnblocked:
      debug &#x26;&#x26; debug(&#x27;Received connection.unblocked from server&#x27;);
      this._blocked = false;
      this._blockedReason = null;
      this.emit(&#x27;unblocked&#x27;);
      break;

    default:
      throw new Error(&#x22;Uncaught method &#x27;&#x22; + method.name + &#x22;&#x27; with args &#x22; +
          JSON.stringify(args));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._outboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._outboundHeartbeatTimerReset = function () {
  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
  if (this.socket.writable &#x26;&#x26; this.options.heartbeat) {
    var self = this;
    this._outboundHeartbeatTimer = setTimeout(function () {
      self.heartbeat();
      self._outboundHeartbeatTimerReset();
    }, 1000 * this.options.heartbeat);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._parseURLOptions" id="apidoc.element.amqp.Connection.prototype._parseURLOptions">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._parseURLOptions
        <span class="apidocSignatureSpan">(connectionString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._parseURLOptions = function (connectionString) {
  var opts = {};
  opts.ssl = {};
  var url = URL.parse(connectionString);
  var scheme = url.protocol.substring(0, url.protocol.lastIndexOf(&#x27;:&#x27;));
  if (scheme != &#x27;amqp&#x27; &#x26;&#x26; scheme != &#x27;amqps&#x27;) {
    throw new Error(&#x27;Connection URI must use amqp or amqps scheme. &#x27; +
                    &#x27;For example, &#x22;amqp://bus.megacorp.internal:5766&#x22;.&#x27;);
  }
  opts.ssl.enabled = (&#x27;amqps&#x27; === scheme);
  opts.host = url.hostname;
  opts.port = url.port || defaultPorts[scheme];
  if (url.auth) {
    var auth = url.auth.split(&#x27;:&#x27;);
    auth[0] &#x26;&#x26; (opts.login = auth[0]);
    auth[1] &#x26;&#x26; (opts.password = auth[1]);
  }
  if (url.pathname) {
    opts.vhost = unescape(url.pathname.substr(1));
  }
  return opts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._saslResponse" id="apidoc.element.amqp.Connection.prototype._saslResponse">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._saslResponse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._saslResponse = function () {
  var response;
  if (this.options.authMechanism == &#x27;AMQPLAIN&#x27;)
    response = {
      LOGIN: this.options.login,
      PASSWORD: this.options.password
    };
  else if (this.options.authMechanism == &#x27;PLAIN&#x27;)
    response = &#x22;\0&#x22; + this.options.login + &#x22;\0&#x22; + this.options.password;
  else if (this.options.authMechanism == &#x27;EXTERNAL&#x27;)
    response = &#x22;\0&#x22;;
  else if (this.options.authMechanism == &#x27;ANONYMOUS&#x27;)
    response = &#x22;\0&#x22;;
  else
    response = this.options.response;

  return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendBody" id="apidoc.element.amqp.Connection.prototype._sendBody">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendBody
        <span class="apidocSignatureSpan">(channel, body, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._sendBody = function (channel, body, properties) {
  var r = this._bodyToBuffer(body);
  var props = r[0], buffer = r[1];

  properties = _.assignIn(props || {}, properties);

  this._sendHeader(channel, buffer.length, properties);

  var pos = 0, len = buffer.length;
  var metaSize = 8; // headerBytes = 7, frameEndBytes = 1
  var maxBodySize = maxFrameBuffer - metaSize;

  while (len &#x3e; 0) {
    var bodySize = len &#x3c; maxBodySize ? len : maxBodySize;
    var frameSize = bodySize + metaSize;

    var b = new Buffer(frameSize);
    b.used = 0;
    b[b.used++] = 3; // constants.frameBody
    serializer.serializeInt(b, 2, channel);
    serializer.serializeInt(b, 4, bodySize);
    buffer.copy(b, b.used, pos, pos+bodySize);
    b.used += bodySize;
    b[b.used++] = 206; // constants.frameEnd;
    this.write(b);

    len -= bodySize;
    pos += bodySize;
  }
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendHeader" id="apidoc.element.amqp.Connection.prototype._sendHeader">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendHeader
        <span class="apidocSignatureSpan">(channel, size, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._sendHeader = function (channel, size, properties) {
  var b = new Buffer(maxFrameBuffer); // FIXME allocating too much.
                                      // use freelist?
  b.used = 0;

  var classInfo = classes[60]; // always basic class.

  // 7 OCTET FRAME HEADER

  b[b.used++] = 2; // constants.frameHeader

  serializer.serializeInt(b, 2, channel);

  var lengthStart = b.used;

  serializer.serializeInt(b, 4, 0 /*dummy*/); // length

  var bodyStart = b.used;

  // HEADER&#x27;S BODY

  serializer.serializeInt(b, 2, classInfo.index);   // class 60 for Basic
  serializer.serializeInt(b, 2, 0);                 // weight, always 0 for rabbitmq
  serializer.serializeInt(b, 8, size);              // byte size of body

  // properties - first propertyFlags
  properties = _.defaults(properties || {}, {contentType: &#x27;application/octet-stream&#x27;});
  var propertyFlags = 0;
  for (var i = 0; i &#x3c; classInfo.fields.length; i++) {
    if (properties[classInfo.fields[i].name]) propertyFlags |= 1 &#x3c;&#x3c; (15-i);
  }
  serializer.serializeInt(b, 2, propertyFlags);
  // now the actual properties.
  serializer.serializeFields(b, classInfo.fields, properties, false);

  //serializeTable(b, properties);

  var bodyEnd = b.used;

  // Go back to the header and write in the length now that we know it.
  b.used = lengthStart;
  serializer.serializeInt(b, 4, bodyEnd - bodyStart);
  b.used = bodyEnd;

  // 1 OCTET END

  b[b.used++] = 206; // constants.frameEnd;

  var s = new Buffer(b.used);
  b.copy(s);

  //debug &#x26;&#x26; debug(&#x27;header sent: &#x27; + JSON.stringify(s));

  this.write(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendMethod" id="apidoc.element.amqp.Connection.prototype._sendMethod">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._sendMethod = function (channel, method, args) {
  debug &#x26;&#x26; debug(channel + &#x22; &#x3c; &#x22; + method.name + &#x22; &#x22; + JSON.stringify(args));
  var b = this._sendBuffer;
  b.used = 0;

  b[b.used++] = 1; // constants.frameMethod

  serializer.serializeInt(b, 2, channel);

  var lengthIndex = b.used;

  serializer.serializeInt(b, 4, 42); // replace with actual length.

  var startIndex = b.used;


  serializer.serializeInt(b, 2, method.classIndex); // short, classId
  serializer.serializeInt(b, 2, method.methodIndex); // short, methodId

  serializer.serializeFields(b, method.fields, args, true);

  var endIndex = b.used;

  // write in the frame length now that we know it.
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;

  b[b.used++] = 206; // constants.frameEnd;

  var c = new Buffer(b.used);
  b.copy(c);

  debug &#x26;&#x26; debug(&#x22;sending frame: &#x22; + c.toJSON());

  this.write(c);

  this._outboundHeartbeatTimerReset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._startHandshake" id="apidoc.element.amqp.Connection.prototype._startHandshake">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._startHandshake
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._startHandshake = function () {
  debug &#x26;&#x26; debug(&#x22;Initiating handshake...&#x22;);
  this.write(&#x22;AMQP&#x22; + String.fromCharCode(0,0,9,1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.addAllListeners" id="apidoc.element.amqp.Connection.prototype.addAllListeners">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.addAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.addAllListeners = function () {
  var self = this;
  var connectEvent = this.options.ssl.enabled ? &#x27;secureConnect&#x27; : &#x27;connect&#x27;;


  self.addListener(connectEvent, function() {
    // In the case where this is a reconnection, do not trample on the existing
    // channels.
    // For your reference, channel 0 is the control channel.
    self.channels = self.channels || {0:self};
    self.queues = self.queues || {};
    self.exchanges = self.exchanges || {};

    self.parser = new AMQPParser(&#x27;0-9-1&#x27;, &#x27;client&#x27;);

    self.parser.onMethod = function (channel, method, args) {
      self._onMethod(channel, method, args);
    };

    self.parser.onContent = function (channel, data) {
      debug &#x26;&#x26; debug(channel + &#x22; &#x3e; content &#x22; + data.length);
      if (self.channels[channel] &#x26;&#x26; self.channels[channel]._onContent) {
        self.channels[channel]._onContent(channel, data);
      } else {
        debug &#x26;&#x26; debug(&#x22;unhandled content: &#x22; + data);
      }
    };

    self.parser.onContentHeader = function (channel, classInfo, weight, properties, size) {
      debug &#x26;&#x26; debug(channel + &#x22; &#x3e; content header &#x22; + JSON.stringify([classInfo.name, weight, properties, size]));
      if (self.channels[channel] &#x26;&#x26; self.channels[channel]._onContentHeader) {
        self.channels[channel]._onContentHeader(channel, classInfo, weight, properties, size);
      } else {
        debug &#x26;&#x26; debug(&#x22;unhandled content header&#x22;);
      }
    };

    self.parser.onHeartBeat = function () {
      self.emit(&#x22;heartbeat&#x22;);
      debug &#x26;&#x26; debug(&#x22;heartbeat&#x22;);
    };

    self.parser.onError = function (e) {
      self.emit(&#x22;error&#x22;, e);
      self.emit(&#x22;close&#x22;);
    };

    // Remove readyEmitted flag so we can detect an auth error.
    self.readyEmitted = false;
  });

  self.addListener(&#x27;data&#x27;, function (data) {
    if(self.parser != null){
      try {
        self.parser.execute(data);
      } catch (exception) {
        self.emit(&#x27;error&#x27;, exception);
        return;
      }
    }
    self._inboundHeartbeatTimerReset();
  });

  var backoffTime = null;
  self.addListener(&#x27;error&#x27;, function backoff(e) {
    if (self._inboundHeartbeatTimer !== null) {
      clearTimeout(self._inboundHeartbeatTimer);
      self._inboundHeartbeatTimer = null;
    }
    if (self._outboundHeartbeatTimer !== null) {
      clearTimeout(self._outboundHeartbeatTimer);
      self._outboundHeartbeatTimer = null;
    }

    if (!self.connectionAttemptScheduled) {
      // Set to true, as we are presently in the process of scheduling one.
      self.connectionAttemptScheduled = true;

      // Kill the socket, if it hasn&#x27;t been killed already.
      self.socket.end();

      // Reset parser state
      self.parser = null;

      // In order for our reconnection to be seamless, we have to notify the
      // channels that they are no longer connected so that nobody attempts
      // to send messages which would be doomed to fail.
      for (var channel in self.channels) {
        if (channel !== &#x27;0&#x27;) {
          self.channels[channel].state = &#x27;closed&#x27;;
        }
      }
      // Queues are channels (so we have already marked them as closed), but
      // queues have special needs, since the subscriptions will no longer
      // be known to the server when we reconnect.  Mark the subscriptions as
      // closed so that we can resubscribe them once we are reconnected.
      for (var queue in self.queues) {
        for (var index in self.queues[queue].consumerTagOptions) {
          self.queues[queue].consumerTagOptions[index][&#x27;state&#x27;] = &#x27;closed&#x27;;
        }
      }

      // Begin reconnection attempts
      if (self.implOptions.reconnect) {
        // Don&#x27;t thrash, use a backoff strategy.
        if (backoffTime === null) {
          // This is the first time we&#x27;ve failed since a successful connection,
          // so use the configured backoff time without any modification.
          backoffTime = self.implOptions.reconnectBackoffTime;
        } else if (self.implOptions.reconnectBackoffStrategy === &#x27;exponential&#x27;) {
          // If you&#x27;ve configured exponential backoff, we&#x27;ll double the
          // backoff time each ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.connect" id="apidoc.element.amqp.Connection.prototype.connect">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.connect = function () {
  // If this is our first connection, add listeners.
  if (!this.socket) this.addAllListeners();

  this._createSocket();
  this._startHandshake();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.disconnect" id="apidoc.element.amqp.Connection.prototype.disconnect">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.disconnect = function () {
  debug &#x26;&#x26; debug(&#x22;Sending disconnect request to server&#x22;);
  this._sendMethod(0, methods.connectionClose, {
    &#x27;replyText&#x27;: &#x27;client disconnect&#x27;,
    &#x27;replyCode&#x27;: 200,
    &#x27;classId&#x27;: 0,
    &#x27;methodId&#x27;: 0
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.end" id="apidoc.element.amqp.Connection.prototype.end">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.end = function () {
  if (this.socket) {
    this.socket.end();
  }

  this.options.heartbeat = false;

  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }

  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchange" id="apidoc.element.amqp.Connection.prototype.exchange">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.exchange
        <span class="apidocSignatureSpan">(name, options, openCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.exchange = function (name, options, openCallback) {
  if (name === undefined) name = this.implOptions.defaultExchangeName;

  if (!options) options = {};
  if (name !== &#x27;&#x27; &#x26;&#x26; options.type === undefined) options.type = &#x27;topic&#x27;;

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit(&#x22;error&#x22;, exception);
    return;
  }
  var exchange = new Exchange(this, channel, name, options, openCallback);
  this.channels[channel] = exchange;
  this.exchanges[name] = exchange;
  return exchange;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchangeClosed" id="apidoc.element.amqp.Connection.prototype.exchangeClosed">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.exchangeClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.exchangeClosed = function (name) {
  if (this.exchanges[name]) delete this.exchanges[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.generateChannelId" id="apidoc.element.amqp.Connection.prototype.generateChannelId">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.generateChannelId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.generateChannelId = function () {
  // start from the last used slot id
  var channelId = this.channelCounter;
  while(true){
    // use values in range of 1..65535
    channelId = channelId % channelMax + 1;
    if(!this.channels[channelId]){
      break;
    }
    // after a full loop throw an Error
    if(channelId == this.channelCounter){
      throw new Error(&#x22;No valid Channel Id values available&#x22;);
    }
  }
  this.channelCounter = channelId;
  return this.channelCounter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.heartbeat" id="apidoc.element.amqp.Connection.prototype.heartbeat">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.heartbeat = function () {
  if(this.socket.writable) this.write(new Buffer([8,0,0,0,0,0,0,206]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.publish" id="apidoc.element.amqp.Connection.prototype.publish">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.publish
        <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.publish = function (routingKey, body, options, callback) {
  if (!this._defaultExchange) {
    this._defaultExchange = this.exchange();
  }

  var exchange = this._defaultExchange;
  if (exchange.state === &#x27;open&#x27;) {
    exchange.publish(routingKey, body, options, callback);
  } else {
    exchange.once(&#x27;open&#x27;, function() {
      exchange.publish(routingKey, body, options, callback);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queue" id="apidoc.element.amqp.Connection.prototype.queue">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.queue
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.queue = function (name) {
  var options, callback;
  if (typeof arguments[1] == &#x27;object&#x27;) {
    options = arguments[1];
    callback = arguments[2];
  } else {
    callback = arguments[1];
  }

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit(&#x22;error&#x22;, exception);
    return;
  }

  var q = new Queue(this, channel, name, options, callback);
  this.channels[channel] = q;
  return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queueClosed" id="apidoc.element.amqp.Connection.prototype.queueClosed">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.queueClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.queueClosed = function (name) {
  if (this.queues[name]) delete this.queues[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.reconnect" id="apidoc.element.amqp.Connection.prototype.reconnect">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.reconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.reconnect = function () {
  // Suspend activity on channels
  for (var channel in this.channels) {
    this.channels[channel].state = &#x27;closed&#x27;;
  }
  debug &#x26;&#x26; debug(&#x22;Connection lost, reconnecting...&#x22;);
  // Terminate socket activity
  if (this.socket) this.socket.end();
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setImplOptions" id="apidoc.element.amqp.Connection.prototype.setImplOptions">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.setImplOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.setImplOptions = function (options) {
  this.implOptions = _.assignIn({}, defaultImplOptions, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setOptions" id="apidoc.element.amqp.Connection.prototype.setOptions">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.setOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.setOptions = function (options) {
  var urlo = (options &#x26;&#x26; options.url) ? this._parseURLOptions(options.url) : {};
  var sslo = (options &#x26;&#x26; options.ssl &#x26;&#x26; options.ssl.enabled) ? defaultSslOptions : {};
  this.options = _.assignIn({}, defaultOptions, sslo, urlo, options || {});
  this.options.clientProperties =  _.assignIn({}, defaultClientProperties, (options &#x26;&#x26; options.clientProperties) || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel" id="apidoc.element.amqp.channel">
        function <span class="apidocSignatureSpan">amqp.</span>channel
        <span class="apidocSignatureSpan">(connection, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Channel(connection, channel) {
  events.EventEmitter.call(this);

  // Unlimited listeners. Helps when e.g. publishing high-volume messages,
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.reconnect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.createConnection" id="apidoc.element.amqp.createConnection">
        function <span class="apidocSignatureSpan">amqp.</span>createConnection
        <span class="apidocSignatureSpan">(options, implOptions, readyCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createConnection = function (options, implOptions, readyCallback) {
  var c = new Connection(options, implOptions, readyCallback);
  c.connect();
  return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
IMPORTANT: This module only works with node v0.4.0 and later.

An example of connecting to a server and listening on a queue.

```javascript
var amqp = require(&#x27;amqp&#x27;);

var connection = amqp.<span class="apidocCodeKeywordSpan">createConnection</span>({ host: &#x27;dev.rabbitmq.com&#x27; });

// add this for better debuging
connection.on(&#x27;error&#x27;, function(e) {
  console.log(&#x22;Error from amqp: &#x22;, e);
});

// Wait for connection to become established.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange" id="apidoc.element.amqp.exchange">
        function <span class="apidocSignatureSpan">amqp.</span>exchange
        <span class="apidocSignatureSpan">(connection, channel, name, options, openCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Exchange(connection, channel, name, options, openCallback) {
  Channel.call(this, connection, channel);
  this.name = name;
  this.binds = 0; // keep track of queues bound
  this.exchangeBinds = 0; // keep track of exchanges bound
  this.sourceExchanges = {};
  this.options = _.defaults(options || {}, {autoDelete: true});
  this._openCallback = openCallback;

  this._sequence = null;
  this._unAcked  = {};
  this._addedExchangeErrorHandler = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.<span class="apidocCodeKeywordSpan">exchange</span>()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
- [exchange.unbind(srcExchange, routingKey [, callback])](#exchangeunbindsrcexchange-routingkey--callback)
- [exchange.bind_headers(exchange, routing [, bindCallback])](#exchangebind_headersexchange-routing--bindcallback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.message" id="apidoc.element.amqp.message">
        function <span class="apidocSignatureSpan">amqp.</span>message
        <span class="apidocSignatureSpan">(queue, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(queue, args) {
  var msgProperties = definitions.classes[60].fields;

  events.EventEmitter.call(this);

  this.queue = queue;

  this.deliveryTag = args.deliveryTag;
  this.redelivered = args.redelivered;
  this.exchange    = args.exchange;
  this.routingKey  = args.routingKey;
  this.consumerTag = args.consumerTag;

  for (var i=0, l=msgProperties.length; i&#x3c;l; i++) {
    if (args[msgProperties[i].name]) {
      this[msgProperties[i].name] = args[msgProperties[i].name];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.parser" id="apidoc.element.amqp.parser">
        function <span class="apidocSignatureSpan">amqp.</span>parser
        <span class="apidocSignatureSpan">(version, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AMQPParser(version, type) {
  this.isClient = (type == &#x27;client&#x27;);
  this.state = this.isClient ? &#x27;frameHeader&#x27; : &#x27;protocolHeader&#x27;;
  this.maxFrameBuffer = MAX_FRAME_BUFFER_DEFAULT;

  if (version != &#x27;0-9-1&#x27;) this.throwError(&#x22;Unsupported protocol version&#x22;);

  var frameHeader = new Buffer(7);
  frameHeader.used = 0;
  var frameBuffer, frameType, frameChannel;

  var self = this;

  function header(data) {
    var fh = frameHeader;
    var needed = fh.length - fh.used;
    data.copy(fh, fh.used, 0, data.length);
    fh.used += data.length; // sloppy
    if (fh.used &#x3e;= fh.length) {
      fh.read = 0;
      frameType = fh[fh.read++];
      frameChannel = parseInt(fh, 2);
      var frameSize = parseInt(fh, 4);
      fh.used = 0; // for reuse
      if (frameSize &#x3e; self.maxFrameBuffer) {
        self.throwError(&#x22;Oversized frame &#x22; + frameSize);
      }
      frameBuffer = new Buffer(frameSize);
      frameBuffer.used = 0;
      return frame(data.slice(needed));
    }
    else { // need more!
      return header;
    }
  }

  function frame(data) {
    var fb = frameBuffer;
    var needed = fb.length - fb.used;
    var sourceEnd = (fb.length &#x3e; data.length) ? data.length : fb.length;
    data.copy(fb, fb.used, 0, sourceEnd);
    fb.used += data.length;
    if (data.length &#x3e; needed) {
      return frameEnd(data.slice(needed));
    }
    else if (data.length == needed) {
      return frameEnd;
    }
    else {
      return frame;
    }
  }

  function frameEnd(data) {
    if (data.length &#x3e; 0) {
      if (data[0] === Indicators.FRAME_END) {
        switch (frameType) {
        case FrameType.METHOD:
          self._parseMethodFrame(frameChannel, frameBuffer);
          break;
        case FrameType.HEADER:
          self._parseHeaderFrame(frameChannel, frameBuffer);
          break;
        case FrameType.BODY:
          if (self.onContent) {
            self.onContent(frameChannel, frameBuffer);
          }
          break;
        case FrameType.HEARTBEAT:
          debug &#x26;&#x26; debug(&#x22;heartbeat&#x22;);
          if (self.onHeartBeat) self.onHeartBeat();
          break;
        default:
          self.throwError(&#x22;Unhandled frame type &#x22; + frameType);
          break;
        }
        return header(data.slice(1));
      }
      else {
        self.throwError(&#x22;Missing frame end marker&#x22;);
      }
    }
    else {
      return frameEnd;
    }
  }

  self.parse = header;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue" id="apidoc.element.amqp.queue">
        function <span class="apidocSignatureSpan">amqp.</span>queue
        <span class="apidocSignatureSpan">(connection, channel, name, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue(connection, channel, name, options, callback) {
  Channel.call(this, connection, channel);

  var self = this;
  this.name = name;
  this._bindings = {};
  this.consumerTagListeners = {};
  this.consumerTagOptions = {};

  // route messages to subscribers based on consumerTag
  this.on(&#x27;rawMessage&#x27;, function(message) {
    if (message.consumerTag &#x26;&#x26; self.consumerTagListeners[message.consumerTag]) {
      self.consumerTagListeners[message.consumerTag](message);
    }
  });

  this.options = { autoDelete: true, closeChannelOnUnsubscribe: false };
  _.assignIn(this.options, options || {});

  this._openCallback = callback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.<span class="apidocCodeKeywordSpan">queue</span>(name[, options][, openCallback])](#connectionqueuename-options-opencallback
)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection" id="apidoc.module.amqp.Connection">module amqp.Connection</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.Connection" id="apidoc.element.amqp.Connection.Connection">
        function <span class="apidocSignatureSpan">amqp.</span>Connection
        <span class="apidocSignatureSpan">(connectionArgs, options, readyCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(connectionArgs, options, readyCallback) {
  EventEmitter.call(this);
  this.setOptions(connectionArgs);
  this.setImplOptions(options);

  if (typeof readyCallback === &#x27;function&#x27;) {
    this._readyCallback = readyCallback;
  }

  this.connectionAttemptScheduled = false;
  this._defaultExchange = null;
  this.channelCounter = 0;
  this._sendBuffer = new Buffer(maxFrameBuffer);

  this._blocked = false;
  this._blockedReason = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      });
  });
});
```

## Connection

`new amqp.<span class="apidocCodeKeywordSpan">Connection</span>()` Instantiates a new connection. Use
`connection.connect()` to connect to a server.

`amqp.createConnection()` returns an instance of `amqp.Connection`, which contains
an instance of `net.Socket` at its `socket` property. All events and methods which work on
`net.Socket` can also be used on an `amqp.Connection` instance. (e.g., the
events `&#x27;connect&#x27;` and `&#x27;close&#x27;`.)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.super_" id="apidoc.element.amqp.Connection.super_">
        function <span class="apidocSignatureSpan">amqp.Connection.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype" id="apidoc.module.amqp.Connection.prototype">module amqp.Connection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer" id="apidoc.element.amqp.Connection.prototype._bodyToBuffer">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_bodyToBuffer
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_bodyToBuffer = function (body) {
  // Handles 3 cases
  // - body is utf8 string
  // - body is instance of Buffer
  // - body is an object and its JSON representation is sent
  // Does not handle the case for streaming bodies.
  // Returns buffer.
  if (typeof(body) == &#x27;string&#x27;) {
    return [null, new Buffer(body, &#x27;utf8&#x27;)];
  } else if (body instanceof Buffer) {
    return [null, body];
  } else {
    var jsonBody = JSON.stringify(body);

    debug &#x26;&#x26; debug(&#x27;sending json: &#x27; + jsonBody);

    var props = {contentType: &#x27;application/json&#x27;};
    return [props, new Buffer(jsonBody, &#x27;utf8&#x27;)];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._chooseHost" id="apidoc.element.amqp.Connection.prototype._chooseHost">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_chooseHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_chooseHost = function () {
  if(Array.isArray(this.options.host)){
    if(this.hosti == null){
      if(typeof this.options.hostPreference == &#x27;number&#x27;) {
        this.hosti = (this.options.hostPreference &#x3c; this.options.host.length) ?
          this.options.hostPreference : this.options.host.length-1;
      } else {
        this.hosti = parseInt(Math.random() * this.options.host.length, 10);
      }
    } else {
      // If this is already set, it looks like we want to choose another one.
      // Add one to hosti but don&#x27;t overflow it.
      this.hosti = (this.hosti + 1) % this.options.host.length;
    }
    return this.options.host[this.hosti];
  } else {
    return this.options.host;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._createSocket" id="apidoc.element.amqp.Connection.prototype._createSocket">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_createSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createSocket = function () {
  var hostName = this._chooseHost(), self = this, port = this.options.port;
  var parsedHost = URL.parse(hostName);
  if(parsedHost.port){
    hostName = parsedHost.hostname;
    port = parsedHost.port;
  }

  var options = {
    port: port,
    host: hostName
  };

  // Disable tcp nagle&#x27;s algo
  // Default: true, makes small messages faster
  var noDelay = this.options.noDelay || true;

  var resetConnectionTimeout = function () {
    debug &#x26;&#x26; debug(&#x27;connected so resetting connection timeout&#x27;);
    this.setTimeout(0);
  };

  // Connect socket
  if (this.options.ssl.enabled) {
    debug &#x26;&#x26; debug(&#x27;making ssl connection&#x27;);
    options = _.assignIn(options, this._getSSLOptions());
    this.socket = tls.connect(options, resetConnectionTimeout);
  } else {
    debug &#x26;&#x26; debug(&#x27;making non-ssl connection&#x27;);
    this.socket = net.connect(options, resetConnectionTimeout);
  }
  var connTimeout = this.options.connectionTimeout;
  if (connTimeout) {
    debug &#x26;&#x26; debug(&#x27;setting connection timeout to &#x27; + connTimeout);
    this.socket.setTimeout(connTimeout, function () {
      debug &#x26;&#x26; debug(&#x27;connection timeout&#x27;);
      this.destroy();
      var e = new Error(&#x27;connection timeout&#x27;);
      e.name = &#x27;TimeoutError&#x27;;
      self.emit(&#x27;error&#x27;, e);
    });
  }

  this.socket.setNoDelay(noDelay);

  // Proxy events.
  // Note that if we don&#x27;t attach a &#x27;data&#x27; event, no data will flow.
  var events = [&#x27;close&#x27;, &#x27;connect&#x27;, &#x27;data&#x27;, &#x27;drain&#x27;, &#x27;error&#x27;, &#x27;end&#x27;, &#x27;secureConnect&#x27;, &#x27;timeout&#x27;];
  _.forEach(events, function(event){
    self.socket.on(event, self.emit.bind(self, event));
  });

  // Proxy a few methods that we use / previously used.
  var methods = [&#x27;destroy&#x27;, &#x27;write&#x27;, &#x27;pause&#x27;, &#x27;resume&#x27;, &#x27;setEncoding&#x27;, &#x27;ref&#x27;, &#x27;unref&#x27;, &#x27;address&#x27;];
  _.forEach(methods, function(method){
    self[method] = function(){
      self.socket[method].apply(self.socket, arguments);
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._getSSLOptions" id="apidoc.element.amqp.Connection.prototype._getSSLOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_getSSLOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSSLOptions = function () {
  if (this.sslConnectionOptions) return this.sslConnectionOptions;
  this.sslConnectionOptions = {};

  if (this.options.ssl.pfxFile) {
    this.sslConnectionOptions.pfx = fs.readFileSync(this.options.ssl.pfxFile);
  }
  if (this.options.ssl.keyFile) {
    this.sslConnectionOptions.key = fs.readFileSync(this.options.ssl.keyFile);
  }
  if (this.options.ssl.certFile) {
    this.sslConnectionOptions.cert = fs.readFileSync(this.options.ssl.certFile);
  }
  if (this.options.ssl.caFile) {
    if (Array.isArray(this.options.ssl.caFile)) {
      this.sslConnectionOptions.ca = this.options.ssl.caFile.map(function(f){
        return fs.readFileSync(f);
      });
    } else {
      this.sslConnectionOptions.ca = fs.readFileSync(this.options.ssl.caFile);
    }
  }

  this.sslConnectionOptions.rejectUnauthorized = this.options.ssl.rejectUnauthorized;
  this.sslConnectionOptions.passphrase = this.options.ssl.passphrase;

  return this.sslConnectionOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_inboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_inboundHeartbeatTimerReset = function () {
  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }
  if (this.options.heartbeat) {
    var self = this;
    var gracePeriod = 2 * this.options.heartbeat;
    this._inboundHeartbeatTimer = setTimeout(function () {
      if(self.socket.readable || self.options.heartbeatForceReconnect){
        self.emit(&#x27;error&#x27;, new Error(&#x27;no heartbeat or data in last &#x27; + gracePeriod + &#x27; seconds&#x27;));
      }
    }, gracePeriod * 1000);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._onMethod" id="apidoc.element.amqp.Connection.prototype._onMethod">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_onMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onMethod = function (channel, method, args) {
  debug &#x26;&#x26; debug(channel + &#x22; &#x3e; &#x22; + method.name + &#x22; &#x22; + JSON.stringify(args));

  // Channel 0 is the control channel. If not zero then delegate to
  // one of the channel objects.

  if (channel &#x3e; 0) {
    if (!this.channels[channel]) {
      debug &#x26;&#x26; debug(&#x22;Received message on untracked channel.&#x22;);
      return;
    }
    if (!this.channels[channel]._onChannelMethod) {
      throw new Error(&#x27;Channel &#x27; + channel + &#x27; has no _onChannelMethod method.&#x27;);
    }
    this.channels[channel]._onChannelMethod(channel, method, args);
    return;
  }

  // channel 0

  switch (method) {
    // 2. The server responds, after the version string, with the
    // &#x27;connectionStart&#x27; method (contains various useless information)
    case methods.connectionStart:
      // We check that they&#x27;re serving us AMQP 0-9
      if (args.versionMajor !== 0 &#x26;&#x26; args.versionMinor != 9) {
        this.socket.end();
        this.emit(&#x27;error&#x27;, new Error(&#x22;Bad server version&#x22;));
        return;
      }
      this.serverProperties = args.serverProperties;
      // 3. Then we reply with StartOk, containing our useless information.
      this._sendMethod(0, methods.connectionStartOk, {
        clientProperties: this.options.clientProperties,
        mechanism: this.options.authMechanism,
        response: this._saslResponse(),
        locale: &#x27;en_US&#x27;
      });
      break;

    // 4. The server responds with a connectionTune request
    case methods.connectionTune:
      if (args.frameMax) {
          debug &#x26;&#x26; debug(&#x22;tweaking maxFrameBuffer to &#x22; + args.frameMax);
          maxFrameBuffer = args.frameMax;
          this._sendBuffer = new Buffer(maxFrameBuffer);
          this.parser.setMaxFrameBuffer(maxFrameBuffer);
      }
      if (args.channelMax) {
          debug &#x26;&#x26; debug(&#x22;tweaking channelMax to &#x22; + args.channelMax);
          channelMax = args.channelMax;
      }
      // 5. We respond with connectionTuneOk
      this._sendMethod(0, methods.connectionTuneOk, {
        channelMax: channelMax,
        frameMax: maxFrameBuffer,
        heartbeat: this.options.heartbeat || 0
      });
      // 6. Then we have to send a connectionOpen request
      this._sendMethod(0, methods.connectionOpen, {
        virtualHost: this.options.vhost
        // , capabilities: &#x27;&#x27;
        // , insist: true
        ,
        reserved1: &#x27;&#x27;,
        reserved2: true
      });
      break;


    case methods.connectionOpenOk:
      // 7. Finally they respond with connectionOpenOk
      // Whew! That&#x27;s why they call it the Advanced MQP.
      if (this._readyCallback) {
        this._readyCallback(this);
        this._readyCallback = null;
      }
      this.emit(&#x27;ready&#x27;);
      break;

    case methods.connectionClose:
      var e = new Error(args.replyText);
      e.code = args.replyCode;
      if (!this.listeners(&#x27;close&#x27;).length) {
        console.log(&#x27;Unhandled connection error: &#x27; + args.replyText);
      }
      this.socket.destroy(e);
      break;

    case methods.connectionCloseOk:
      debug &#x26;&#x26; debug(&#x22;Received close-ok from server, closing socket&#x22;);
      this.socket.end();
      break;

    case methods.connectionBlocked:
      debug &#x26;&#x26; debug(&#x27;Received connection.blocked from server with reason: &#x27; + args.reason);
      this._blocked = true;
      this._blockedReason = args.reason;
      this.emit(&#x27;blocked&#x27;);
      break;

    case methods.connectionUnblocked:
      debug &#x26;&#x26; debug(&#x27;Received connection.unblocked from server&#x27;);
      this._blocked = false;
      this._blockedReason = null;
      this.emit(&#x27;unblocked&#x27;);
      break;

    default:
      throw new Error(&#x22;Uncaught method &#x27;&#x22; + method.name + &#x22;&#x27; with args &#x22; +
          JSON.stringify(args));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Channel.prototype._onChannelMethod = function(channel, method, args) {
switch (method) {
  case methods.channelCloseOk:
    delete this.connection.channels[this.channel];
    this.state = &#x27;closed&#x27;;
    // TODO should this be falling through?
  default:
    this.<span class="apidocCodeKeywordSpan">_onMethod</span>(channel, method, args);
}
};

Channel.prototype.close = function(reason) {
this.state = &#x27;closing&#x27;;
this.connection._sendMethod(this.channel, methods.channelClose,
                            {&#x27;replyText&#x27;: reason ? reason : &#x27;Goodbye from node&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_outboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_outboundHeartbeatTimerReset = function () {
  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
  if (this.socket.writable &#x26;&#x26; this.options.heartbeat) {
    var self = this;
    this._outboundHeartbeatTimer = setTimeout(function () {
      self.heartbeat();
      self._outboundHeartbeatTimerReset();
    }, 1000 * this.options.heartbeat);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._parseURLOptions" id="apidoc.element.amqp.Connection.prototype._parseURLOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_parseURLOptions
        <span class="apidocSignatureSpan">(connectionString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseURLOptions = function (connectionString) {
  var opts = {};
  opts.ssl = {};
  var url = URL.parse(connectionString);
  var scheme = url.protocol.substring(0, url.protocol.lastIndexOf(&#x27;:&#x27;));
  if (scheme != &#x27;amqp&#x27; &#x26;&#x26; scheme != &#x27;amqps&#x27;) {
    throw new Error(&#x27;Connection URI must use amqp or amqps scheme. &#x27; +
                    &#x27;For example, &#x22;amqp://bus.megacorp.internal:5766&#x22;.&#x27;);
  }
  opts.ssl.enabled = (&#x27;amqps&#x27; === scheme);
  opts.host = url.hostname;
  opts.port = url.port || defaultPorts[scheme];
  if (url.auth) {
    var auth = url.auth.split(&#x27;:&#x27;);
    auth[0] &#x26;&#x26; (opts.login = auth[0]);
    auth[1] &#x26;&#x26; (opts.password = auth[1]);
  }
  if (url.pathname) {
    opts.vhost = unescape(url.pathname.substr(1));
  }
  return opts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._saslResponse" id="apidoc.element.amqp.Connection.prototype._saslResponse">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_saslResponse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_saslResponse = function () {
  var response;
  if (this.options.authMechanism == &#x27;AMQPLAIN&#x27;)
    response = {
      LOGIN: this.options.login,
      PASSWORD: this.options.password
    };
  else if (this.options.authMechanism == &#x27;PLAIN&#x27;)
    response = &#x22;\0&#x22; + this.options.login + &#x22;\0&#x22; + this.options.password;
  else if (this.options.authMechanism == &#x27;EXTERNAL&#x27;)
    response = &#x22;\0&#x22;;
  else if (this.options.authMechanism == &#x27;ANONYMOUS&#x27;)
    response = &#x22;\0&#x22;;
  else
    response = this.options.response;

  return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendBody" id="apidoc.element.amqp.Connection.prototype._sendBody">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendBody
        <span class="apidocSignatureSpan">(channel, body, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendBody = function (channel, body, properties) {
  var r = this._bodyToBuffer(body);
  var props = r[0], buffer = r[1];

  properties = _.assignIn(props || {}, properties);

  this._sendHeader(channel, buffer.length, properties);

  var pos = 0, len = buffer.length;
  var metaSize = 8; // headerBytes = 7, frameEndBytes = 1
  var maxBodySize = maxFrameBuffer - metaSize;

  while (len &#x3e; 0) {
    var bodySize = len &#x3c; maxBodySize ? len : maxBodySize;
    var frameSize = bodySize + metaSize;

    var b = new Buffer(frameSize);
    b.used = 0;
    b[b.used++] = 3; // constants.frameBody
    serializer.serializeInt(b, 2, channel);
    serializer.serializeInt(b, 4, bodySize);
    buffer.copy(b, b.used, pos, pos+bodySize);
    b.used += bodySize;
    b[b.used++] = 206; // constants.frameEnd;
    this.write(b);

    len -= bodySize;
    pos += bodySize;
  }
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // This interface is probably not appropriate for streaming large files.
    // (Of course it&#x27;s arguable about whether AMQP is the appropriate
    // transport for large files.) The content header wants to know the size
    // of the data before sending it - so there&#x27;s no point in trying to have a
    // general streaming interface - streaming messages of unknown size simply
    // isn&#x27;t possible with AMQP. This is all to say, don&#x27;t send big messages.
    // If you need to stream something large, chunk it yourself.
    self.connection.<span class="apidocCodeKeywordSpan">_sendBody</span>(self.channel, data, options);
  });

  if (self.options.confirm) self._awaitConfirm(task, callback);
  return task;
};

// registers tasks for confirms
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendHeader" id="apidoc.element.amqp.Connection.prototype._sendHeader">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendHeader
        <span class="apidocSignatureSpan">(channel, size, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendHeader = function (channel, size, properties) {
  var b = new Buffer(maxFrameBuffer); // FIXME allocating too much.
                                      // use freelist?
  b.used = 0;

  var classInfo = classes[60]; // always basic class.

  // 7 OCTET FRAME HEADER

  b[b.used++] = 2; // constants.frameHeader

  serializer.serializeInt(b, 2, channel);

  var lengthStart = b.used;

  serializer.serializeInt(b, 4, 0 /*dummy*/); // length

  var bodyStart = b.used;

  // HEADER&#x27;S BODY

  serializer.serializeInt(b, 2, classInfo.index);   // class 60 for Basic
  serializer.serializeInt(b, 2, 0);                 // weight, always 0 for rabbitmq
  serializer.serializeInt(b, 8, size);              // byte size of body

  // properties - first propertyFlags
  properties = _.defaults(properties || {}, {contentType: &#x27;application/octet-stream&#x27;});
  var propertyFlags = 0;
  for (var i = 0; i &#x3c; classInfo.fields.length; i++) {
    if (properties[classInfo.fields[i].name]) propertyFlags |= 1 &#x3c;&#x3c; (15-i);
  }
  serializer.serializeInt(b, 2, propertyFlags);
  // now the actual properties.
  serializer.serializeFields(b, classInfo.fields, properties, false);

  //serializeTable(b, properties);

  var bodyEnd = b.used;

  // Go back to the header and write in the length now that we know it.
  b.used = lengthStart;
  serializer.serializeInt(b, 4, bodyEnd - bodyStart);
  b.used = bodyEnd;

  // 1 OCTET END

  b[b.used++] = 206; // constants.frameEnd;

  var s = new Buffer(b.used);
  b.copy(s);

  //debug &#x26;&#x26; debug(&#x27;header sent: &#x27; + JSON.stringify(s));

  this.write(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendMethod" id="apidoc.element.amqp.Connection.prototype._sendMethod">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendMethod = function (channel, method, args) {
  debug &#x26;&#x26; debug(channel + &#x22; &#x3c; &#x22; + method.name + &#x22; &#x22; + JSON.stringify(args));
  var b = this._sendBuffer;
  b.used = 0;

  b[b.used++] = 1; // constants.frameMethod

  serializer.serializeInt(b, 2, channel);

  var lengthIndex = b.used;

  serializer.serializeInt(b, 4, 42); // replace with actual length.

  var startIndex = b.used;


  serializer.serializeInt(b, 2, method.classIndex); // short, classId
  serializer.serializeInt(b, 2, method.methodIndex); // short, methodId

  serializer.serializeFields(b, method.fields, args, true);

  var endIndex = b.used;

  // write in the frame length now that we know it.
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;

  b[b.used++] = 206; // constants.frameEnd;

  var c = new Buffer(b.used);
  b.copy(c);

  debug &#x26;&#x26; debug(&#x22;sending frame: &#x22; + c.toJSON());

  this.write(c);

  this._outboundHeartbeatTimerReset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._tasks = [];

  this.reconnect();
};
util.inherits(Channel, events.EventEmitter);

Channel.prototype.closeOK = function() {
  this.connection.<span class="apidocCodeKeywordSpan">_sendMethod</span>(this.channel, methods.channelCloseOk, {reserved1: &#x22
;&#x22;});
};

Channel.prototype.reconnect = function () {
  this.connection._sendMethod(this.channel, methods.channelOpen, {reserved1: &#x22;&#x22;});
};

Channel.prototype._taskPush = function (reply, cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._startHandshake" id="apidoc.element.amqp.Connection.prototype._startHandshake">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_startHandshake
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_startHandshake = function () {
  debug &#x26;&#x26; debug(&#x22;Initiating handshake...&#x22;);
  this.write(&#x22;AMQP&#x22; + String.fromCharCode(0,0,9,1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.addAllListeners" id="apidoc.element.amqp.Connection.prototype.addAllListeners">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>addAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addAllListeners = function () {
  var self = this;
  var connectEvent = this.options.ssl.enabled ? &#x27;secureConnect&#x27; : &#x27;connect&#x27;;


  self.addListener(connectEvent, function() {
    // In the case where this is a reconnection, do not trample on the existing
    // channels.
    // For your reference, channel 0 is the control channel.
    self.channels = self.channels || {0:self};
    self.queues = self.queues || {};
    self.exchanges = self.exchanges || {};

    self.parser = new AMQPParser(&#x27;0-9-1&#x27;, &#x27;client&#x27;);

    self.parser.onMethod = function (channel, method, args) {
      self._onMethod(channel, method, args);
    };

    self.parser.onContent = function (channel, data) {
      debug &#x26;&#x26; debug(channel + &#x22; &#x3e; content &#x22; + data.length);
      if (self.channels[channel] &#x26;&#x26; self.channels[channel]._onContent) {
        self.channels[channel]._onContent(channel, data);
      } else {
        debug &#x26;&#x26; debug(&#x22;unhandled content: &#x22; + data);
      }
    };

    self.parser.onContentHeader = function (channel, classInfo, weight, properties, size) {
      debug &#x26;&#x26; debug(channel + &#x22; &#x3e; content header &#x22; + JSON.stringify([classInfo.name, weight, properties, size]));
      if (self.channels[channel] &#x26;&#x26; self.channels[channel]._onContentHeader) {
        self.channels[channel]._onContentHeader(channel, classInfo, weight, properties, size);
      } else {
        debug &#x26;&#x26; debug(&#x22;unhandled content header&#x22;);
      }
    };

    self.parser.onHeartBeat = function () {
      self.emit(&#x22;heartbeat&#x22;);
      debug &#x26;&#x26; debug(&#x22;heartbeat&#x22;);
    };

    self.parser.onError = function (e) {
      self.emit(&#x22;error&#x22;, e);
      self.emit(&#x22;close&#x22;);
    };

    // Remove readyEmitted flag so we can detect an auth error.
    self.readyEmitted = false;
  });

  self.addListener(&#x27;data&#x27;, function (data) {
    if(self.parser != null){
      try {
        self.parser.execute(data);
      } catch (exception) {
        self.emit(&#x27;error&#x27;, exception);
        return;
      }
    }
    self._inboundHeartbeatTimerReset();
  });

  var backoffTime = null;
  self.addListener(&#x27;error&#x27;, function backoff(e) {
    if (self._inboundHeartbeatTimer !== null) {
      clearTimeout(self._inboundHeartbeatTimer);
      self._inboundHeartbeatTimer = null;
    }
    if (self._outboundHeartbeatTimer !== null) {
      clearTimeout(self._outboundHeartbeatTimer);
      self._outboundHeartbeatTimer = null;
    }

    if (!self.connectionAttemptScheduled) {
      // Set to true, as we are presently in the process of scheduling one.
      self.connectionAttemptScheduled = true;

      // Kill the socket, if it hasn&#x27;t been killed already.
      self.socket.end();

      // Reset parser state
      self.parser = null;

      // In order for our reconnection to be seamless, we have to notify the
      // channels that they are no longer connected so that nobody attempts
      // to send messages which would be doomed to fail.
      for (var channel in self.channels) {
        if (channel !== &#x27;0&#x27;) {
          self.channels[channel].state = &#x27;closed&#x27;;
        }
      }
      // Queues are channels (so we have already marked them as closed), but
      // queues have special needs, since the subscriptions will no longer
      // be known to the server when we reconnect.  Mark the subscriptions as
      // closed so that we can resubscribe them once we are reconnected.
      for (var queue in self.queues) {
        for (var index in self.queues[queue].consumerTagOptions) {
          self.queues[queue].consumerTagOptions[index][&#x27;state&#x27;] = &#x27;closed&#x27;;
        }
      }

      // Begin reconnection attempts
      if (self.implOptions.reconnect) {
        // Don&#x27;t thrash, use a backoff strategy.
        if (backoffTime === null) {
          // This is the first time we&#x27;ve failed since a successful connection,
          // so use the configured backoff time without any modification.
          backoffTime = self.implOptions.reconnectBackoffTime;
        } else if (self.implOptions.reconnectBackoffStrategy === &#x27;exponential&#x27;) {
          // If you&#x27;ve configured exponential backoff, we&#x27;ll double the
          // backoff time each ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.connect" id="apidoc.element.amqp.Connection.prototype.connect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  // If this is our first connection, add listeners.
  if (!this.socket) this.addAllListeners();

  this._createSocket();
  this._startHandshake();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
});
```

## Connection

`new amqp.Connection()` Instantiates a new connection. Use
`connection.<span class="apidocCodeKeywordSpan">connect</span>()` to connect to a server.

`amqp.createConnection()` returns an instance of `amqp.Connection`, which contains
an instance of `net.Socket` at its `socket` property. All events and methods which work on
`net.Socket` can also be used on an `amqp.Connection` instance. (e.g., the
events `&#x27;connect&#x27;` and `&#x27;close&#x27;`.)

### Connection options and URL
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.disconnect" id="apidoc.element.amqp.Connection.prototype.disconnect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function () {
  debug &#x26;&#x26; debug(&#x22;Sending disconnect request to server&#x22;);
  this._sendMethod(0, methods.connectionClose, {
    &#x27;replyText&#x27;: &#x27;client disconnect&#x27;,
    &#x27;replyCode&#x27;: 200,
    &#x27;classId&#x27;: 0,
    &#x27;methodId&#x27;: 0
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Table of Contents

- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.<span class="apidocCodeKeywordSpan">disconnect</span>()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.end" id="apidoc.element.amqp.Connection.prototype.end">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  if (this.socket) {
    this.socket.end();
  }

  this.options.heartbeat = false;

  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }

  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
    });

    m.addListener(&#x27;end&#x27;, function () {
var json, deliveryInfo = {}, msgProperties = classes[60].fields, i, l;

if (isJSON) {
  decoder.<span class="apidocCodeKeywordSpan">end</span>();
  try {
    json = JSON.parse(buffer);
  } catch (e) {
    json = null;
    deliveryInfo.parseError = e;
    deliveryInfo.rawData = buffer;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchange" id="apidoc.element.amqp.Connection.prototype.exchange">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchange
        <span class="apidocSignatureSpan">(name, options, openCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exchange = function (name, options, openCallback) {
  if (name === undefined) name = this.implOptions.defaultExchangeName;

  if (!options) options = {};
  if (name !== &#x27;&#x27; &#x26;&#x26; options.type === undefined) options.type = &#x27;topic&#x27;;

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit(&#x22;error&#x22;, exception);
    return;
  }
  var exchange = new Exchange(this, channel, name, options, openCallback);
  this.channels[channel] = exchange;
  this.exchanges[name] = exchange;
  return exchange;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.<span class="apidocCodeKeywordSpan">exchange</span>()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
- [exchange.unbind(srcExchange, routingKey [, callback])](#exchangeunbindsrcexchange-routingkey--callback)
- [exchange.bind_headers(exchange, routing [, bindCallback])](#exchangebind_headersexchange-routing--bindcallback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchangeClosed" id="apidoc.element.amqp.Connection.prototype.exchangeClosed">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchangeClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exchangeClosed = function (name) {
  if (this.exchanges[name]) delete this.exchanges[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._openCallback = null;
  }
  break;

case methods.channelClose:
  this.state = &#x22;closed&#x22;;
  this.closeOK();
  this.connection.<span class="apidocCodeKeywordSpan">exchangeClosed</span>(this.name);
  var e = new Error(args.replyText);
  e.code = args.replyCode;
  this.emit(&#x27;error&#x27;, e);
  this.emit(&#x27;close&#x27;);
  break;

case methods.channelCloseOk:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.generateChannelId" id="apidoc.element.amqp.Connection.prototype.generateChannelId">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>generateChannelId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateChannelId = function () {
  // start from the last used slot id
  var channelId = this.channelCounter;
  while(true){
    // use values in range of 1..65535
    channelId = channelId % channelMax + 1;
    if(!this.channels[channelId]){
      break;
    }
    // after a full loop throw an Error
    if(channelId == this.channelCounter){
      throw new Error(&#x22;No valid Channel Id values available&#x22;);
    }
  }
  this.channelCounter = channelId;
  return this.channelCounter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.heartbeat" id="apidoc.element.amqp.Connection.prototype.heartbeat">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heartbeat = function () {
  if(this.socket.writable) this.write(new Buffer([8,0,0,0,0,0,0,206]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.publish" id="apidoc.element.amqp.Connection.prototype.publish">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>publish
        <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (routingKey, body, options, callback) {
  if (!this._defaultExchange) {
    this._defaultExchange = this.exchange();
  }

  var exchange = this._defaultExchange;
  if (exchange.state === &#x27;open&#x27;) {
    exchange.publish(routingKey, body, options, callback);
  } else {
    exchange.once(&#x27;open&#x27;, function() {
      exchange.publish(routingKey, body, options, callback);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Table of Contents

- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.<span class="apidocCodeKeywordSpan">publish</span>(routingKey, body, options, callback)](#connectionpublishroutingkey
-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queue" id="apidoc.element.amqp.Connection.prototype.queue">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queue
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (name) {
  var options, callback;
  if (typeof arguments[1] == &#x27;object&#x27;) {
    options = arguments[1];
    callback = arguments[2];
  } else {
    callback = arguments[1];
  }

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit(&#x22;error&#x22;, exception);
    return;
  }

  var q = new Queue(this, channel, name, options, callback);
  this.channels[channel] = q;
  return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.<span class="apidocCodeKeywordSpan">queue</span>(name[, options][, openCallback])](#connectionqueuename-options-opencallback
)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queueClosed" id="apidoc.element.amqp.Connection.prototype.queueClosed">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queueClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queueClosed = function (name) {
  if (this.queues[name]) delete this.queues[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Queue.prototype.destroy = function (options) {
var self = this;

options = options || {};
return this._taskPush(methods.queueDeleteOk, function () {
  self.connection.<span class="apidocCodeKeywordSpan">queueClosed</span>(self.name);
  if (&#x27;exchange&#x27; in self) {
    self.exchange.binds--;
  }
  self.connection._sendMethod(self.channel, methods.queueDelete,
      { reserved1: 0
      , queue: self.name
      , ifUnused: options.ifUnused ? true : false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.reconnect" id="apidoc.element.amqp.Connection.prototype.reconnect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>reconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnect = function () {
  // Suspend activity on channels
  for (var channel in this.channels) {
    this.channels[channel].state = &#x27;closed&#x27;;
  }
  debug &#x26;&#x26; debug(&#x22;Connection lost, reconnecting...&#x22;);
  // Terminate socket activity
  if (this.socket) this.socket.end();
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.<span class="apidocCodeKeywordSpan">reconnect</span>();
};
util.inherits(Channel, events.EventEmitter);

Channel.prototype.closeOK = function() {
  this.connection._sendMethod(this.channel, methods.channelCloseOk, {reserved1: &#x22;&#x22;});
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setImplOptions" id="apidoc.element.amqp.Connection.prototype.setImplOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setImplOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImplOptions = function (options) {
  this.implOptions = _.assignIn({}, defaultImplOptions, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setOptions" id="apidoc.element.amqp.Connection.prototype.setOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOptions = function (options) {
  var urlo = (options &#x26;&#x26; options.url) ? this._parseURLOptions(options.url) : {};
  var sslo = (options &#x26;&#x26; options.ssl &#x26;&#x26; options.ssl.enabled) ? defaultSslOptions : {};
  this.options = _.assignIn({}, defaultOptions, sslo, urlo, options || {});
  this.options.clientProperties =  _.assignIn({}, defaultClientProperties, (options &#x26;&#x26; options.clientProperties) || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._bodyToBuffer" id="apidoc.module.amqp.Connection.prototype._bodyToBuffer">module amqp.Connection.prototype._bodyToBuffer</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer._bodyToBuffer" id="apidoc.element.amqp.Connection.prototype._bodyToBuffer._bodyToBuffer">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_bodyToBuffer
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_bodyToBuffer = function (body) {
  // Handles 3 cases
  // - body is utf8 string
  // - body is instance of Buffer
  // - body is an object and its JSON representation is sent
  // Does not handle the case for streaming bodies.
  // Returns buffer.
  if (typeof(body) == &#x27;string&#x27;) {
    return [null, new Buffer(body, &#x27;utf8&#x27;)];
  } else if (body instanceof Buffer) {
    return [null, body];
  } else {
    var jsonBody = JSON.stringify(body);

    debug &#x26;&#x26; debug(&#x27;sending json: &#x27; + jsonBody);

    var props = {contentType: &#x27;application/json&#x27;};
    return [props, new Buffer(jsonBody, &#x27;utf8&#x27;)];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._chooseHost" id="apidoc.module.amqp.Connection.prototype._chooseHost">module amqp.Connection.prototype._chooseHost</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._chooseHost._chooseHost" id="apidoc.element.amqp.Connection.prototype._chooseHost._chooseHost">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_chooseHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_chooseHost = function () {
  if(Array.isArray(this.options.host)){
    if(this.hosti == null){
      if(typeof this.options.hostPreference == &#x27;number&#x27;) {
        this.hosti = (this.options.hostPreference &#x3c; this.options.host.length) ?
          this.options.hostPreference : this.options.host.length-1;
      } else {
        this.hosti = parseInt(Math.random() * this.options.host.length, 10);
      }
    } else {
      // If this is already set, it looks like we want to choose another one.
      // Add one to hosti but don&#x27;t overflow it.
      this.hosti = (this.hosti + 1) % this.options.host.length;
    }
    return this.options.host[this.hosti];
  } else {
    return this.options.host;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._createSocket" id="apidoc.module.amqp.Connection.prototype._createSocket">module amqp.Connection.prototype._createSocket</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._createSocket._createSocket" id="apidoc.element.amqp.Connection.prototype._createSocket._createSocket">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_createSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createSocket = function () {
  var hostName = this._chooseHost(), self = this, port = this.options.port;
  var parsedHost = URL.parse(hostName);
  if(parsedHost.port){
    hostName = parsedHost.hostname;
    port = parsedHost.port;
  }

  var options = {
    port: port,
    host: hostName
  };

  // Disable tcp nagle&#x27;s algo
  // Default: true, makes small messages faster
  var noDelay = this.options.noDelay || true;

  var resetConnectionTimeout = function () {
    debug &#x26;&#x26; debug(&#x27;connected so resetting connection timeout&#x27;);
    this.setTimeout(0);
  };

  // Connect socket
  if (this.options.ssl.enabled) {
    debug &#x26;&#x26; debug(&#x27;making ssl connection&#x27;);
    options = _.assignIn(options, this._getSSLOptions());
    this.socket = tls.connect(options, resetConnectionTimeout);
  } else {
    debug &#x26;&#x26; debug(&#x27;making non-ssl connection&#x27;);
    this.socket = net.connect(options, resetConnectionTimeout);
  }
  var connTimeout = this.options.connectionTimeout;
  if (connTimeout) {
    debug &#x26;&#x26; debug(&#x27;setting connection timeout to &#x27; + connTimeout);
    this.socket.setTimeout(connTimeout, function () {
      debug &#x26;&#x26; debug(&#x27;connection timeout&#x27;);
      this.destroy();
      var e = new Error(&#x27;connection timeout&#x27;);
      e.name = &#x27;TimeoutError&#x27;;
      self.emit(&#x27;error&#x27;, e);
    });
  }

  this.socket.setNoDelay(noDelay);

  // Proxy events.
  // Note that if we don&#x27;t attach a &#x27;data&#x27; event, no data will flow.
  var events = [&#x27;close&#x27;, &#x27;connect&#x27;, &#x27;data&#x27;, &#x27;drain&#x27;, &#x27;error&#x27;, &#x27;end&#x27;, &#x27;secureConnect&#x27;, &#x27;timeout&#x27;];
  _.forEach(events, function(event){
    self.socket.on(event, self.emit.bind(self, event));
  });

  // Proxy a few methods that we use / previously used.
  var methods = [&#x27;destroy&#x27;, &#x27;write&#x27;, &#x27;pause&#x27;, &#x27;resume&#x27;, &#x27;setEncoding&#x27;, &#x27;ref&#x27;, &#x27;unref&#x27;, &#x27;address&#x27;];
  _.forEach(methods, function(method){
    self[method] = function(){
      self.socket[method].apply(self.socket, arguments);
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._getSSLOptions" id="apidoc.module.amqp.Connection.prototype._getSSLOptions">module amqp.Connection.prototype._getSSLOptions</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._getSSLOptions._getSSLOptions" id="apidoc.element.amqp.Connection.prototype._getSSLOptions._getSSLOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_getSSLOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSSLOptions = function () {
  if (this.sslConnectionOptions) return this.sslConnectionOptions;
  this.sslConnectionOptions = {};

  if (this.options.ssl.pfxFile) {
    this.sslConnectionOptions.pfx = fs.readFileSync(this.options.ssl.pfxFile);
  }
  if (this.options.ssl.keyFile) {
    this.sslConnectionOptions.key = fs.readFileSync(this.options.ssl.keyFile);
  }
  if (this.options.ssl.certFile) {
    this.sslConnectionOptions.cert = fs.readFileSync(this.options.ssl.certFile);
  }
  if (this.options.ssl.caFile) {
    if (Array.isArray(this.options.ssl.caFile)) {
      this.sslConnectionOptions.ca = this.options.ssl.caFile.map(function(f){
        return fs.readFileSync(f);
      });
    } else {
      this.sslConnectionOptions.ca = fs.readFileSync(this.options.ssl.caFile);
    }
  }

  this.sslConnectionOptions.rejectUnauthorized = this.options.ssl.rejectUnauthorized;
  this.sslConnectionOptions.passphrase = this.options.ssl.passphrase;

  return this.sslConnectionOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._inboundHeartbeatTimerReset" id="apidoc.module.amqp.Connection.prototype._inboundHeartbeatTimerReset">module amqp.Connection.prototype._inboundHeartbeatTimerReset</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset._inboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset._inboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_inboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_inboundHeartbeatTimerReset = function () {
  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }
  if (this.options.heartbeat) {
    var self = this;
    var gracePeriod = 2 * this.options.heartbeat;
    this._inboundHeartbeatTimer = setTimeout(function () {
      if(self.socket.readable || self.options.heartbeatForceReconnect){
        self.emit(&#x27;error&#x27;, new Error(&#x27;no heartbeat or data in last &#x27; + gracePeriod + &#x27; seconds&#x27;));
      }
    }, gracePeriod * 1000);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._onMethod" id="apidoc.module.amqp.Connection.prototype._onMethod">module amqp.Connection.prototype._onMethod</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._onMethod._onMethod" id="apidoc.element.amqp.Connection.prototype._onMethod._onMethod">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_onMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onMethod = function (channel, method, args) {
  debug &#x26;&#x26; debug(channel + &#x22; &#x3e; &#x22; + method.name + &#x22; &#x22; + JSON.stringify(args));

  // Channel 0 is the control channel. If not zero then delegate to
  // one of the channel objects.

  if (channel &#x3e; 0) {
    if (!this.channels[channel]) {
      debug &#x26;&#x26; debug(&#x22;Received message on untracked channel.&#x22;);
      return;
    }
    if (!this.channels[channel]._onChannelMethod) {
      throw new Error(&#x27;Channel &#x27; + channel + &#x27; has no _onChannelMethod method.&#x27;);
    }
    this.channels[channel]._onChannelMethod(channel, method, args);
    return;
  }

  // channel 0

  switch (method) {
    // 2. The server responds, after the version string, with the
    // &#x27;connectionStart&#x27; method (contains various useless information)
    case methods.connectionStart:
      // We check that they&#x27;re serving us AMQP 0-9
      if (args.versionMajor !== 0 &#x26;&#x26; args.versionMinor != 9) {
        this.socket.end();
        this.emit(&#x27;error&#x27;, new Error(&#x22;Bad server version&#x22;));
        return;
      }
      this.serverProperties = args.serverProperties;
      // 3. Then we reply with StartOk, containing our useless information.
      this._sendMethod(0, methods.connectionStartOk, {
        clientProperties: this.options.clientProperties,
        mechanism: this.options.authMechanism,
        response: this._saslResponse(),
        locale: &#x27;en_US&#x27;
      });
      break;

    // 4. The server responds with a connectionTune request
    case methods.connectionTune:
      if (args.frameMax) {
          debug &#x26;&#x26; debug(&#x22;tweaking maxFrameBuffer to &#x22; + args.frameMax);
          maxFrameBuffer = args.frameMax;
          this._sendBuffer = new Buffer(maxFrameBuffer);
          this.parser.setMaxFrameBuffer(maxFrameBuffer);
      }
      if (args.channelMax) {
          debug &#x26;&#x26; debug(&#x22;tweaking channelMax to &#x22; + args.channelMax);
          channelMax = args.channelMax;
      }
      // 5. We respond with connectionTuneOk
      this._sendMethod(0, methods.connectionTuneOk, {
        channelMax: channelMax,
        frameMax: maxFrameBuffer,
        heartbeat: this.options.heartbeat || 0
      });
      // 6. Then we have to send a connectionOpen request
      this._sendMethod(0, methods.connectionOpen, {
        virtualHost: this.options.vhost
        // , capabilities: &#x27;&#x27;
        // , insist: true
        ,
        reserved1: &#x27;&#x27;,
        reserved2: true
      });
      break;


    case methods.connectionOpenOk:
      // 7. Finally they respond with connectionOpenOk
      // Whew! That&#x27;s why they call it the Advanced MQP.
      if (this._readyCallback) {
        this._readyCallback(this);
        this._readyCallback = null;
      }
      this.emit(&#x27;ready&#x27;);
      break;

    case methods.connectionClose:
      var e = new Error(args.replyText);
      e.code = args.replyCode;
      if (!this.listeners(&#x27;close&#x27;).length) {
        console.log(&#x27;Unhandled connection error: &#x27; + args.replyText);
      }
      this.socket.destroy(e);
      break;

    case methods.connectionCloseOk:
      debug &#x26;&#x26; debug(&#x22;Received close-ok from server, closing socket&#x22;);
      this.socket.end();
      break;

    case methods.connectionBlocked:
      debug &#x26;&#x26; debug(&#x27;Received connection.blocked from server with reason: &#x27; + args.reason);
      this._blocked = true;
      this._blockedReason = args.reason;
      this.emit(&#x27;blocked&#x27;);
      break;

    case methods.connectionUnblocked:
      debug &#x26;&#x26; debug(&#x27;Received connection.unblocked from server&#x27;);
      this._blocked = false;
      this._blockedReason = null;
      this.emit(&#x27;unblocked&#x27;);
      break;

    default:
      throw new Error(&#x22;Uncaught method &#x27;&#x22; + method.name + &#x22;&#x27; with args &#x22; +
          JSON.stringify(args));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Channel.prototype._onChannelMethod = function(channel, method, args) {
switch (method) {
  case methods.channelCloseOk:
    delete this.connection.channels[this.channel];
    this.state = &#x27;closed&#x27;;
    // TODO should this be falling through?
  default:
    this.<span class="apidocCodeKeywordSpan">_onMethod</span>(channel, method, args);
}
};

Channel.prototype.close = function(reason) {
this.state = &#x27;closing&#x27;;
this.connection._sendMethod(this.channel, methods.channelClose,
                            {&#x27;replyText&#x27;: reason ? reason : &#x27;Goodbye from node&#x27;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._outboundHeartbeatTimerReset" id="apidoc.module.amqp.Connection.prototype._outboundHeartbeatTimerReset">module amqp.Connection.prototype._outboundHeartbeatTimerReset</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset._outboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset._outboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_outboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_outboundHeartbeatTimerReset = function () {
  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
  if (this.socket.writable &#x26;&#x26; this.options.heartbeat) {
    var self = this;
    this._outboundHeartbeatTimer = setTimeout(function () {
      self.heartbeat();
      self._outboundHeartbeatTimerReset();
    }, 1000 * this.options.heartbeat);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._parseURLOptions" id="apidoc.module.amqp.Connection.prototype._parseURLOptions">module amqp.Connection.prototype._parseURLOptions</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._parseURLOptions._parseURLOptions" id="apidoc.element.amqp.Connection.prototype._parseURLOptions._parseURLOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_parseURLOptions
        <span class="apidocSignatureSpan">(connectionString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseURLOptions = function (connectionString) {
  var opts = {};
  opts.ssl = {};
  var url = URL.parse(connectionString);
  var scheme = url.protocol.substring(0, url.protocol.lastIndexOf(&#x27;:&#x27;));
  if (scheme != &#x27;amqp&#x27; &#x26;&#x26; scheme != &#x27;amqps&#x27;) {
    throw new Error(&#x27;Connection URI must use amqp or amqps scheme. &#x27; +
                    &#x27;For example, &#x22;amqp://bus.megacorp.internal:5766&#x22;.&#x27;);
  }
  opts.ssl.enabled = (&#x27;amqps&#x27; === scheme);
  opts.host = url.hostname;
  opts.port = url.port || defaultPorts[scheme];
  if (url.auth) {
    var auth = url.auth.split(&#x27;:&#x27;);
    auth[0] &#x26;&#x26; (opts.login = auth[0]);
    auth[1] &#x26;&#x26; (opts.password = auth[1]);
  }
  if (url.pathname) {
    opts.vhost = unescape(url.pathname.substr(1));
  }
  return opts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._saslResponse" id="apidoc.module.amqp.Connection.prototype._saslResponse">module amqp.Connection.prototype._saslResponse</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._saslResponse._saslResponse" id="apidoc.element.amqp.Connection.prototype._saslResponse._saslResponse">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_saslResponse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_saslResponse = function () {
  var response;
  if (this.options.authMechanism == &#x27;AMQPLAIN&#x27;)
    response = {
      LOGIN: this.options.login,
      PASSWORD: this.options.password
    };
  else if (this.options.authMechanism == &#x27;PLAIN&#x27;)
    response = &#x22;\0&#x22; + this.options.login + &#x22;\0&#x22; + this.options.password;
  else if (this.options.authMechanism == &#x27;EXTERNAL&#x27;)
    response = &#x22;\0&#x22;;
  else if (this.options.authMechanism == &#x27;ANONYMOUS&#x27;)
    response = &#x22;\0&#x22;;
  else
    response = this.options.response;

  return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._sendBody" id="apidoc.module.amqp.Connection.prototype._sendBody">module amqp.Connection.prototype._sendBody</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendBody._sendBody" id="apidoc.element.amqp.Connection.prototype._sendBody._sendBody">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendBody
        <span class="apidocSignatureSpan">(channel, body, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendBody = function (channel, body, properties) {
  var r = this._bodyToBuffer(body);
  var props = r[0], buffer = r[1];

  properties = _.assignIn(props || {}, properties);

  this._sendHeader(channel, buffer.length, properties);

  var pos = 0, len = buffer.length;
  var metaSize = 8; // headerBytes = 7, frameEndBytes = 1
  var maxBodySize = maxFrameBuffer - metaSize;

  while (len &#x3e; 0) {
    var bodySize = len &#x3c; maxBodySize ? len : maxBodySize;
    var frameSize = bodySize + metaSize;

    var b = new Buffer(frameSize);
    b.used = 0;
    b[b.used++] = 3; // constants.frameBody
    serializer.serializeInt(b, 2, channel);
    serializer.serializeInt(b, 4, bodySize);
    buffer.copy(b, b.used, pos, pos+bodySize);
    b.used += bodySize;
    b[b.used++] = 206; // constants.frameEnd;
    this.write(b);

    len -= bodySize;
    pos += bodySize;
  }
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // This interface is probably not appropriate for streaming large files.
    // (Of course it&#x27;s arguable about whether AMQP is the appropriate
    // transport for large files.) The content header wants to know the size
    // of the data before sending it - so there&#x27;s no point in trying to have a
    // general streaming interface - streaming messages of unknown size simply
    // isn&#x27;t possible with AMQP. This is all to say, don&#x27;t send big messages.
    // If you need to stream something large, chunk it yourself.
    self.connection.<span class="apidocCodeKeywordSpan">_sendBody</span>(self.channel, data, options);
  });

  if (self.options.confirm) self._awaitConfirm(task, callback);
  return task;
};

// registers tasks for confirms
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._sendHeader" id="apidoc.module.amqp.Connection.prototype._sendHeader">module amqp.Connection.prototype._sendHeader</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendHeader._sendHeader" id="apidoc.element.amqp.Connection.prototype._sendHeader._sendHeader">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendHeader
        <span class="apidocSignatureSpan">(channel, size, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendHeader = function (channel, size, properties) {
  var b = new Buffer(maxFrameBuffer); // FIXME allocating too much.
                                      // use freelist?
  b.used = 0;

  var classInfo = classes[60]; // always basic class.

  // 7 OCTET FRAME HEADER

  b[b.used++] = 2; // constants.frameHeader

  serializer.serializeInt(b, 2, channel);

  var lengthStart = b.used;

  serializer.serializeInt(b, 4, 0 /*dummy*/); // length

  var bodyStart = b.used;

  // HEADER&#x27;S BODY

  serializer.serializeInt(b, 2, classInfo.index);   // class 60 for Basic
  serializer.serializeInt(b, 2, 0);                 // weight, always 0 for rabbitmq
  serializer.serializeInt(b, 8, size);              // byte size of body

  // properties - first propertyFlags
  properties = _.defaults(properties || {}, {contentType: &#x27;application/octet-stream&#x27;});
  var propertyFlags = 0;
  for (var i = 0; i &#x3c; classInfo.fields.length; i++) {
    if (properties[classInfo.fields[i].name]) propertyFlags |= 1 &#x3c;&#x3c; (15-i);
  }
  serializer.serializeInt(b, 2, propertyFlags);
  // now the actual properties.
  serializer.serializeFields(b, classInfo.fields, properties, false);

  //serializeTable(b, properties);

  var bodyEnd = b.used;

  // Go back to the header and write in the length now that we know it.
  b.used = lengthStart;
  serializer.serializeInt(b, 4, bodyEnd - bodyStart);
  b.used = bodyEnd;

  // 1 OCTET END

  b[b.used++] = 206; // constants.frameEnd;

  var s = new Buffer(b.used);
  b.copy(s);

  //debug &#x26;&#x26; debug(&#x27;header sent: &#x27; + JSON.stringify(s));

  this.write(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._sendMethod" id="apidoc.module.amqp.Connection.prototype._sendMethod">module amqp.Connection.prototype._sendMethod</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendMethod._sendMethod" id="apidoc.element.amqp.Connection.prototype._sendMethod._sendMethod">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendMethod = function (channel, method, args) {
  debug &#x26;&#x26; debug(channel + &#x22; &#x3c; &#x22; + method.name + &#x22; &#x22; + JSON.stringify(args));
  var b = this._sendBuffer;
  b.used = 0;

  b[b.used++] = 1; // constants.frameMethod

  serializer.serializeInt(b, 2, channel);

  var lengthIndex = b.used;

  serializer.serializeInt(b, 4, 42); // replace with actual length.

  var startIndex = b.used;


  serializer.serializeInt(b, 2, method.classIndex); // short, classId
  serializer.serializeInt(b, 2, method.methodIndex); // short, methodId

  serializer.serializeFields(b, method.fields, args, true);

  var endIndex = b.used;

  // write in the frame length now that we know it.
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;

  b[b.used++] = 206; // constants.frameEnd;

  var c = new Buffer(b.used);
  b.copy(c);

  debug &#x26;&#x26; debug(&#x22;sending frame: &#x22; + c.toJSON());

  this.write(c);

  this._outboundHeartbeatTimerReset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._tasks = [];

  this.reconnect();
};
util.inherits(Channel, events.EventEmitter);

Channel.prototype.closeOK = function() {
  this.connection.<span class="apidocCodeKeywordSpan">_sendMethod</span>(this.channel, methods.channelCloseOk, {reserved1: &#x22
;&#x22;});
};

Channel.prototype.reconnect = function () {
  this.connection._sendMethod(this.channel, methods.channelOpen, {reserved1: &#x22;&#x22;});
};

Channel.prototype._taskPush = function (reply, cb) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._startHandshake" id="apidoc.module.amqp.Connection.prototype._startHandshake">module amqp.Connection.prototype._startHandshake</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._startHandshake._startHandshake" id="apidoc.element.amqp.Connection.prototype._startHandshake._startHandshake">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_startHandshake
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_startHandshake = function () {
  debug &#x26;&#x26; debug(&#x22;Initiating handshake...&#x22;);
  this.write(&#x22;AMQP&#x22; + String.fromCharCode(0,0,9,1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.addAllListeners" id="apidoc.module.amqp.Connection.prototype.addAllListeners">module amqp.Connection.prototype.addAllListeners</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.addAllListeners.addAllListeners" id="apidoc.element.amqp.Connection.prototype.addAllListeners.addAllListeners">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>addAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addAllListeners = function () {
  var self = this;
  var connectEvent = this.options.ssl.enabled ? &#x27;secureConnect&#x27; : &#x27;connect&#x27;;


  self.addListener(connectEvent, function() {
    // In the case where this is a reconnection, do not trample on the existing
    // channels.
    // For your reference, channel 0 is the control channel.
    self.channels = self.channels || {0:self};
    self.queues = self.queues || {};
    self.exchanges = self.exchanges || {};

    self.parser = new AMQPParser(&#x27;0-9-1&#x27;, &#x27;client&#x27;);

    self.parser.onMethod = function (channel, method, args) {
      self._onMethod(channel, method, args);
    };

    self.parser.onContent = function (channel, data) {
      debug &#x26;&#x26; debug(channel + &#x22; &#x3e; content &#x22; + data.length);
      if (self.channels[channel] &#x26;&#x26; self.channels[channel]._onContent) {
        self.channels[channel]._onContent(channel, data);
      } else {
        debug &#x26;&#x26; debug(&#x22;unhandled content: &#x22; + data);
      }
    };

    self.parser.onContentHeader = function (channel, classInfo, weight, properties, size) {
      debug &#x26;&#x26; debug(channel + &#x22; &#x3e; content header &#x22; + JSON.stringify([classInfo.name, weight, properties, size]));
      if (self.channels[channel] &#x26;&#x26; self.channels[channel]._onContentHeader) {
        self.channels[channel]._onContentHeader(channel, classInfo, weight, properties, size);
      } else {
        debug &#x26;&#x26; debug(&#x22;unhandled content header&#x22;);
      }
    };

    self.parser.onHeartBeat = function () {
      self.emit(&#x22;heartbeat&#x22;);
      debug &#x26;&#x26; debug(&#x22;heartbeat&#x22;);
    };

    self.parser.onError = function (e) {
      self.emit(&#x22;error&#x22;, e);
      self.emit(&#x22;close&#x22;);
    };

    // Remove readyEmitted flag so we can detect an auth error.
    self.readyEmitted = false;
  });

  self.addListener(&#x27;data&#x27;, function (data) {
    if(self.parser != null){
      try {
        self.parser.execute(data);
      } catch (exception) {
        self.emit(&#x27;error&#x27;, exception);
        return;
      }
    }
    self._inboundHeartbeatTimerReset();
  });

  var backoffTime = null;
  self.addListener(&#x27;error&#x27;, function backoff(e) {
    if (self._inboundHeartbeatTimer !== null) {
      clearTimeout(self._inboundHeartbeatTimer);
      self._inboundHeartbeatTimer = null;
    }
    if (self._outboundHeartbeatTimer !== null) {
      clearTimeout(self._outboundHeartbeatTimer);
      self._outboundHeartbeatTimer = null;
    }

    if (!self.connectionAttemptScheduled) {
      // Set to true, as we are presently in the process of scheduling one.
      self.connectionAttemptScheduled = true;

      // Kill the socket, if it hasn&#x27;t been killed already.
      self.socket.end();

      // Reset parser state
      self.parser = null;

      // In order for our reconnection to be seamless, we have to notify the
      // channels that they are no longer connected so that nobody attempts
      // to send messages which would be doomed to fail.
      for (var channel in self.channels) {
        if (channel !== &#x27;0&#x27;) {
          self.channels[channel].state = &#x27;closed&#x27;;
        }
      }
      // Queues are channels (so we have already marked them as closed), but
      // queues have special needs, since the subscriptions will no longer
      // be known to the server when we reconnect.  Mark the subscriptions as
      // closed so that we can resubscribe them once we are reconnected.
      for (var queue in self.queues) {
        for (var index in self.queues[queue].consumerTagOptions) {
          self.queues[queue].consumerTagOptions[index][&#x27;state&#x27;] = &#x27;closed&#x27;;
        }
      }

      // Begin reconnection attempts
      if (self.implOptions.reconnect) {
        // Don&#x27;t thrash, use a backoff strategy.
        if (backoffTime === null) {
          // This is the first time we&#x27;ve failed since a successful connection,
          // so use the configured backoff time without any modification.
          backoffTime = self.implOptions.reconnectBackoffTime;
        } else if (self.implOptions.reconnectBackoffStrategy === &#x27;exponential&#x27;) {
          // If you&#x27;ve configured exponential backoff, we&#x27;ll double the
          // backoff time each ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.connect" id="apidoc.module.amqp.Connection.prototype.connect">module amqp.Connection.prototype.connect</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.connect.connect" id="apidoc.element.amqp.Connection.prototype.connect.connect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  // If this is our first connection, add listeners.
  if (!this.socket) this.addAllListeners();

  this._createSocket();
  this._startHandshake();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
});
```

## Connection

`new amqp.Connection()` Instantiates a new connection. Use
`connection.<span class="apidocCodeKeywordSpan">connect</span>()` to connect to a server.

`amqp.createConnection()` returns an instance of `amqp.Connection`, which contains
an instance of `net.Socket` at its `socket` property. All events and methods which work on
`net.Socket` can also be used on an `amqp.Connection` instance. (e.g., the
events `&#x27;connect&#x27;` and `&#x27;close&#x27;`.)

### Connection options and URL
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.disconnect" id="apidoc.module.amqp.Connection.prototype.disconnect">module amqp.Connection.prototype.disconnect</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.disconnect.disconnect" id="apidoc.element.amqp.Connection.prototype.disconnect.disconnect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function () {
  debug &#x26;&#x26; debug(&#x22;Sending disconnect request to server&#x22;);
  this._sendMethod(0, methods.connectionClose, {
    &#x27;replyText&#x27;: &#x27;client disconnect&#x27;,
    &#x27;replyCode&#x27;: 200,
    &#x27;classId&#x27;: 0,
    &#x27;methodId&#x27;: 0
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Table of Contents

- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.<span class="apidocCodeKeywordSpan">disconnect</span>()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.end" id="apidoc.module.amqp.Connection.prototype.end">module amqp.Connection.prototype.end</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.end.end" id="apidoc.element.amqp.Connection.prototype.end.end">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  if (this.socket) {
    this.socket.end();
  }

  this.options.heartbeat = false;

  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }

  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
    });

    m.addListener(&#x27;end&#x27;, function () {
var json, deliveryInfo = {}, msgProperties = classes[60].fields, i, l;

if (isJSON) {
  decoder.<span class="apidocCodeKeywordSpan">end</span>();
  try {
    json = JSON.parse(buffer);
  } catch (e) {
    json = null;
    deliveryInfo.parseError = e;
    deliveryInfo.rawData = buffer;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.exchange" id="apidoc.module.amqp.Connection.prototype.exchange">module amqp.Connection.prototype.exchange</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchange.exchange" id="apidoc.element.amqp.Connection.prototype.exchange.exchange">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchange
        <span class="apidocSignatureSpan">(name, options, openCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exchange = function (name, options, openCallback) {
  if (name === undefined) name = this.implOptions.defaultExchangeName;

  if (!options) options = {};
  if (name !== &#x27;&#x27; &#x26;&#x26; options.type === undefined) options.type = &#x27;topic&#x27;;

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit(&#x22;error&#x22;, exception);
    return;
  }
  var exchange = new Exchange(this, channel, name, options, openCallback);
  this.channels[channel] = exchange;
  this.exchanges[name] = exchange;
  return exchange;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.<span class="apidocCodeKeywordSpan">exchange</span>()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
- [exchange.unbind(srcExchange, routingKey [, callback])](#exchangeunbindsrcexchange-routingkey--callback)
- [exchange.bind_headers(exchange, routing [, bindCallback])](#exchangebind_headersexchange-routing--bindcallback)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.exchangeClosed" id="apidoc.module.amqp.Connection.prototype.exchangeClosed">module amqp.Connection.prototype.exchangeClosed</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchangeClosed.exchangeClosed" id="apidoc.element.amqp.Connection.prototype.exchangeClosed.exchangeClosed">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchangeClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exchangeClosed = function (name) {
  if (this.exchanges[name]) delete this.exchanges[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._openCallback = null;
  }
  break;

case methods.channelClose:
  this.state = &#x22;closed&#x22;;
  this.closeOK();
  this.connection.<span class="apidocCodeKeywordSpan">exchangeClosed</span>(this.name);
  var e = new Error(args.replyText);
  e.code = args.replyCode;
  this.emit(&#x27;error&#x27;, e);
  this.emit(&#x27;close&#x27;);
  break;

case methods.channelCloseOk:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.generateChannelId" id="apidoc.module.amqp.Connection.prototype.generateChannelId">module amqp.Connection.prototype.generateChannelId</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.generateChannelId.generateChannelId" id="apidoc.element.amqp.Connection.prototype.generateChannelId.generateChannelId">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>generateChannelId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateChannelId = function () {
  // start from the last used slot id
  var channelId = this.channelCounter;
  while(true){
    // use values in range of 1..65535
    channelId = channelId % channelMax + 1;
    if(!this.channels[channelId]){
      break;
    }
    // after a full loop throw an Error
    if(channelId == this.channelCounter){
      throw new Error(&#x22;No valid Channel Id values available&#x22;);
    }
  }
  this.channelCounter = channelId;
  return this.channelCounter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.heartbeat" id="apidoc.module.amqp.Connection.prototype.heartbeat">module amqp.Connection.prototype.heartbeat</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.heartbeat.heartbeat" id="apidoc.element.amqp.Connection.prototype.heartbeat.heartbeat">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heartbeat = function () {
  if(this.socket.writable) this.write(new Buffer([8,0,0,0,0,0,0,206]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.publish" id="apidoc.module.amqp.Connection.prototype.publish">module amqp.Connection.prototype.publish</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.publish.publish" id="apidoc.element.amqp.Connection.prototype.publish.publish">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>publish
        <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (routingKey, body, options, callback) {
  if (!this._defaultExchange) {
    this._defaultExchange = this.exchange();
  }

  var exchange = this._defaultExchange;
  if (exchange.state === &#x27;open&#x27;) {
    exchange.publish(routingKey, body, options, callback);
  } else {
    exchange.once(&#x27;open&#x27;, function() {
      exchange.publish(routingKey, body, options, callback);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Table of Contents

- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.<span class="apidocCodeKeywordSpan">publish</span>(routingKey, body, options, callback)](#connectionpublishroutingkey
-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.queue" id="apidoc.module.amqp.Connection.prototype.queue">module amqp.Connection.prototype.queue</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queue.queue" id="apidoc.element.amqp.Connection.prototype.queue.queue">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queue
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (name) {
  var options, callback;
  if (typeof arguments[1] == &#x27;object&#x27;) {
    options = arguments[1];
    callback = arguments[2];
  } else {
    callback = arguments[1];
  }

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit(&#x22;error&#x22;, exception);
    return;
  }

  var q = new Queue(this, channel, name, options, callback);
  this.channels[channel] = q;
  return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.<span class="apidocCodeKeywordSpan">queue</span>(name[, options][, openCallback])](#connectionqueuename-options-opencallback
)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.queueClosed" id="apidoc.module.amqp.Connection.prototype.queueClosed">module amqp.Connection.prototype.queueClosed</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queueClosed.queueClosed" id="apidoc.element.amqp.Connection.prototype.queueClosed.queueClosed">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queueClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queueClosed = function (name) {
  if (this.queues[name]) delete this.queues[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Queue.prototype.destroy = function (options) {
var self = this;

options = options || {};
return this._taskPush(methods.queueDeleteOk, function () {
  self.connection.<span class="apidocCodeKeywordSpan">queueClosed</span>(self.name);
  if (&#x27;exchange&#x27; in self) {
    self.exchange.binds--;
  }
  self.connection._sendMethod(self.channel, methods.queueDelete,
      { reserved1: 0
      , queue: self.name
      , ifUnused: options.ifUnused ? true : false
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.reconnect" id="apidoc.module.amqp.Connection.prototype.reconnect">module amqp.Connection.prototype.reconnect</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.reconnect.reconnect" id="apidoc.element.amqp.Connection.prototype.reconnect.reconnect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>reconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnect = function () {
  // Suspend activity on channels
  for (var channel in this.channels) {
    this.channels[channel].state = &#x27;closed&#x27;;
  }
  debug &#x26;&#x26; debug(&#x22;Connection lost, reconnecting...&#x22;);
  // Terminate socket activity
  if (this.socket) this.socket.end();
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.<span class="apidocCodeKeywordSpan">reconnect</span>();
};
util.inherits(Channel, events.EventEmitter);

Channel.prototype.closeOK = function() {
  this.connection._sendMethod(this.channel, methods.channelCloseOk, {reserved1: &#x22;&#x22;});
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.setImplOptions" id="apidoc.module.amqp.Connection.prototype.setImplOptions">module amqp.Connection.prototype.setImplOptions</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setImplOptions.setImplOptions" id="apidoc.element.amqp.Connection.prototype.setImplOptions.setImplOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setImplOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImplOptions = function (options) {
  this.implOptions = _.assignIn({}, defaultImplOptions, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.setOptions" id="apidoc.module.amqp.Connection.prototype.setOptions">module amqp.Connection.prototype.setOptions</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setOptions.setOptions" id="apidoc.element.amqp.Connection.prototype.setOptions.setOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOptions = function (options) {
  var urlo = (options &#x26;&#x26; options.url) ? this._parseURLOptions(options.url) : {};
  var sslo = (options &#x26;&#x26; options.ssl &#x26;&#x26; options.ssl.enabled) ? defaultSslOptions : {};
  this.options = _.assignIn({}, defaultOptions, sslo, urlo, options || {});
  this.options.clientProperties =  _.assignIn({}, defaultClientProperties, (options &#x26;&#x26; options.clientProperties) || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.channel" id="apidoc.module.amqp.channel">module amqp.channel</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.channel.channel" id="apidoc.element.amqp.channel.channel">
        function <span class="apidocSignatureSpan">amqp.</span>channel
        <span class="apidocSignatureSpan">(connection, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Channel(connection, channel) {
  events.EventEmitter.call(this);

  // Unlimited listeners. Helps when e.g. publishing high-volume messages,
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.reconnect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.super_" id="apidoc.element.amqp.channel.super_">
        function <span class="apidocSignatureSpan">amqp.channel.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.channel.prototype" id="apidoc.module.amqp.channel.prototype">module amqp.channel.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.channel.prototype._handleTaskReply" id="apidoc.element.amqp.channel.prototype._handleTaskReply">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_handleTaskReply
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleTaskReply = function (channel, method, args) {
  var task, i;

  for (i = 0; i &#x3c; this._tasks.length; i++) {
    if (this._tasks[i].reply == method) {
      task = this._tasks[i];
      this._tasks.splice(i, 1);
      task.promise.emitSuccess(args);
      this._tasksFlush();
      return true;
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype._onChannelMethod" id="apidoc.element.amqp.channel.prototype._onChannelMethod">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_onChannelMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onChannelMethod = function (channel, method, args) {
  switch (method) {
    case methods.channelCloseOk:
      delete this.connection.channels[this.channel];
      this.state = &#x27;closed&#x27;;
      // TODO should this be falling through?
    default:
      this._onMethod(channel, method, args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype._taskPush" id="apidoc.element.amqp.channel.prototype._taskPush">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_taskPush
        <span class="apidocSignatureSpan">(reply, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_taskPush = function (reply, cb) {
  var promise = new Promise();
  this._tasks.push({
    promise: promise,
    reply: reply,
    sent: false,
    cb: cb
  });
  this._tasksFlush();
  return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = _.assignIn({}, options || {});
options.routingKey = routingKey;
options.exchange   = self.name;
options.mandatory  = options.mandatory ? true : false;
options.immediate  = options.immediate ? true : false;
options.reserved1  = 0;

var task = this.<span class="apidocCodeKeywordSpan">_taskPush</span>(null, function () {
  self.connection._sendMethod(self.channel, methods.basicPublish, options);
  // This interface is probably not appropriate for streaming large files.
  // (Of course it&#x27;s arguable about whether AMQP is the appropriate
  // transport for large files.) The content header wants to know the size
  // of the data before sending it - so there&#x27;s no point in trying to have a
  // general streaming interface - streaming messages of unknown size simply
  // isn&#x27;t possible with AMQP. This is all to say, don&#x27;t send big messages.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype._tasksFlush" id="apidoc.element.amqp.channel.prototype._tasksFlush">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_tasksFlush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_tasksFlush = function () {
  if (this.state != &#x27;open&#x27;) return;

  for (var i = 0; i &#x3c; this._tasks.length; i++) {
    var task = this._tasks[i];
    if (task.sent) continue;
    task.cb();
    task.sent = true;
    if (!task.reply) {
      // if we don&#x27;t expect a reply, just delete it now
      this._tasks.splice(i, 1);
      i = i-1;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var promise = new Promise();
this._tasks.push({
  promise: promise,
  reply: reply,
  sent: false,
  cb: cb
});
this.<span class="apidocCodeKeywordSpan">_tasksFlush</span>();
return promise;
};

Channel.prototype._tasksFlush = function () {
if (this.state != &#x27;open&#x27;) return;

for (var i = 0; i &#x3c; this._tasks.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype.close" id="apidoc.element.amqp.channel.prototype.close">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>close
        <span class="apidocSignatureSpan">(reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (reason) {
  this.state = &#x27;closing&#x27;;
  this.connection._sendMethod(this.channel, methods.channelClose,
                              {&#x27;replyText&#x27;: reason ? reason : &#x27;Goodbye from node&#x27;,
                               &#x27;replyCode&#x27;: 200,
                               &#x27;classId&#x27;: 0,
                               &#x27;methodId&#x27;: 0});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.connection._sendMethod(self.channel, methods.basicCancel,
                                { reserved1: 0,
                                  consumerTag: consumerTag,
                                  noWait: false });
  })
  .addCallback(function () {
    if (self.options.closeChannelOnUnsubscribe) {
      self.<span class="apidocCodeKeywordSpan">close</span>();
    }
    delete self.consumerTagListeners[consumerTag];
    delete self.consumerTagOptions[consumerTag];
  });
};

Queue.prototype.subscribe = function (options, messageListener) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype.closeOK" id="apidoc.element.amqp.channel.prototype.closeOK">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>closeOK
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeOK = function () {
  this.connection._sendMethod(this.channel, methods.channelCloseOk, {reserved1: &#x22;&#x22;});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._openCallback(this);
    this._openCallback = null;
  }
  break;

case methods.channelClose:
  this.state = &#x22;closed&#x22;;
  this.<span class="apidocCodeKeywordSpan">closeOK</span>();
  this.connection.exchangeClosed(this.name);
  var e = new Error(args.replyText);
  e.code = args.replyCode;
  this.emit(&#x27;error&#x27;, e);
  this.emit(&#x27;close&#x27;);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype.reconnect" id="apidoc.element.amqp.channel.prototype.reconnect">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>reconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnect = function () {
  this.connection._sendMethod(this.channel, methods.channelOpen, {reserved1: &#x22;&#x22;});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.<span class="apidocCodeKeywordSpan">reconnect</span>();
};
util.inherits(Channel, events.EventEmitter);

Channel.prototype.closeOK = function() {
  this.connection._sendMethod(this.channel, methods.channelCloseOk, {reserved1: &#x22;&#x22;});
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.createConnection" id="apidoc.module.amqp.createConnection">module amqp.createConnection</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.createConnection.createConnection" id="apidoc.element.amqp.createConnection.createConnection">
        function <span class="apidocSignatureSpan">amqp.</span>createConnection
        <span class="apidocSignatureSpan">(options, implOptions, readyCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createConnection = function (options, implOptions, readyCallback) {
  var c = new Connection(options, implOptions, readyCallback);
  c.connect();
  return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
IMPORTANT: This module only works with node v0.4.0 and later.

An example of connecting to a server and listening on a queue.

```javascript
var amqp = require(&#x27;amqp&#x27;);

var connection = amqp.<span class="apidocCodeKeywordSpan">createConnection</span>({ host: &#x27;dev.rabbitmq.com&#x27; });

// add this for better debuging
connection.on(&#x27;error&#x27;, function(e) {
  console.log(&#x22;Error from amqp: &#x22;, e);
});

// Wait for connection to become established.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.exchange" id="apidoc.module.amqp.exchange">module amqp.exchange</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.exchange.exchange" id="apidoc.element.amqp.exchange.exchange">
        function <span class="apidocSignatureSpan">amqp.</span>exchange
        <span class="apidocSignatureSpan">(connection, channel, name, options, openCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Exchange(connection, channel, name, options, openCallback) {
  Channel.call(this, connection, channel);
  this.name = name;
  this.binds = 0; // keep track of queues bound
  this.exchangeBinds = 0; // keep track of exchanges bound
  this.sourceExchanges = {};
  this.options = _.defaults(options || {}, {autoDelete: true});
  this._openCallback = openCallback;

  this._sequence = null;
  this._unAcked  = {};
  this._addedExchangeErrorHandler = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.<span class="apidocCodeKeywordSpan">exchange</span>()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
- [exchange.unbind(srcExchange, routingKey [, callback])](#exchangeunbindsrcexchange-routingkey--callback)
- [exchange.bind_headers(exchange, routing [, bindCallback])](#exchangebind_headersexchange-routing--bindcallback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.super_" id="apidoc.element.amqp.exchange.super_">
        function <span class="apidocSignatureSpan">amqp.exchange.</span>super_
        <span class="apidocSignatureSpan">(connection, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Channel(connection, channel) {
  events.EventEmitter.call(this);

  // Unlimited listeners. Helps when e.g. publishing high-volume messages,
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.reconnect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.exchange.prototype" id="apidoc.module.amqp.exchange.prototype">module amqp.exchange.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype._awaitConfirm" id="apidoc.element.amqp.exchange.prototype._awaitConfirm">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_awaitConfirm
        <span class="apidocSignatureSpan">(task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _awaitConfirm(task, callback) {
  if (!this._addedExchangeErrorHandler) {
    // if connection fails, we want to ack error all unacked publishes.
    this.connection.on(&#x27;error&#x27;, createExchangeErrorHandlerFor(this));
    this.on(&#x27;error&#x27;, createExchangeErrorHandlerFor(this));
    this._addedExchangeErrorHandler = true;
  }

  debug &#x26;&#x26; debug(&#x27;awaiting confirmation for &#x27; + this._sequence);
  task.sequence = this._sequence;
  this._unAcked[this._sequence] = task;
  this._sequence++;

  if (&#x27;function&#x27; != typeof callback) return;

  task.once(&#x27;ack error&#x27;, function (err) {
    task.removeAllListeners();
    callback(true, err);
  });

  task.once(&#x27;ack&#x27;, function () {
    task.removeAllListeners();
    callback(false);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // of the data before sending it - so there&#x27;s no point in trying to have a
  // general streaming interface - streaming messages of unknown size simply
  // isn&#x27;t possible with AMQP. This is all to say, don&#x27;t send big messages.
  // If you need to stream something large, chunk it yourself.
  self.connection._sendBody(self.channel, data, options);
});

if (self.options.confirm) self.<span class="apidocCodeKeywordSpan">_awaitConfirm</span>(task, callback);
return task;
};

// registers tasks for confirms
Exchange.prototype._awaitConfirm = function _awaitConfirm (task, callback) {
if (!this._addedExchangeErrorHandler) {
  // if connection fails, we want to ack error all unacked publishes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype._confirmSelect" id="apidoc.element.amqp.exchange.prototype._confirmSelect">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_confirmSelect
        <span class="apidocSignatureSpan">(channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_confirmSelect = function (channel) {
  this.connection._sendMethod(channel, methods.confirmSelect, { noWait: false });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._addedExchangeErrorHandler = true;
      }

      // Pre-baked exchanges don&#x27;t need to be declared
      if (/^$|(amq\.)/.test(this.name)) {
//If confirm mode is specified we have to set it no matter the exchange.
if (this.options.confirm) {
  this.<span class="apidocCodeKeywordSpan">_confirmSelect</span>(channel);
  return;
}

this.state = &#x27;open&#x27;;
// - issue #33 fix
if (this._openCallback) {
 this._openCallback(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype._onMethod" id="apidoc.element.amqp.exchange.prototype._onMethod">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_onMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onMethod = function (channel, method, args) {
  this.emit(method.name, args);

  if (this._handleTaskReply.apply(this, arguments))
    return true;

  var cb;

  switch (method) {
    case methods.channelOpenOk:
      this._sequence = null;

      if (!this._addedExchangeErrorHandler) {
        var errorHandler = createExchangeErrorHandlerFor(this);
        this.connection.on(&#x27;error&#x27;, errorHandler);
        this.on(&#x27;error&#x27;, errorHandler);
        this._addedExchangeErrorHandler = true;
      }

      // Pre-baked exchanges don&#x27;t need to be declared
      if (/^$|(amq\.)/.test(this.name)) {
        //If confirm mode is specified we have to set it no matter the exchange.
        if (this.options.confirm) {
          this._confirmSelect(channel);
          return;
        }

        this.state = &#x27;open&#x27;;
        // - issue #33 fix
        if (this._openCallback) {
         this._openCallback(this);
         this._openCallback = null;
        }
        // --
        this.emit(&#x27;open&#x27;);

      // For if we want to delete a exchange,
      // we dont care if all of the options match.
      } else if (this.options.noDeclare) {
        if (this.options.confirm) {
          this._confirmSelect(channel);
          this.state = &#x27;open&#x27;;

          if (this._openCallback) {
           this._openCallback(this);
           this._openCallback = null;
          }

          this.emit(&#x27;open&#x27;);
        }
      } else {
        this.connection._sendMethod(channel, methods.exchangeDeclare,
            { reserved1:  0
            , reserved2:  false
            , reserved3:  false
            , exchange:   this.name
            , type:       this.options.type || &#x27;topic&#x27;
            , passive:    !!this.options.passive
            , durable:    !!this.options.durable
            , autoDelete: !!this.options.autoDelete
            , internal:   !!this.options.internal
            , noWait:     false
            , &#x22;arguments&#x22;:this.options.arguments || {}
            });
        this.state = &#x27;declaring&#x27;;
      }
      break;

    case methods.exchangeDeclareOk:
      if (this.options.confirm) {
        this._confirmSelect(channel);
      } else {

        this.state = &#x27;open&#x27;;
        this.emit(&#x27;open&#x27;);
        if (this._openCallback) {
          this._openCallback(this);
          this._openCallback = null;
        }
      }
      break;

    case methods.confirmSelectOk:
      this._sequence = 1;

      this.state = &#x27;open&#x27;;
      this.emit(&#x27;open&#x27;);
      if (this._openCallback) {
        this._openCallback(this);
        this._openCallback = null;
      }
      break;

    case methods.channelClose:
      this.state = &#x22;closed&#x22;;
      this.closeOK();
      this.connection.exchangeClosed(this.name);
      var e = new Error(args.replyText);
      e.code = args.replyCode;
      this.emit(&#x27;error&#x27;, e);
      this.emit(&#x27;close&#x27;);
      break;

    case methods.channelCloseOk:
      this.connection.exchangeClosed(this.name);
      this.emit(&#x27;close&#x27;);
      break;


    case methods.basicAck:
      this.emit(&#x27;basic-ack&#x27;, args);
      var sequenceNumber = args.deliveryTag.readUInt32BE(4), tag;
      debug &#x26;&#x26; debug(&#x22;basic-ack, sequence: &#x22;, sequenceNumber);

      if (sequenceNumber === 0 &#x26;&#x26; args.multiple === true) {
        // we must ack everything
        for (tag in this._unAcked) {
          this._unAcked[tag].emit(&#x27;ack&#x27;);
          delete this._unAcked[tag];
        }
      } else if (sequenceNumber !== 0 &#x26;&#x26; args.multiple === true) {
        // we must ack everything before the delivery tag
        for (tag in this._unAcked) {
          if (tag &#x3c;= sequenceNumber) {
            this._unAcked[tag].emit(&#x27;ack&#x27;);
            delete this._unAcked[tag];
          }
        }
      } else if (this._unAcked[sequenceNumber] &#x26;&#x26; args.multiple === false) {
        // simple single ack
        this._unAcked[sequenceNumber].emit(&#x27;ack&#x27;);
        delete this._unAcked[sequenceNumber];
      }
      break;

    case methods.basicReturn:
      this.emit(&#x27;basic-return&#x27;, args);
      break;

    case methods.exchangeBindOk:
      if (this._bindCallback) {
        // setting this._bindCa ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Channel.prototype._onChannelMethod = function(channel, method, args) {
switch (method) {
  case methods.channelCloseOk:
    delete this.connection.channels[this.channel];
    this.state = &#x27;closed&#x27;;
    // TODO should this be falling through?
  default:
    this.<span class="apidocCodeKeywordSpan">_onMethod</span>(channel, method, args);
}
};

Channel.prototype.close = function(reason) {
this.state = &#x27;closing&#x27;;
this.connection._sendMethod(this.channel, methods.channelClose,
                            {&#x27;replyText&#x27;: reason ? reason : &#x27;Goodbye from node&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype._readyToPublishWithConfirms" id="apidoc.element.amqp.exchange.prototype._readyToPublishWithConfirms">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_readyToPublishWithConfirms
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readyToPublishWithConfirms = function () {
  return this._sequence != null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (this.state !== &#x27;open&#x27;) {
  this._sequence = null;
  return callback(true, new Error(&#x27;Can not publish: exchange is not open&#x27;));
}

if (this.options.confirm &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">_readyToPublishWithConfirms</span>()) {
  return callback(true, new Error(&#x27;Not yet ready to publish with confirms&#x27;));
}

options = _.assignIn({}, options || {});
options.routingKey = routingKey;
options.exchange   = self.name;
options.mandatory  = options.mandatory ? true : false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.bind" id="apidoc.element.amqp.exchange.prototype.bind">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>bind
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind = function () {
  var self = this;

  // Two arguments are required. The binding to the destination
  // exchange/routingKey will be established.

  var exchange    = arguments[0]
    , routingKey  = arguments[1]
    , callback    = arguments[2]
  ;

  if (callback) this._bindCallback = callback;

  var source = exchange instanceof Exchange ? exchange.name : exchange;
  var destination = self.name;

  if(source in self.connection.exchanges) {
    self.sourceExchanges[source] = self.connection.exchanges[source];
    self.connection.exchanges[source].exchangeBinds++;
  }

  self.connection._sendMethod(self.channel, methods.exchangeBind,
      { reserved1: 0
      , destination: destination
      , source: source
      , routingKey: routingKey
      , noWait: false
      , &#x22;arguments&#x22;: {}
      });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.<span class="apidocCodeKeywordSpan">bind</span>([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.bind_headers" id="apidoc.element.amqp.exchange.prototype.bind_headers">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>bind_headers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind_headers = function () {
  var self = this;

  // Two arguments are required. The binding to the destination
  // exchange/routingKey will be established.

  var exchange = arguments[0]
    , routing  = arguments[1]
    , callback = arguments[2]
  ;

  if (callback) this._bindCallback = callback;

  var source = exchange instanceof Exchange ? exchange.name : exchange;
  var destination = self.name;

  if (source in self.connection.exchanges) {
    self.sourceExchanges[source] = self.connection.exchanges[source];
    self.connection.exchanges[source].exchangeBinds++;
  }

  self.connection._sendMethod(self.channel, methods.exchangeBind,
    { reserved1: 0
        , destination: destination
        , source: source
        , routingKey: &#x27;&#x27;
        , noWait: false
        , &#x22;arguments&#x22;: routing
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.<span class="apidocCodeKeywordSpan">bind_headers</span>([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.cleanup" id="apidoc.element.amqp.exchange.prototype.cleanup">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>cleanup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanup = function () {
  if (this.binds === 0) { // don&#x27;t keep reference open if unused
    this.connection.exchangeClosed(this.name);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.destroy" id="apidoc.element.amqp.exchange.prototype.destroy">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>destroy
        <span class="apidocSignatureSpan">(ifUnused)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (ifUnused) {
  var self = this;
  return this._taskPush(methods.exchangeDeleteOk, function () {
    self.connection.exchangeClosed(self.name);
    self.connection._sendMethod(self.channel, methods.exchangeDelete,
        { reserved1: 0
        , exchange: self.name
        , ifUnused: ifUnused ? true : false
        , noWait: false
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.<span class="apidocCodeKeywordSpan">destroy</span>(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.publish" id="apidoc.element.amqp.exchange.prototype.publish">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>publish
        <span class="apidocSignatureSpan">(routingKey, data, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (routingKey, data, options, callback) {
  var self = this;
  callback = callback || function() {};

  if (this.connection._blocked) {
    return callback(true, new Error(&#x27;Connection is blocked, server reason: &#x27; + this.connection._blockedReason));
  }

  if (this.state !== &#x27;open&#x27;) {
    this._sequence = null;
    return callback(true, new Error(&#x27;Can not publish: exchange is not open&#x27;));
  }

  if (this.options.confirm &#x26;&#x26; !this._readyToPublishWithConfirms()) {
    return callback(true, new Error(&#x27;Not yet ready to publish with confirms&#x27;));
  }

  options = _.assignIn({}, options || {});
  options.routingKey = routingKey;
  options.exchange   = self.name;
  options.mandatory  = options.mandatory ? true : false;
  options.immediate  = options.immediate ? true : false;
  options.reserved1  = 0;

  var task = this._taskPush(null, function () {
    self.connection._sendMethod(self.channel, methods.basicPublish, options);
    // This interface is probably not appropriate for streaming large files.
    // (Of course it&#x27;s arguable about whether AMQP is the appropriate
    // transport for large files.) The content header wants to know the size
    // of the data before sending it - so there&#x27;s no point in trying to have a
    // general streaming interface - streaming messages of unknown size simply
    // isn&#x27;t possible with AMQP. This is all to say, don&#x27;t send big messages.
    // If you need to stream something large, chunk it yourself.
    self.connection._sendBody(self.channel, data, options);
  });

  if (self.options.confirm) self._awaitConfirm(task, callback);
  return task;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Table of Contents

- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.<span class="apidocCodeKeywordSpan">publish</span>(routingKey, body, options, callback)](#connectionpublishroutingkey
-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.unbind" id="apidoc.element.amqp.exchange.prototype.unbind">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>unbind
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbind = function () {
  var self = this;

  // Both arguments are required. The binding to the destination
  // exchange/routingKey will be unbound.

  var exchange    = arguments[0]
    , routingKey  = arguments[1]
    , callback    = arguments[2]
  ;

  if (callback) this._unbindCallback = callback;

  return this._taskPush(methods.exchangeUnbindOk, function () {
    var source = exchange instanceof Exchange ? exchange.name : exchange;
    var destination = self.name;

    if (source in self.connection.exchanges) {
      delete self.sourceExchanges[source];
      self.connection.exchanges[source].exchangeBinds--;
    }

    self.connection._sendMethod(self.channel, methods.exchangeUnbind,
        { reserved1: 0
        , destination: destination
        , source: source
        , routingKey: routingKey
        , noWait: false
        , &#x22;arguments&#x22;: {}
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.<span class="apidocCodeKeywordSpan">unbind</span>([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.jspack" id="apidoc.module.amqp.jspack">module amqp.jspack</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.jspack.jspack" id="apidoc.element.amqp.jspack.jspack">
        function <span class="apidocSignatureSpan">amqp.</span>jspack
        <span class="apidocSignatureSpan">(bigEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jspack = function (bigEndian) {
  this.bigEndian = bigEndian;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.message" id="apidoc.module.amqp.message">module amqp.message</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.message.message" id="apidoc.element.amqp.message.message">
        function <span class="apidocSignatureSpan">amqp.</span>message
        <span class="apidocSignatureSpan">(queue, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(queue, args) {
  var msgProperties = definitions.classes[60].fields;

  events.EventEmitter.call(this);

  this.queue = queue;

  this.deliveryTag = args.deliveryTag;
  this.redelivered = args.redelivered;
  this.exchange    = args.exchange;
  this.routingKey  = args.routingKey;
  this.consumerTag = args.consumerTag;

  for (var i=0, l=msgProperties.length; i&#x3c;l; i++) {
    if (args[msgProperties[i].name]) {
      this[msgProperties[i].name] = args[msgProperties[i].name];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.message.super_" id="apidoc.element.amqp.message.super_">
        function <span class="apidocSignatureSpan">amqp.message.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.message.prototype" id="apidoc.module.amqp.message.prototype">module amqp.message.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.message.prototype.acknowledge" id="apidoc.element.amqp.message.prototype.acknowledge">
        function <span class="apidocSignatureSpan">amqp.message.prototype.</span>acknowledge
        <span class="apidocSignatureSpan">(all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acknowledge = function (all) {
  this.queue.connection._sendMethod(this.queue.channel, definitions.methods.basicAck,
      { reserved1: 0
      , deliveryTag: this.deliveryTag
      , multiple: all ? true : false
      });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can also use the prefetchCount option to increase the window of how
many messages the server will send you before you need to ack (quality of service).
`{ ack: true, prefetchCount: 1 }` is the default and will only send you one
message before you ack. Setting prefetchCount to 0 will make that window unlimited.
If this option is used `q.shift()` should not be called. Instead the listener
function should take four parameters `(message, headers, deliveryInfo, ack)` and
`ack.<span class="apidocCodeKeywordSpan">acknowledge</span>()` should be called to ack a single message.

The `routingKeyInPayload` and `deliveryKeyInPayload` options determine
if the reception process will inject the routingKey and deliveryKey,
respectively, into the JSON payload received.  These default to unset
thus adopting the parent connection&#x27;s values (which default to false).
Setting these to true provide backward compatibility for older
applications.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.message.prototype.reject" id="apidoc.element.amqp.message.prototype.reject">
        function <span class="apidocSignatureSpan">amqp.message.prototype.</span>reject
        <span class="apidocSignatureSpan">(requeue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (requeue) {
  this.queue.connection._sendMethod(this.queue.channel, definitions.methods.basicReject,
      { deliveryTag: this.deliveryTag
      , requeue: requeue ? true : false
      });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Queue.prototype.subscribeJSON = Queue.prototype.subscribe;

/* Acknowledges the last message */
Queue.prototype.shift = function (reject, requeue) {
  if (this._lastMessage) {
    if (reject) {
      this._lastMessage.<span class="apidocCodeKeywordSpan">reject</span>(requeue ? true : false);
    } else {
      this._lastMessage.acknowledge();
    }
    this._lastMessage = null;
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.parser" id="apidoc.module.amqp.parser">module amqp.parser</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.parser.parser" id="apidoc.element.amqp.parser.parser">
        function <span class="apidocSignatureSpan">amqp.</span>parser
        <span class="apidocSignatureSpan">(version, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AMQPParser(version, type) {
  this.isClient = (type == &#x27;client&#x27;);
  this.state = this.isClient ? &#x27;frameHeader&#x27; : &#x27;protocolHeader&#x27;;
  this.maxFrameBuffer = MAX_FRAME_BUFFER_DEFAULT;

  if (version != &#x27;0-9-1&#x27;) this.throwError(&#x22;Unsupported protocol version&#x22;);

  var frameHeader = new Buffer(7);
  frameHeader.used = 0;
  var frameBuffer, frameType, frameChannel;

  var self = this;

  function header(data) {
    var fh = frameHeader;
    var needed = fh.length - fh.used;
    data.copy(fh, fh.used, 0, data.length);
    fh.used += data.length; // sloppy
    if (fh.used &#x3e;= fh.length) {
      fh.read = 0;
      frameType = fh[fh.read++];
      frameChannel = parseInt(fh, 2);
      var frameSize = parseInt(fh, 4);
      fh.used = 0; // for reuse
      if (frameSize &#x3e; self.maxFrameBuffer) {
        self.throwError(&#x22;Oversized frame &#x22; + frameSize);
      }
      frameBuffer = new Buffer(frameSize);
      frameBuffer.used = 0;
      return frame(data.slice(needed));
    }
    else { // need more!
      return header;
    }
  }

  function frame(data) {
    var fb = frameBuffer;
    var needed = fb.length - fb.used;
    var sourceEnd = (fb.length &#x3e; data.length) ? data.length : fb.length;
    data.copy(fb, fb.used, 0, sourceEnd);
    fb.used += data.length;
    if (data.length &#x3e; needed) {
      return frameEnd(data.slice(needed));
    }
    else if (data.length == needed) {
      return frameEnd;
    }
    else {
      return frame;
    }
  }

  function frameEnd(data) {
    if (data.length &#x3e; 0) {
      if (data[0] === Indicators.FRAME_END) {
        switch (frameType) {
        case FrameType.METHOD:
          self._parseMethodFrame(frameChannel, frameBuffer);
          break;
        case FrameType.HEADER:
          self._parseHeaderFrame(frameChannel, frameBuffer);
          break;
        case FrameType.BODY:
          if (self.onContent) {
            self.onContent(frameChannel, frameBuffer);
          }
          break;
        case FrameType.HEARTBEAT:
          debug &#x26;&#x26; debug(&#x22;heartbeat&#x22;);
          if (self.onHeartBeat) self.onHeartBeat();
          break;
        default:
          self.throwError(&#x22;Unhandled frame type &#x22; + frameType);
          break;
        }
        return header(data.slice(1));
      }
      else {
        self.throwError(&#x22;Missing frame end marker&#x22;);
      }
    }
    else {
      return frameEnd;
    }
  }

  self.parse = header;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.parser.prototype" id="apidoc.module.amqp.parser.prototype">module amqp.parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.parser.prototype._parseHeaderFrame" id="apidoc.element.amqp.parser.prototype._parseHeaderFrame">
        function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>_parseHeaderFrame
        <span class="apidocSignatureSpan">(channel, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseHeaderFrame = function (channel, buffer) {
  buffer.read = 0;

  var classIndex = parseInt(buffer, 2);
  var weight = parseInt(buffer, 2);
  var size = parseInt(buffer, 8);

  var classInfo = classes[classIndex];

  if (classInfo.fields.length &#x3e; 15) {
    this.throwError(&#x22;TODO: support more than 15 properties&#x22;);
  }

  var propertyFlags = parseInt(buffer, 2);

  var fields = [];
  for (var i = 0; i &#x3c; classInfo.fields.length; i++) {
    var field = classInfo.fields[i];
    // groan.
    if (propertyFlags &#x26; (1 &#x3c;&#x3c; (15-i))) fields.push(field);
  }

  var properties = parseFields(buffer, fields);

  if (this.onContentHeader) {
    this.onContentHeader(channel, classInfo, weight, properties, size);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (data.length &#x3e; 0) {
if (data[0] === Indicators.FRAME_END) {
  switch (frameType) {
  case FrameType.METHOD:
    self._parseMethodFrame(frameChannel, frameBuffer);
    break;
  case FrameType.HEADER:
    self.<span class="apidocCodeKeywordSpan">_parseHeaderFrame</span>(frameChannel, frameBuffer);
    break;
  case FrameType.BODY:
    if (self.onContent) {
      self.onContent(frameChannel, frameBuffer);
    }
    break;
  case FrameType.HEARTBEAT:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.parser.prototype._parseMethodFrame" id="apidoc.element.amqp.parser.prototype._parseMethodFrame">
        function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>_parseMethodFrame
        <span class="apidocSignatureSpan">(channel, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseMethodFrame = function (channel, buffer) {
  buffer.read = 0;
  var classId = parseInt(buffer, 2),
     methodId = parseInt(buffer, 2);

  // Make sure that this is a method that we understand.
  if (!methodTable[classId] || !methodTable[classId][methodId]) {
    this.throwError(&#x22;Received unknown [classId, methodId] pair [&#x22; +
               classId + &#x22;, &#x22; + methodId + &#x22;]&#x22;);
  }

  var method = methodTable[classId][methodId];

  if (!method) this.throwError(&#x22;bad method?&#x22;);

  var args = parseFields(buffer, method.fields);

  if (this.onMethod) {
    debug &#x26;&#x26; debug(&#x22;Executing method&#x22;, channel, method, args);
    this.onMethod(channel, method, args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function frameEnd(data) {
  if (data.length &#x3e; 0) {
    if (data[0] === Indicators.FRAME_END) {
      switch (frameType) {
      case FrameType.METHOD:
        self.<span class="apidocCodeKeywordSpan">_parseMethodFrame</span>(frameChannel, frameBuffer);
        break;
      case FrameType.HEADER:
        self._parseHeaderFrame(frameChannel, frameBuffer);
        break;
      case FrameType.BODY:
        if (self.onContent) {
          self.onContent(frameChannel, frameBuffer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.parser.prototype.execute" id="apidoc.element.amqp.parser.prototype.execute">
        function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>execute
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execute = function (data) {
  // This function only deals with dismantling and buffering the frames.
  // It delegates to other functions for parsing the frame-body.
  debug &#x26;&#x26; debug(&#x27;execute: &#x27; + data.toString(&#x27;hex&#x27;));
  this.parse = this.parse(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.parser.prototype.setMaxFrameBuffer" id="apidoc.element.amqp.parser.prototype.setMaxFrameBuffer">
        function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>setMaxFrameBuffer
        <span class="apidocSignatureSpan">(maxFrameBuffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxFrameBuffer = function (maxFrameBuffer) {
  this.maxFrameBuffer = maxFrameBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.parser.prototype.throwError" id="apidoc.element.amqp.parser.prototype.throwError">
        function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>throwError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwError = function (error) {
  if (this.onError) this.onError(error);
  else throw new Error(error);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// of emitting the callbacks. Since this is an internal class, that should
// be fine.
var AMQPParser = module.exports = function AMQPParser (version, type) {
this.isClient = (type == &#x27;client&#x27;);
this.state = this.isClient ? &#x27;frameHeader&#x27; : &#x27;protocolHeader&#x27;;
this.maxFrameBuffer = MAX_FRAME_BUFFER_DEFAULT;

if (version != &#x27;0-9-1&#x27;) this.<span class="apidocCodeKeywordSpan">throwError</span>(&#x22;Unsupported protocol version&#
x22;);

var frameHeader = new Buffer(7);
frameHeader.used = 0;
var frameBuffer, frameType, frameChannel;

var self = this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.promise" id="apidoc.module.amqp.promise">module amqp.promise</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.promise.Promise" id="apidoc.element.amqp.promise.Promise">
        function <span class="apidocSignatureSpan">amqp.promise.</span>Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise = function () {
  events.EventEmitter.call(this);
  this._blocking = false;
  this.hasFired = false;
  this.hasAcked = false;
  this._values = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.queue" id="apidoc.module.amqp.queue">module amqp.queue</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.queue.queue" id="apidoc.element.amqp.queue.queue">
        function <span class="apidocSignatureSpan">amqp.</span>queue
        <span class="apidocSignatureSpan">(connection, channel, name, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue(connection, channel, name, options, callback) {
  Channel.call(this, connection, channel);

  var self = this;
  this.name = name;
  this._bindings = {};
  this.consumerTagListeners = {};
  this.consumerTagOptions = {};

  // route messages to subscribers based on consumerTag
  this.on(&#x27;rawMessage&#x27;, function(message) {
    if (message.consumerTag &#x26;&#x26; self.consumerTagListeners[message.consumerTag]) {
      self.consumerTagListeners[message.consumerTag](message);
    }
  });

  this.options = { autoDelete: true, closeChannelOnUnsubscribe: false };
  _.assignIn(this.options, options || {});

  this._openCallback = callback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.<span class="apidocCodeKeywordSpan">queue</span>(name[, options][, openCallback])](#connectionqueuename-options-opencallback
)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.super_" id="apidoc.element.amqp.queue.super_">
        function <span class="apidocSignatureSpan">amqp.queue.</span>super_
        <span class="apidocSignatureSpan">(connection, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Channel(connection, channel) {
  events.EventEmitter.call(this);

  // Unlimited listeners. Helps when e.g. publishing high-volume messages,
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.reconnect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.queue.prototype" id="apidoc.module.amqp.queue.prototype">module amqp.queue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.queue.prototype._onContent" id="apidoc.element.amqp.queue.prototype._onContent">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onContent
        <span class="apidocSignatureSpan">(channel, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onContent = function (channel, data) {
  this.currentMessage.read += data.length;
  this.currentMessage.emit(&#x27;data&#x27;, data);
  if (this.currentMessage.read == this.currentMessage.size) {
    this.currentMessage.emit(&#x27;end&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype._onContentHeader" id="apidoc.element.amqp.queue.prototype._onContentHeader">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onContentHeader
        <span class="apidocSignatureSpan">(channel, classInfo, weight, properties, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onContentHeader = function (channel, classInfo, weight, properties, size) {
  _.assignIn(this.currentMessage, properties);
  this.currentMessage.read = 0;
  this.currentMessage.size = size;

  this.emit(&#x27;rawMessage&#x27;, this.currentMessage);
  if (size === 0) {
    // If the message has no body, directly emit &#x27;end&#x27;
    this.currentMessage.emit(&#x27;end&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype._onMethod" id="apidoc.element.amqp.queue.prototype._onMethod">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onMethod = function (channel, method, args) {
  var self = this;
  this.emit(method.name, args);
  if (this._handleTaskReply.apply(this, arguments)) return;

  switch (method) {
    case methods.channelOpenOk:
      if (this.options.noDeclare) {
        this.state = &#x27;open&#x27;;

        if (this._openCallback) {
         this._openCallback(this);
         this._openCallback = null;
        }

        this.emit(&#x27;open&#x27;);
      } else {
        if (this.name.indexOf(&#x27;amq.&#x27;) == 0) {
          this.name = &#x27;&#x27;;
        }
        this.connection._sendMethod(channel, methods.queueDeclare,
            { reserved1: 0
            , queue: this.name
            , passive: !!this.options.passive
            , durable: !!this.options.durable
            , exclusive: !!this.options.exclusive
            , autoDelete: !!this.options.autoDelete
            , noWait: false
            , &#x22;arguments&#x22;: this.options.arguments || {}
            });
        this.state = &#x22;declare queue&#x22;;
      }
      break;

    case methods.queueDeclareOk:
      this.state = &#x27;open&#x27;;
      this.name = args.queue;
      this.connection.queues[this.name] = this;

      // Rebind to previously bound exchanges, if present.
      // Important this is called *before* openCallback, otherwise bindings will happen twice.
      // Run test-purge to make sure you got this right
      _.forEach(this._bindings, function(exchange, exchangeName){
        _.forEach(exchange, function(count, routingKey){
          self.bind(exchangeName, routingKey);
        });
      });

      // Call opening callback (passed in function)
      // FIXME use eventemitter - maybe we call a namespaced event here
      if (this._openCallback) {
        this._openCallback(this, args.messageCount, args.consumerCount);
        this._openCallback = null;
      }

      // TODO this is legacy interface, remove me
      this.emit(&#x27;open&#x27;, args.queue, args.messageCount, args.consumerCount);

      // If this is a reconnect, we must re-subscribe our queue listeners.
      var consumerTags = Object.keys(this.consumerTagListeners);
      for (var index in consumerTags) {
        if (consumerTags.hasOwnProperty(index)) {
          if (this.consumerTagOptions[consumerTags[index]][&#x27;state&#x27;] === &#x27;closed&#x27;) {
            this.subscribeRaw(this.consumerTagOptions[consumerTags[index]], this.consumerTagListeners[consumerTags[index]]);
            // Having called subscribeRaw, we are now a new consumer with a new consumerTag.
            delete this.consumerTagListeners[consumerTags[index]];
            delete this.consumerTagOptions[consumerTags[index]];
          }
        }
      }
      break;

    case methods.basicConsumeOk:
      debug &#x26;&#x26; debug(&#x27;basicConsumeOk&#x27;, util.inspect(args, null));
      break;

    case methods.queueBindOk:
      if (this._bindCallback) {
        // setting this._bindCallback to null before calling the callback allows for a subsequent bind within the callback
        // FIXME use eventemitter
        var cb = this._bindCallback;
        this._bindCallback = null;
        cb(this);
      }
      break;

    case methods.queueUnbindOk:
      break;

    case methods.basicQosOk:
      break;

    case methods.confirmSelectOk:
      this._sequence = 1;
      this.confirm = true;
      break;

    case methods.channelClose:
      this.state = &#x22;closed&#x22;;
      this.closeOK();
      this.connection.queueClosed(this.name);
      var e = new Error(args.replyText);
      e.code = args.replyCode;
      this.emit(&#x27;error&#x27;, e);
      this.emit(&#x27;close&#x27;);
      break;

    case methods.channelCloseOk:
      this.connection.queueClosed(this.name);
      this.emit(&#x27;close&#x27;);
      break;

    case methods.basicDeliver:
      this.currentMessage = new Message(this, args);
      break;

    case methods.queueDeleteOk:
      break;

    case methods.basicCancel:
      this.close(&#x22;Closed due to basicCancel received on consumer (&#x22; + args.consumerTag + &#x22;)&#x22;);
      break;

    default:
      throw new Error(&#x22;Uncaught method &#x27;&#x22; + method.name + &#x22;&#x27; with args &#x22; +
          JSON.stringify(args) + &#x22;; tasks = &#x22; + JSON.stringify(this._ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Channel.prototype._onChannelMethod = function(channel, method, args) {
switch (method) {
  case methods.channelCloseOk:
    delete this.connection.channels[this.channel];
    this.state = &#x27;closed&#x27;;
    // TODO should this be falling through?
  default:
    this.<span class="apidocCodeKeywordSpan">_onMethod</span>(channel, method, args);
}
};

Channel.prototype.close = function(reason) {
this.state = &#x27;closing&#x27;;
this.connection._sendMethod(this.channel, methods.channelClose,
                            {&#x27;replyText&#x27;: reason ? reason : &#x27;Goodbye from node&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.bind" id="apidoc.element.amqp.queue.prototype.bind">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>bind
        <span class="apidocSignatureSpan">(exchange, routingKey, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind = function (exchange, routingKey, callback) {
  var self = this;

  // The first argument, exchange is optional.
  // If not supplied the connection will use the &#x27;amq.topic&#x27;
  // exchange.
  if (routingKey === undefined || _.isFunction(routingKey)) {
    callback = routingKey;
    routingKey = exchange;
    exchange = &#x27;amq.topic&#x27;;
  }

  if (_.isFunction(callback)) this._bindCallback = callback;

  var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;

  if (exchangeName in self.connection.exchanges) {
    this.exchange = self.connection.exchanges[exchangeName];
    this.exchange.binds++;
  }

  // Record this binding so we can restore it upon reconnect.
  if (!this._bindings[exchangeName]) {
    this._bindings[exchangeName] = {};
  }

  if (!this._bindings[exchangeName][routingKey]) {
    this._bindings[exchangeName][routingKey] = 0;
  }

  this._bindings[exchangeName][routingKey]++;

  self.connection._sendMethod(self.channel, methods.queueBind,
      { reserved1: 0
      , queue: self.name
      , exchange: exchangeName
      , routingKey: routingKey
      , noWait: false
      , &#x22;arguments&#x22;: {}
      });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.<span class="apidocCodeKeywordSpan">bind</span>([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.bind_headers" id="apidoc.element.amqp.queue.prototype.bind_headers">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>bind_headers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind_headers = function () {
  var self = this;

  // The first argument, exchange is optional.
  // If not supplied the connection will use the default &#x27;amq.headers&#x27;
  // exchange.

  var exchange, matchingPairs;

  if (arguments.length == 2) {
    exchange = arguments[0];
    matchingPairs = arguments[1];
  } else {
    exchange = &#x27;amq.headers&#x27;;
    matchingPairs = arguments[0];
  }


  return this._taskPush(methods.queueBindOk, function () {
    var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;
    self.connection._sendMethod(self.channel, methods.queueBind,
        { reserved1: 0
        , queue: self.name
        , exchange: exchangeName
        , routingKey: &#x27;&#x27;
        , noWait: false
        , &#x22;arguments&#x22;: matchingPairs
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.<span class="apidocCodeKeywordSpan">bind_headers</span>([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.destroy" id="apidoc.element.amqp.queue.prototype.destroy">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>destroy
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (options) {
  var self = this;

  options = options || {};
  return this._taskPush(methods.queueDeleteOk, function () {
    self.connection.queueClosed(self.name);
    if (&#x27;exchange&#x27; in self) {
      self.exchange.binds--;
    }
    self.connection._sendMethod(self.channel, methods.queueDelete,
        { reserved1: 0
        , queue: self.name
        , ifUnused: options.ifUnused ? true : false
        , ifEmpty: options.ifEmpty ? true : false
        , noWait: false
        , &#x22;arguments&#x22;: {}
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.<span class="apidocCodeKeywordSpan">destroy</span>(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.flow" id="apidoc.element.amqp.queue.prototype.flow">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>flow
        <span class="apidocSignatureSpan">(active)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flow = function (active) {
  var self = this;
  return this._taskPush(methods.channelFlowOk, function () {
    self.connection._sendMethod(self.channel, methods.channelFlow, {&#x27;active&#x27;: active });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.purge" id="apidoc.element.amqp.queue.prototype.purge">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>purge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purge = function () {
  var self = this;
  return this._taskPush(methods.queuePurgeOk, function () {
    self.connection._sendMethod(self.channel, methods.queuePurge,
                                 { reserved1 : 0,
                                 queue: self.name,
                                 noWait: false});
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.shift" id="apidoc.element.amqp.queue.prototype.shift">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>shift
        <span class="apidocSignatureSpan">(reject, requeue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function (reject, requeue) {
  if (this._lastMessage) {
    if (reject) {
      this._lastMessage.reject(requeue ? true : false);
    } else {
      this._lastMessage.acknowledge();
    }
    this._lastMessage = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.<span class="apidocCodeKeywordSpan">shift</span>([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.subscribe" id="apidoc.element.amqp.queue.prototype.subscribe">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(options, messageListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (options, messageListener) {
  var self = this;

  // Optional options
  if (typeof options === &#x22;function&#x22;) {
    messageListener = options;
    options = {};
  }

  options = _.defaults(options || {}, {
    ack: false,
    prefetchCount: 1,
    routingKeyInPayload: self.connection.options.routingKeyInPayload,
    deliveryTagInPayload: self.connection.options.deliveryTagInPayload
  });

  // basic consume
  var rawOptions = {
      noAck: !options.ack,
      exclusive: options.exclusive
  };

  if (options.ack) {
    rawOptions[&#x27;prefetchCount&#x27;] = options.prefetchCount;
  }

  return this.subscribeRaw(rawOptions, function (m) {
    var contentType = m.contentType;
    var decoder = new StringDecoder(&#x27;utf8&#x27;);

    if (contentType == null &#x26;&#x26; m.headers &#x26;&#x26; m.headers.properties) {
      contentType = m.headers.properties.content_type;
    }

    var isJSON = contentType == &#x27;text/json&#x27; ||
                 contentType == &#x27;application/json&#x27;;

    var buffer;

    if (isJSON) {
      buffer = &#x22;&#x22;;
    } else {
      buffer = new Buffer(m.size);
      buffer.used = 0;
    }

    self._lastMessage = m;

    m.addListener(&#x27;data&#x27;, function (d) {
      if (isJSON) {
        buffer += decoder.write(d);
      } else {
        d.copy(buffer, buffer.used);
        buffer.used += d.length;
      }
    });

    m.addListener(&#x27;end&#x27;, function () {
      var json, deliveryInfo = {}, msgProperties = classes[60].fields, i, l;

      if (isJSON) {
        decoder.end();
        try {
          json = JSON.parse(buffer);
        } catch (e) {
          json = null;
          deliveryInfo.parseError = e;
          deliveryInfo.rawData = buffer;
        }
      } else {
        json = { data: buffer, contentType: m.contentType };
      }

      for (i = 0, l = msgProperties.length; i&#x3c;l; i++) {
        if (m[msgProperties[i].name]) {
          deliveryInfo[msgProperties[i].name] = m[msgProperties[i].name];
        }
      }

      deliveryInfo.queue = m.queue ? m.queue.name : null;
      deliveryInfo.deliveryTag = m.deliveryTag;
      deliveryInfo.redelivered = m.redelivered;
      deliveryInfo.exchange = m.exchange;
      deliveryInfo.routingKey = m.routingKey;
      deliveryInfo.consumerTag = m.consumerTag;

      if (options.routingKeyInPayload) json._routingKey = m.routingKey;
      if (options.deliveryTagInPayload) json._deliveryTag = m.deliveryTag;

      var headers = {};
      for (i in this.headers) {
        if (this.headers.hasOwnProperty(i)) {
          if (this.headers[i] instanceof Buffer) {
            headers[i] = this.headers[i].toString();
          } else {
            headers[i] = this.headers[i];
          }
        }
      }

      if (messageListener) messageListener(json, headers, deliveryInfo, m);
      self.emit(&#x27;message&#x27;, json, headers, deliveryInfo, m);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.<span class="apidocCodeKeywordSpan">subscribe</span>([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.subscribeJSON" id="apidoc.element.amqp.queue.prototype.subscribeJSON">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribeJSON
        <span class="apidocSignatureSpan">(options, messageListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeJSON = function (options, messageListener) {
  var self = this;

  // Optional options
  if (typeof options === &#x22;function&#x22;) {
    messageListener = options;
    options = {};
  }

  options = _.defaults(options || {}, {
    ack: false,
    prefetchCount: 1,
    routingKeyInPayload: self.connection.options.routingKeyInPayload,
    deliveryTagInPayload: self.connection.options.deliveryTagInPayload
  });

  // basic consume
  var rawOptions = {
      noAck: !options.ack,
      exclusive: options.exclusive
  };

  if (options.ack) {
    rawOptions[&#x27;prefetchCount&#x27;] = options.prefetchCount;
  }

  return this.subscribeRaw(rawOptions, function (m) {
    var contentType = m.contentType;
    var decoder = new StringDecoder(&#x27;utf8&#x27;);

    if (contentType == null &#x26;&#x26; m.headers &#x26;&#x26; m.headers.properties) {
      contentType = m.headers.properties.content_type;
    }

    var isJSON = contentType == &#x27;text/json&#x27; ||
                 contentType == &#x27;application/json&#x27;;

    var buffer;

    if (isJSON) {
      buffer = &#x22;&#x22;;
    } else {
      buffer = new Buffer(m.size);
      buffer.used = 0;
    }

    self._lastMessage = m;

    m.addListener(&#x27;data&#x27;, function (d) {
      if (isJSON) {
        buffer += decoder.write(d);
      } else {
        d.copy(buffer, buffer.used);
        buffer.used += d.length;
      }
    });

    m.addListener(&#x27;end&#x27;, function () {
      var json, deliveryInfo = {}, msgProperties = classes[60].fields, i, l;

      if (isJSON) {
        decoder.end();
        try {
          json = JSON.parse(buffer);
        } catch (e) {
          json = null;
          deliveryInfo.parseError = e;
          deliveryInfo.rawData = buffer;
        }
      } else {
        json = { data: buffer, contentType: m.contentType };
      }

      for (i = 0, l = msgProperties.length; i&#x3c;l; i++) {
        if (m[msgProperties[i].name]) {
          deliveryInfo[msgProperties[i].name] = m[msgProperties[i].name];
        }
      }

      deliveryInfo.queue = m.queue ? m.queue.name : null;
      deliveryInfo.deliveryTag = m.deliveryTag;
      deliveryInfo.redelivered = m.redelivered;
      deliveryInfo.exchange = m.exchange;
      deliveryInfo.routingKey = m.routingKey;
      deliveryInfo.consumerTag = m.consumerTag;

      if (options.routingKeyInPayload) json._routingKey = m.routingKey;
      if (options.deliveryTagInPayload) json._deliveryTag = m.deliveryTag;

      var headers = {};
      for (i in this.headers) {
        if (this.headers.hasOwnProperty(i)) {
          if (this.headers[i] instanceof Buffer) {
            headers[i] = this.headers[i].toString();
          } else {
            headers[i] = this.headers[i];
          }
        }
      }

      if (messageListener) messageListener(json, headers, deliveryInfo, m);
      self.emit(&#x27;message&#x27;, json, headers, deliveryInfo, m);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.subscribeRaw" id="apidoc.element.amqp.queue.prototype.subscribeRaw">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribeRaw
        <span class="apidocSignatureSpan">(options, messageListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeRaw = function (options, messageListener) {
  var self = this;

  // multiple method signatures
  if (typeof options === &#x22;function&#x22;) {
    messageListener = options;
    options = {};
  }

  var consumerTag = &#x27;node-amqp-&#x27; + process.pid + &#x27;-&#x27; + Math.random();
  this.consumerTagListeners[consumerTag] = messageListener;

  options = options || {};
  options[&#x27;state&#x27;] = &#x27;opening&#x27;;
  this.consumerTagOptions[consumerTag] = options;
  if (options.prefetchCount !== undefined) {
    self.connection._sendMethod(self.channel, methods.basicQos,
        { reserved1: 0
        , prefetchSize: 0
        , prefetchCount: options.prefetchCount
        , global: false
        });
  }

  return this._taskPush(methods.basicConsumeOk, function () {
    self.connection._sendMethod(self.channel, methods.basicConsume,
        { reserved1: 0
        , queue: self.name
        , consumerTag: consumerTag
        , noLocal: !!options.noLocal
        , noAck: !!options.noAck
        , exclusive: !!options.exclusive
        , noWait: false
        , &#x22;arguments&#x22;: {}
        });
    self.consumerTagOptions[consumerTag][&#x27;state&#x27;] = &#x27;open&#x27;;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Connection](#connection)
  - [Connection options and URL](#connection-options-and-url)
  - [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
  - [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
  - [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
  - [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
  - [queue.<span class="apidocCodeKeywordSpan">subscribeRaw</span>([options,] listener)](#queuesubscriberawoptions-listener)
  - [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
  - [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
  - [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
  - [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
  - [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
  - [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.unbind" id="apidoc.element.amqp.queue.prototype.unbind">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unbind
        <span class="apidocSignatureSpan">(exchange, routingKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbind = function (exchange, routingKey) {
  var self = this;

  // The first argument, exchange is optional.
  // If not supplied the connection will use the default &#x27;amq.topic&#x27;
  // exchange.
  if (routingKey === undefined) {
    routingKey = exchange;
    exchange = &#x27;amq.topic&#x27;;
  }

  var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;

  // Decrement binding count.
  this._bindings[exchangeName][routingKey]--;
  if (!this._bindings[exchangeName][routingKey]) {
    delete this._bindings[exchangeName][routingKey];
  }

  // If there are no more bindings to this exchange, delete the key for the exchange.
  if (!_.keys(this._bindings[exchangeName]).length){
    delete this._bindings[exchangeName];
  }

  return this._taskPush(methods.queueUnbindOk, function () {
    self.connection._sendMethod(self.channel, methods.queueUnbind,
        { reserved1: 0
        , queue: self.name
        , exchange: exchangeName
        , routingKey: routingKey
        , noWait: false
        , &#x22;arguments&#x22;: {}
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.<span class="apidocCodeKeywordSpan">unbind</span>([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.unbind_headers" id="apidoc.element.amqp.queue.prototype.unbind_headers">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unbind_headers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbind_headers = function () {
  var self = this;

  // The first argument, exchange is optional.
  // If not supplied the connection will use the default &#x27;amq.topic&#x27;
  // exchange.

  var exchange, matchingPairs;

  if (arguments.length === 2) {
    exchange = arguments[0];
    matchingPairs = arguments[1];
  } else {
    exchange = &#x27;amq.headers&#x27;;
    matchingPairs = arguments[0];
  }

  return this._taskPush(methods.queueUnbindOk, function () {
    var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;
    self.connection._sendMethod(self.channel, methods.queueUnbind,
        { reserved1: 0
        , queue: self.name
        , exchange: exchangeName
        , routingKey: &#x27;&#x27;
        , noWait: false
        , &#x22;arguments&#x22;: matchingPairs
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
bound it will not receive any messages.

This method is to be used on an &#x22;headers&#x22;-type exchange. The routing
argument must contain the routing keys and the `x-match` value (`all` or `any`).

If the `exchange` argument is left out `&#x27;amq.headers&#x27;` will be used.

### queue.<span class="apidocCodeKeywordSpan">unbind_headers</span>([exchange,] routing)

This method unbinds a queue from an exchange.  Whilst a queue is
bound it will continue receive messages that have matching headers.

This method is to be used on an &#x22;headers&#x22;-type exchange. The routing
argument must contain the routing keys and the `x-match` value (`all` or `any`).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.unsubscribe" id="apidoc.element.amqp.queue.prototype.unsubscribe">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unsubscribe
        <span class="apidocSignatureSpan">(consumerTag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function (consumerTag) {
  var self = this;
  return this._taskPush(methods.basicCancelOk, function () {
    self.connection._sendMethod(self.channel, methods.basicCancel,
                                { reserved1: 0,
                                  consumerTag: consumerTag,
                                  noWait: false });
  })
  .addCallback(function () {
    if (self.options.closeChannelOnUnsubscribe) {
      self.close();
    }
    delete self.consumerTagListeners[consumerTag];
    delete self.consumerTagOptions[consumerTag];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.<span class="apidocCodeKeywordSpan">unsubscribe</span>(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on(&#x27;open&#x27;, callback)](#exchangeonopen-callback)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.serializer" id="apidoc.module.amqp.serializer">module amqp.serializer</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.serializer.getCode" id="apidoc.element.amqp.serializer.getCode">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>getCode
        <span class="apidocSignatureSpan">(dec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCode = function (dec) {
  var hexArray = &#x22;0123456789ABCDEF&#x22;.split(&#x27;&#x27;);
  var code1 = Math.floor(dec / 16);
  var code2 = dec - code1 * 16;
  return hexArray[code2];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.isBigInt" id="apidoc.element.amqp.serializer.isBigInt">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>isBigInt
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBigInt = function (value) {
  return value &#x3e; 0xffffffff;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;string&#x27;:
  b[b.used++] = &#x27;S&#x27;.charCodeAt(0);
  serializer.serializeLongString(b, value);
  break;

case &#x27;number&#x27;:
  if (!serializer.isFloat(value)) {
    if (serializer.<span class="apidocCodeKeywordSpan">isBigInt</span>(value)) {
      // 64-bit uint
      b[b.used++] = &#x27;l&#x27;.charCodeAt(0);
      serializer.serializeInt(b, 8, value);
    } else {
      //32-bit uint
      b[b.used++] = &#x27;I&#x27;.charCodeAt(0);
      serializer.serializeInt(b, 4, value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.isFloat" id="apidoc.element.amqp.serializer.isFloat">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>isFloat
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFloat = function (value){
  return value === +value &#x26;&#x26; value !== (value|0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    switch (typeof(value)) {
case &#x27;string&#x27;:
  b[b.used++] = &#x27;S&#x27;.charCodeAt(0);
  serializer.serializeLongString(b, value);
  break;

case &#x27;number&#x27;:
  if (!serializer.<span class="apidocCodeKeywordSpan">isFloat</span>(value)) {
    if (serializer.isBigInt(value)) {
      // 64-bit uint
      b[b.used++] = &#x27;l&#x27;.charCodeAt(0);
      serializer.serializeInt(b, 8, value);
    } else {
      //32-bit uint
      b[b.used++] = &#x27;I&#x27;.charCodeAt(0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeArray" id="apidoc.element.amqp.serializer.serializeArray">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeArray
        <span class="apidocSignatureSpan">(b, arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeArray = function (b, arr) {
  // Save our position so that we can go back and write the byte length of this array
  // at the beginning of the packet (once we have serialized all elements).
  var lengthIndex = b.used;
  b.used += 4; // sizeof long
  var startIndex = b.used;

  var len = arr.length;
  for (var i = 0; i &#x3c; len; i++) {
    serializer.serializeValue(b, arr[i]);
  }

  var endIndex = b.used;
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      b[b.used++] = &#x27;T&#x27;.charCodeAt(0);
      serializer.serializeDate(b, value);
    } else if (value instanceof Buffer) {
      b[b.used++] = &#x27;x&#x27;.charCodeAt(0);
      serializer.serializeBuffer(b, value);
    } else if (Array.isArray(value)) {
      b[b.used++] = &#x27;A&#x27;.charCodeAt(0);
      serializer.<span class="apidocCodeKeywordSpan">serializeArray</span>(b, value);
    } else if (typeof(value) === &#x27;object&#x27;) {
      b[b.used++] = &#x27;F&#x27;.charCodeAt(0);
      serializer.serializeTable(b, value);
    } else {
      throw new Error(&#x22;unsupported type in amqp table: &#x22; + typeof(value));
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeBase64" id="apidoc.element.amqp.serializer.serializeBase64">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeBase64
        <span class="apidocSignatureSpan">(b, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeBase64 = function (b, buffer) {
  serializer.serializeLongString(b, buffer.toString(&#x27;base64&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeBuffer" id="apidoc.element.amqp.serializer.serializeBuffer">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeBuffer
        <span class="apidocSignatureSpan">(b, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeBuffer = function (b, buffer) {
  serializer.serializeInt(b, 4, buffer.length);
  buffer.copy(b, b.used, 0);
  b.used += buffer.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      default:
if (value instanceof Date) {
  b[b.used++] = &#x27;T&#x27;.charCodeAt(0);
  serializer.serializeDate(b, value);
} else if (value instanceof Buffer) {
  b[b.used++] = &#x27;x&#x27;.charCodeAt(0);
  serializer.<span class="apidocCodeKeywordSpan">serializeBuffer</span>(b, value);
} else if (Array.isArray(value)) {
  b[b.used++] = &#x27;A&#x27;.charCodeAt(0);
  serializer.serializeArray(b, value);
} else if (typeof(value) === &#x27;object&#x27;) {
  b[b.used++] = &#x27;F&#x27;.charCodeAt(0);
  serializer.serializeTable(b, value);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeDate" id="apidoc.element.amqp.serializer.serializeDate">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeDate
        <span class="apidocSignatureSpan">(b, date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeDate = function (b, date) {
  serializer.serializeInt(b, 8, date.valueOf() / 1000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  b[b.used++] = &#x27;t&#x27;.charCodeAt(0);
  b[b.used++] = value;
  break;

default:
  if (value instanceof Date) {
    b[b.used++] = &#x27;T&#x27;.charCodeAt(0);
    serializer.<span class="apidocCodeKeywordSpan">serializeDate</span>(b, value);
  } else if (value instanceof Buffer) {
    b[b.used++] = &#x27;x&#x27;.charCodeAt(0);
    serializer.serializeBuffer(b, value);
  } else if (Array.isArray(value)) {
    b[b.used++] = &#x27;A&#x27;.charCodeAt(0);
    serializer.serializeArray(b, value);
  } else if (typeof(value) === &#x27;object&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeFields" id="apidoc.element.amqp.serializer.serializeFields">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeFields
        <span class="apidocSignatureSpan">(buffer, fields, args, strict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeFields = function (buffer, fields, args, strict) {
  var bitField = 0;
  var bitIndex = 0;
  for (var i = 0; i &#x3c; fields.length; i++) {
    var field = fields[i];
    var domain = field.domain;
    if (!(field.name in args)) {
      if (strict) {
        throw new Error(&#x22;Missing field &#x27;&#x22; + field.name + &#x22;&#x27; of type &#x27;&#x22; + domain + &#x22;&#x27; while executing AMQP method &#x27;&#x22; +
          arguments.callee.caller.arguments[1].name + &#x22;&#x27;&#x22;);
      }
      continue;
    }

    var param = args[field.name];

    //debug(&#x22;domain: &#x22; + domain + &#x22; param: &#x22; + param);

    switch (domain) {
      case &#x27;bit&#x27;:
        if (typeof(param) != &#x22;boolean&#x22;) {
          throw new Error(&#x22;Unmatched field &#x22; + JSON.stringify(field));
        }

        if (param) bitField |= (1 &#x3c;&#x3c; bitIndex);
        bitIndex++;

        if (!fields[i+1] || fields[i+1].domain != &#x27;bit&#x27;) {
          //debug(&#x27;SET bit field &#x27; + field.name + &#x27; 0x&#x27; + bitField.toString(16));
          buffer[buffer.used++] = bitField;
          bitField = 0;
          bitIndex = 0;
        }
        break;

      case &#x27;octet&#x27;:
        if (typeof(param) != &#x22;number&#x22; || param &#x3e; 0xFF) {
          throw new Error(&#x22;Unmatched field &#x22; + JSON.stringify(field));
        }
        buffer[buffer.used++] = param;
        break;

      case &#x27;short&#x27;:
        if (typeof(param) != &#x22;number&#x22; || param &#x3e; 0xFFFF) {
          throw new Error(&#x22;Unmatched field &#x22; + JSON.stringify(field));
        }
        serializer.serializeInt(buffer, 2, param);
        break;

      case &#x27;long&#x27;:
        if (typeof(param) != &#x22;number&#x22; || param &#x3e; 0xFFFFFFFF) {
          throw new Error(&#x22;Unmatched field &#x22; + JSON.stringify(field));
        }
        serializer.serializeInt(buffer, 4, param);
        break;

      // In a previous version this shared code with &#x27;longlong&#x27;, which caused problems when passed Date
      // integers. Nobody expects to pass a Buffer here, 53 bits is still 28 million years after 1970, we&#x27;ll be fine.
      case &#x27;timestamp&#x27;:
        serializer.serializeInt(buffer, 8, param);
        break;

      case &#x27;longlong&#x27;:
        for (var j = 0; j &#x3c; 8; j++) {
          buffer[buffer.used++] = param[j];
        }
        break;

      case &#x27;shortstr&#x27;:
        if (typeof(param) != &#x22;string&#x22; || param.length &#x3e; 0xFF) {
          throw new Error(&#x22;Unmatched field &#x22; + JSON.stringify(field));
        }
        serializer.serializeShortString(buffer, param);
        break;

      case &#x27;longstr&#x27;:
        serializer.serializeLongString(buffer, param);
        break;

      case &#x27;table&#x27;:
        if (typeof(param) != &#x22;object&#x22;) {
          throw new Error(&#x22;Unmatched field &#x22; + JSON.stringify(field));
        }
        serializer.serializeTable(buffer, param);
        break;

      default:
        throw new Error(&#x22;Unknown domain value type &#x22; + domain);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeFloat" id="apidoc.element.amqp.serializer.serializeFloat">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeFloat
        <span class="apidocSignatureSpan">(b, size, value, bigEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeFloat = function (b, size, value, bigEndian) {
  var jp = new jspack(bigEndian);

  switch(size) {
    case 4:
      var x = jp.Pack(&#x27;f&#x27;, [value]);
      for (var i = 0; i &#x3c; x.length; ++i)
        b[b.used++] = x[i];
      break;

    case 8:
      var x = jp.Pack(&#x27;d&#x27;, [value]);
      for (var i = 0; i &#x3c; x.length; ++i)
        b[b.used++] = x[i];
      break;

    default:
      throw new Error(&#x22;Unknown floating point size&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      //32-bit uint
      b[b.used++] = &#x27;I&#x27;.charCodeAt(0);
      serializer.serializeInt(b, 4, value);
    }
  } else {
    //64-bit float
    b[b.used++] = &#x27;d&#x27;.charCodeAt(0);
    serializer.<span class="apidocCodeKeywordSpan">serializeFloat</span>(b, 8, value);
  }
  break;

case &#x27;boolean&#x27;:
  b[b.used++] = &#x27;t&#x27;.charCodeAt(0);
  b[b.used++] = value;
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeInt" id="apidoc.element.amqp.serializer.serializeInt">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeInt
        <span class="apidocSignatureSpan">(b, size, int)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeInt = function (b, size, int) {
  if (b.used + size &#x3e; b.length) {
    throw new Error(&#x22;write out of bounds&#x22;);
  }

  // Only 4 cases - just going to be explicit instead of looping.

  switch (size) {
    // octet
    case 1:
      b[b.used++] = int;
      break;

    // short
    case 2:
      b[b.used++] = (int &#x26; 0xFF00) &#x3e;&#x3e; 8;
      b[b.used++] = (int &#x26; 0x00FF) &#x3e;&#x3e; 0;
      break;

    // long
    case 4:
      b[b.used++] = (int &#x26; 0xFF000000) &#x3e;&#x3e; 24;
      b[b.used++] = (int &#x26; 0x00FF0000) &#x3e;&#x3e; 16;
      b[b.used++] = (int &#x26; 0x0000FF00) &#x3e;&#x3e; 8;
      b[b.used++] = (int &#x26; 0x000000FF) &#x3e;&#x3e; 0;
      break;


    // long long
    case 8:
      b[b.used++] = (int &#x26; 0xFF00000000000000) &#x3e;&#x3e; 56;
      b[b.used++] = (int &#x26; 0x00FF000000000000) &#x3e;&#x3e; 48;
      b[b.used++] = (int &#x26; 0x0000FF0000000000) &#x3e;&#x3e; 40;
      b[b.used++] = (int &#x26; 0x000000FF00000000) &#x3e;&#x3e; 32;
      b[b.used++] = (int &#x26; 0x00000000FF000000) &#x3e;&#x3e; 24;
      b[b.used++] = (int &#x26; 0x0000000000FF0000) &#x3e;&#x3e; 16;
      b[b.used++] = (int &#x26; 0x000000000000FF00) &#x3e;&#x3e; 8;
      b[b.used++] = (int &#x26; 0x00000000000000FF) &#x3e;&#x3e; 0;
      break;

    default:
      throw new Error(&#x22;Bad size&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

serializeLongString: function(b, string) {
  // we accept string, object, or buffer for this parameter.
  // in the case of string we serialize it to utf8.
  if (typeof(string) == &#x27;string&#x27;) {
    var byteLength = Buffer.byteLength(string, &#x27;utf8&#x27;);
    serializer.<span class="apidocCodeKeywordSpan">serializeInt</span>(b, 4, byteLength);
    b.write(string, b.used, &#x27;utf8&#x27;);
    b.used += byteLength;
  } else if (typeof(string) == &#x27;object&#x27;) {
    serializer.serializeTable(b, string);
  } else {
    // data is Buffer
    var byteLength = string.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeLongString" id="apidoc.element.amqp.serializer.serializeLongString">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeLongString
        <span class="apidocSignatureSpan">(b, string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeLongString = function (b, string) {
  // we accept string, object, or buffer for this parameter.
  // in the case of string we serialize it to utf8.
  if (typeof(string) == &#x27;string&#x27;) {
    var byteLength = Buffer.byteLength(string, &#x27;utf8&#x27;);
    serializer.serializeInt(b, 4, byteLength);
    b.write(string, b.used, &#x27;utf8&#x27;);
    b.used += byteLength;
  } else if (typeof(string) == &#x27;object&#x27;) {
    serializer.serializeTable(b, string);
  } else {
    // data is Buffer
    var byteLength = string.length;
    serializer.serializeInt(b, 4, byteLength);
    b.write(string, b.used); // memcpy
    b.used += byteLength;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
serializeBuffer: function(b, buffer) {
  serializer.serializeInt(b, 4, buffer.length);
  buffer.copy(b, b.used, 0);
  b.used += buffer.length;
},

serializeBase64: function(b, buffer) {
  serializer.<span class="apidocCodeKeywordSpan">serializeLongString</span>(b, buffer.toString(&#x27;base64&#x27;));
},

isBigInt: function(value) {
  return value &#x3e; 0xffffffff;
},

getCode: function(dec) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeShortString" id="apidoc.element.amqp.serializer.serializeShortString">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeShortString
        <span class="apidocSignatureSpan">(b, string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeShortString = function (b, string) {
  if (typeof(string) != &#x22;string&#x22;) {
    throw new Error(&#x22;param must be a string&#x22;);
  }
  var byteLength = Buffer.byteLength(string, &#x27;utf8&#x27;);
  if (byteLength &#x3e; 0xFF) {
    throw new Error(&#x22;String too long for &#x27;shortstr&#x27; parameter&#x22;);
  }
  if (1 + byteLength + b.used &#x3e;= b.length) {
    throw new Error(&#x22;Not enough space in buffer for &#x27;shortstr&#x27;&#x22;);
  }
  b[b.used++] = byteLength;
  b.write(string, b.used, &#x27;utf8&#x27;);
  b.used += byteLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// at the beginning of the packet (once we know how many entries there are).
var lengthIndex = b.used;
b.used += 4; // sizeof long
var startIndex = b.used;

for (var key in object) {
  if (!object.hasOwnProperty(key)) continue;
  serializer.<span class="apidocCodeKeywordSpan">serializeShortString</span>(b, key);
  serializer.serializeValue(b, object[key]);
}

var endIndex = b.used;
b.used = lengthIndex;
serializer.serializeInt(b, 4, endIndex - startIndex);
b.used = endIndex;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeTable" id="apidoc.element.amqp.serializer.serializeTable">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeTable
        <span class="apidocSignatureSpan">(b, object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeTable = function (b, object) {
  if (typeof(object) != &#x22;object&#x22;) {
    throw new Error(&#x22;param must be an object&#x22;);
  }

  // Save our position so that we can go back and write the length of this table
  // at the beginning of the packet (once we know how many entries there are).
  var lengthIndex = b.used;
  b.used += 4; // sizeof long
  var startIndex = b.used;

  for (var key in object) {
    if (!object.hasOwnProperty(key)) continue;
    serializer.serializeShortString(b, key);
    serializer.serializeValue(b, object[key]);
  }

  var endIndex = b.used;
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// in the case of string we serialize it to utf8.
if (typeof(string) == &#x27;string&#x27;) {
  var byteLength = Buffer.byteLength(string, &#x27;utf8&#x27;);
  serializer.serializeInt(b, 4, byteLength);
  b.write(string, b.used, &#x27;utf8&#x27;);
  b.used += byteLength;
} else if (typeof(string) == &#x27;object&#x27;) {
  serializer.<span class="apidocCodeKeywordSpan">serializeTable</span>(b, string);
} else {
  // data is Buffer
  var byteLength = string.length;
  serializer.serializeInt(b, 4, byteLength);
  b.write(string, b.used); // memcpy
  b.used += byteLength;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeValue" id="apidoc.element.amqp.serializer.serializeValue">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeValue
        <span class="apidocSignatureSpan">(b, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeValue = function (b, value) {
  switch (typeof(value)) {
    case &#x27;string&#x27;:
      b[b.used++] = &#x27;S&#x27;.charCodeAt(0);
      serializer.serializeLongString(b, value);
      break;

    case &#x27;number&#x27;:
      if (!serializer.isFloat(value)) {
        if (serializer.isBigInt(value)) {
          // 64-bit uint
          b[b.used++] = &#x27;l&#x27;.charCodeAt(0);
          serializer.serializeInt(b, 8, value);
        } else {
          //32-bit uint
          b[b.used++] = &#x27;I&#x27;.charCodeAt(0);
          serializer.serializeInt(b, 4, value);
        }
      } else {
        //64-bit float
        b[b.used++] = &#x27;d&#x27;.charCodeAt(0);
        serializer.serializeFloat(b, 8, value);
      }
      break;

    case &#x27;boolean&#x27;:
      b[b.used++] = &#x27;t&#x27;.charCodeAt(0);
      b[b.used++] = value;
      break;

    default:
      if (value instanceof Date) {
        b[b.used++] = &#x27;T&#x27;.charCodeAt(0);
        serializer.serializeDate(b, value);
      } else if (value instanceof Buffer) {
        b[b.used++] = &#x27;x&#x27;.charCodeAt(0);
        serializer.serializeBuffer(b, value);
      } else if (Array.isArray(value)) {
        b[b.used++] = &#x27;A&#x27;.charCodeAt(0);
        serializer.serializeArray(b, value);
      } else if (typeof(value) === &#x27;object&#x27;) {
        b[b.used++] = &#x27;F&#x27;.charCodeAt(0);
        serializer.serializeTable(b, value);
      } else {
        throw new Error(&#x22;unsupported type in amqp table: &#x22; + typeof(value));
      }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var lengthIndex = b.used;
  b.used += 4; // sizeof long
  var startIndex = b.used;

  for (var key in object) {
    if (!object.hasOwnProperty(key)) continue;
    serializer.serializeShortString(b, key);
    serializer.<span class="apidocCodeKeywordSpan">serializeValue</span>(b, object[key]);
  }

  var endIndex = b.used;
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;
},
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
