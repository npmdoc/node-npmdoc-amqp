<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/postwait/node-amqp#readme">amqp (v0.2.6)</a>
</h1>
<h4>AMQP driver for node</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp">module amqp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection">
            function <span class="apidocSignatureSpan">amqp.</span>Connection
            <span class="apidocSignatureSpan">(connectionArgs, options, readyCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._bodyToBuffer
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._chooseHost">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._chooseHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._createSocket">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._createSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._getSSLOptions">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._getSSLOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._inboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._onMethod">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._onMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._outboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._parseURLOptions">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._parseURLOptions
            <span class="apidocSignatureSpan">(connectionString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._saslResponse">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._saslResponse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendBody">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendBody
            <span class="apidocSignatureSpan">(channel, body, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendHeader">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendHeader
            <span class="apidocSignatureSpan">(channel, size, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendMethod">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._startHandshake">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._startHandshake
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.addAllListeners">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.addAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.connect">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.disconnect">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.end">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchange">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.exchange
            <span class="apidocSignatureSpan">(name, options, openCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchangeClosed">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.exchangeClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.generateChannelId">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.generateChannelId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.heartbeat">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.publish">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.publish
            <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queue">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.queue
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queueClosed">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.queueClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.reconnect">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.reconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setImplOptions">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.setImplOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setOptions">
            function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.setOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel">
            function <span class="apidocSignatureSpan">amqp.</span>channel
            <span class="apidocSignatureSpan">(connection, channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.createConnection">
            function <span class="apidocSignatureSpan">amqp.</span>createConnection
            <span class="apidocSignatureSpan">(options, implOptions, readyCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange">
            function <span class="apidocSignatureSpan">amqp.</span>exchange
            <span class="apidocSignatureSpan">(connection, channel, name, options, openCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.message">
            function <span class="apidocSignatureSpan">amqp.</span>message
            <span class="apidocSignatureSpan">(queue, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser">
            function <span class="apidocSignatureSpan">amqp.</span>parser
            <span class="apidocSignatureSpan">(version, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue">
            function <span class="apidocSignatureSpan">amqp.</span>queue
            <span class="apidocSignatureSpan">(connection, channel, name, options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>Connection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>channel.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>exchange.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>jspack</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>message.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>promise</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>queue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amqp.</span>serializer</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection">module amqp.Connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.Connection">
            function <span class="apidocSignatureSpan">amqp.</span>Connection
            <span class="apidocSignatureSpan">(connectionArgs, options, readyCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.super_">
            function <span class="apidocSignatureSpan">amqp.Connection.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype">module amqp.Connection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_bodyToBuffer
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._chooseHost">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_chooseHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._createSocket">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_createSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._getSSLOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_getSSLOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_inboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._onMethod">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_onMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_outboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._parseURLOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_parseURLOptions
            <span class="apidocSignatureSpan">(connectionString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._saslResponse">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_saslResponse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendBody">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendBody
            <span class="apidocSignatureSpan">(channel, body, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendHeader">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendHeader
            <span class="apidocSignatureSpan">(channel, size, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendMethod">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._startHandshake">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_startHandshake
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.addAllListeners">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>addAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.connect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.disconnect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.end">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchange">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchange
            <span class="apidocSignatureSpan">(name, options, openCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchangeClosed">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchangeClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.generateChannelId">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>generateChannelId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.heartbeat">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.publish">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>publish
            <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queue">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queue
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queueClosed">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queueClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.reconnect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>reconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setImplOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setImplOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._bodyToBuffer">module amqp.Connection.prototype._bodyToBuffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer._bodyToBuffer">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_bodyToBuffer
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._chooseHost">module amqp.Connection.prototype._chooseHost</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._chooseHost._chooseHost">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_chooseHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._createSocket">module amqp.Connection.prototype._createSocket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._createSocket._createSocket">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_createSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._getSSLOptions">module amqp.Connection.prototype._getSSLOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._getSSLOptions._getSSLOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_getSSLOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._inboundHeartbeatTimerReset">module amqp.Connection.prototype._inboundHeartbeatTimerReset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset._inboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_inboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._onMethod">module amqp.Connection.prototype._onMethod</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._onMethod._onMethod">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_onMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._outboundHeartbeatTimerReset">module amqp.Connection.prototype._outboundHeartbeatTimerReset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset._outboundHeartbeatTimerReset">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_outboundHeartbeatTimerReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._parseURLOptions">module amqp.Connection.prototype._parseURLOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._parseURLOptions._parseURLOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_parseURLOptions
            <span class="apidocSignatureSpan">(connectionString)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._saslResponse">module amqp.Connection.prototype._saslResponse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._saslResponse._saslResponse">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_saslResponse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._sendBody">module amqp.Connection.prototype._sendBody</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendBody._sendBody">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendBody
            <span class="apidocSignatureSpan">(channel, body, properties)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._sendHeader">module amqp.Connection.prototype._sendHeader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendHeader._sendHeader">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendHeader
            <span class="apidocSignatureSpan">(channel, size, properties)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._sendMethod">module amqp.Connection.prototype._sendMethod</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._sendMethod._sendMethod">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype._startHandshake">module amqp.Connection.prototype._startHandshake</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype._startHandshake._startHandshake">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_startHandshake
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.addAllListeners">module amqp.Connection.prototype.addAllListeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.addAllListeners.addAllListeners">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>addAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.connect">module amqp.Connection.prototype.connect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.connect.connect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.disconnect">module amqp.Connection.prototype.disconnect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.disconnect.disconnect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.end">module amqp.Connection.prototype.end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.end.end">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.exchange">module amqp.Connection.prototype.exchange</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchange.exchange">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchange
            <span class="apidocSignatureSpan">(name, options, openCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.exchangeClosed">module amqp.Connection.prototype.exchangeClosed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.exchangeClosed.exchangeClosed">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchangeClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.generateChannelId">module amqp.Connection.prototype.generateChannelId</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.generateChannelId.generateChannelId">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>generateChannelId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.heartbeat">module amqp.Connection.prototype.heartbeat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.heartbeat.heartbeat">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.publish">module amqp.Connection.prototype.publish</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.publish.publish">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>publish
            <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.queue">module amqp.Connection.prototype.queue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queue.queue">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queue
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.queueClosed">module amqp.Connection.prototype.queueClosed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.queueClosed.queueClosed">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queueClosed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.reconnect">module amqp.Connection.prototype.reconnect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.reconnect.reconnect">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>reconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.setImplOptions">module amqp.Connection.prototype.setImplOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setImplOptions.setImplOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setImplOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.Connection.prototype.setOptions">module amqp.Connection.prototype.setOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.Connection.prototype.setOptions.setOptions">
            function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.channel">module amqp.channel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.channel">
            function <span class="apidocSignatureSpan">amqp.</span>channel
            <span class="apidocSignatureSpan">(connection, channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.super_">
            function <span class="apidocSignatureSpan">amqp.channel.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.channel.prototype">module amqp.channel.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype._handleTaskReply">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_handleTaskReply
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype._onChannelMethod">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_onChannelMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype._taskPush">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_taskPush
            <span class="apidocSignatureSpan">(reply, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype._tasksFlush">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_tasksFlush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype.close">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>close
            <span class="apidocSignatureSpan">(reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype.closeOK">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>closeOK
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.channel.prototype.reconnect">
            function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>reconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.createConnection">module amqp.createConnection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.createConnection.createConnection">
            function <span class="apidocSignatureSpan">amqp.</span>createConnection
            <span class="apidocSignatureSpan">(options, implOptions, readyCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.exchange">module amqp.exchange</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.exchange">
            function <span class="apidocSignatureSpan">amqp.</span>exchange
            <span class="apidocSignatureSpan">(connection, channel, name, options, openCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.super_">
            function <span class="apidocSignatureSpan">amqp.exchange.</span>super_
            <span class="apidocSignatureSpan">(connection, channel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.exchange.prototype">module amqp.exchange.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype._awaitConfirm">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_awaitConfirm
            <span class="apidocSignatureSpan">(task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype._confirmSelect">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_confirmSelect
            <span class="apidocSignatureSpan">(channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype._onMethod">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_onMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype._readyToPublishWithConfirms">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_readyToPublishWithConfirms
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.bind">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>bind
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.bind_headers">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>bind_headers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.cleanup">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>cleanup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.destroy">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>destroy
            <span class="apidocSignatureSpan">(ifUnused)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.publish">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>publish
            <span class="apidocSignatureSpan">(routingKey, data, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.exchange.prototype.unbind">
            function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>unbind
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.jspack">module amqp.jspack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.jspack.jspack">
            function <span class="apidocSignatureSpan">amqp.</span>jspack
            <span class="apidocSignatureSpan">(bigEndian)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.message">module amqp.message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.message.message">
            function <span class="apidocSignatureSpan">amqp.</span>message
            <span class="apidocSignatureSpan">(queue, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.message.super_">
            function <span class="apidocSignatureSpan">amqp.message.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.message.prototype">module amqp.message.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.message.prototype.acknowledge">
            function <span class="apidocSignatureSpan">amqp.message.prototype.</span>acknowledge
            <span class="apidocSignatureSpan">(all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.message.prototype.reject">
            function <span class="apidocSignatureSpan">amqp.message.prototype.</span>reject
            <span class="apidocSignatureSpan">(requeue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.parser">module amqp.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.parser">
            function <span class="apidocSignatureSpan">amqp.</span>parser
            <span class="apidocSignatureSpan">(version, type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.parser.prototype">module amqp.parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.prototype._parseHeaderFrame">
            function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>_parseHeaderFrame
            <span class="apidocSignatureSpan">(channel, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.prototype._parseMethodFrame">
            function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>_parseMethodFrame
            <span class="apidocSignatureSpan">(channel, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.prototype.execute">
            function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>execute
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.prototype.setMaxFrameBuffer">
            function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>setMaxFrameBuffer
            <span class="apidocSignatureSpan">(maxFrameBuffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.parser.prototype.throwError">
            function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>throwError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.promise">module amqp.promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.promise.Promise">
            function <span class="apidocSignatureSpan">amqp.promise.</span>Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.queue">module amqp.queue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.queue">
            function <span class="apidocSignatureSpan">amqp.</span>queue
            <span class="apidocSignatureSpan">(connection, channel, name, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.super_">
            function <span class="apidocSignatureSpan">amqp.queue.</span>super_
            <span class="apidocSignatureSpan">(connection, channel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.queue.prototype">module amqp.queue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype._onContent">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onContent
            <span class="apidocSignatureSpan">(channel, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype._onContentHeader">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onContentHeader
            <span class="apidocSignatureSpan">(channel, classInfo, weight, properties, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype._onMethod">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onMethod
            <span class="apidocSignatureSpan">(channel, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.bind">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>bind
            <span class="apidocSignatureSpan">(exchange, routingKey, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.bind_headers">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>bind_headers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.destroy">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>destroy
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.flow">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>flow
            <span class="apidocSignatureSpan">(active)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.purge">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>purge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.shift">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>shift
            <span class="apidocSignatureSpan">(reject, requeue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.subscribe">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(options, messageListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.subscribeJSON">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribeJSON
            <span class="apidocSignatureSpan">(options, messageListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.subscribeRaw">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribeRaw
            <span class="apidocSignatureSpan">(options, messageListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.unbind">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unbind
            <span class="apidocSignatureSpan">(exchange, routingKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.unbind_headers">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unbind_headers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.queue.prototype.unsubscribe">
            function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unsubscribe
            <span class="apidocSignatureSpan">(consumerTag)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amqp.serializer">module amqp.serializer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.getCode">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>getCode
            <span class="apidocSignatureSpan">(dec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.isBigInt">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>isBigInt
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.isFloat">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>isFloat
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeArray">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeArray
            <span class="apidocSignatureSpan">(b, arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeBase64">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeBase64
            <span class="apidocSignatureSpan">(b, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeBuffer">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeBuffer
            <span class="apidocSignatureSpan">(b, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeDate">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeDate
            <span class="apidocSignatureSpan">(b, date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeFields">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeFields
            <span class="apidocSignatureSpan">(buffer, fields, args, strict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeFloat">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeFloat
            <span class="apidocSignatureSpan">(b, size, value, bigEndian)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeInt">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeInt
            <span class="apidocSignatureSpan">(b, size, int)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeLongString">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeLongString
            <span class="apidocSignatureSpan">(b, string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeShortString">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeShortString
            <span class="apidocSignatureSpan">(b, string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeTable">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeTable
            <span class="apidocSignatureSpan">(b, object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amqp.serializer.serializeValue">
            function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeValue
            <span class="apidocSignatureSpan">(b, value)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp" id="apidoc.module.amqp">module amqp</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection" id="apidoc.element.amqp.Connection">
        function <span class="apidocSignatureSpan">amqp.</span>Connection
        <span class="apidocSignatureSpan">(connectionArgs, options, readyCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(connectionArgs, options, readyCallback) {
  EventEmitter.call(this);
  this.setOptions(connectionArgs);
  this.setImplOptions(options);

  if (typeof readyCallback === 'function') {
    this._readyCallback = readyCallback;
  }

  this.connectionAttemptScheduled = false;
  this._defaultExchange = null;
  this.channelCounter = 0;
  this._sendBuffer = new Buffer(maxFrameBuffer);

  this._blocked = false;
  this._blockedReason = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      });
  });
});
```

## Connection

`new amqp.<span class="apidocCodeKeywordSpan">Connection</span>()` Instantiates a new connection. Use
`connection.connect()` to connect to a server.

`amqp.createConnection()` returns an instance of `amqp.Connection`, which contains
an instance of `net.Socket` at its `socket` property. All events and methods which work on
`net.Socket` can also be used on an `amqp.Connection` instance. (e.g., the
events `'connect'` and `'close'`.)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer" id="apidoc.element.amqp.Connection.prototype._bodyToBuffer">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._bodyToBuffer
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._bodyToBuffer = function (body) {
  // Handles 3 cases
  // - body is utf8 string
  // - body is instance of Buffer
  // - body is an object and its JSON representation is sent
  // Does not handle the case for streaming bodies.
  // Returns buffer.
  if (typeof(body) == 'string') {
    return [null, new Buffer(body, 'utf8')];
  } else if (body instanceof Buffer) {
    return [null, body];
  } else {
    var jsonBody = JSON.stringify(body);

    debug &amp;&amp; debug('sending json: ' + jsonBody);

    var props = {contentType: 'application/json'};
    return [props, new Buffer(jsonBody, 'utf8')];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._chooseHost" id="apidoc.element.amqp.Connection.prototype._chooseHost">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._chooseHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._chooseHost = function () {
  if(Array.isArray(this.options.host)){
    if(this.hosti == null){
      if(typeof this.options.hostPreference == 'number') {
        this.hosti = (this.options.hostPreference &lt; this.options.host.length) ?
          this.options.hostPreference : this.options.host.length-1;
      } else {
        this.hosti = parseInt(Math.random() * this.options.host.length, 10);
      }
    } else {
      // If this is already set, it looks like we want to choose another one.
      // Add one to hosti but don't overflow it.
      this.hosti = (this.hosti + 1) % this.options.host.length;
    }
    return this.options.host[this.hosti];
  } else {
    return this.options.host;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._createSocket" id="apidoc.element.amqp.Connection.prototype._createSocket">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._createSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._createSocket = function () {
  var hostName = this._chooseHost(), self = this, port = this.options.port;
  var parsedHost = URL.parse(hostName);
  if(parsedHost.port){
    hostName = parsedHost.hostname;
    port = parsedHost.port;
  }

  var options = {
    port: port,
    host: hostName
  };

  // Disable tcp nagle's algo
  // Default: true, makes small messages faster
  var noDelay = this.options.noDelay || true;

  var resetConnectionTimeout = function () {
    debug &amp;&amp; debug('connected so resetting connection timeout');
    this.setTimeout(0);
  };

  // Connect socket
  if (this.options.ssl.enabled) {
    debug &amp;&amp; debug('making ssl connection');
    options = _.assignIn(options, this._getSSLOptions());
    this.socket = tls.connect(options, resetConnectionTimeout);
  } else {
    debug &amp;&amp; debug('making non-ssl connection');
    this.socket = net.connect(options, resetConnectionTimeout);
  }
  var connTimeout = this.options.connectionTimeout;
  if (connTimeout) {
    debug &amp;&amp; debug('setting connection timeout to ' + connTimeout);
    this.socket.setTimeout(connTimeout, function () {
      debug &amp;&amp; debug('connection timeout');
      this.destroy();
      var e = new Error('connection timeout');
      e.name = 'TimeoutError';
      self.emit('error', e);
    });
  }

  this.socket.setNoDelay(noDelay);

  // Proxy events.
  // Note that if we don't attach a 'data' event, no data will flow.
  var events = ['close', 'connect', 'data', 'drain', 'error', 'end', 'secureConnect', 'timeout'];
  _.forEach(events, function(event){
    self.socket.on(event, self.emit.bind(self, event));
  });

  // Proxy a few methods that we use / previously used.
  var methods = ['destroy', 'write', 'pause', 'resume', 'setEncoding', 'ref', 'unref', 'address'];
  _.forEach(methods, function(method){
    self[method] = function(){
      self.socket[method].apply(self.socket, arguments);
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._getSSLOptions" id="apidoc.element.amqp.Connection.prototype._getSSLOptions">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._getSSLOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._getSSLOptions = function () {
  if (this.sslConnectionOptions) return this.sslConnectionOptions;
  this.sslConnectionOptions = {};

  if (this.options.ssl.pfxFile) {
    this.sslConnectionOptions.pfx = fs.readFileSync(this.options.ssl.pfxFile);
  }
  if (this.options.ssl.keyFile) {
    this.sslConnectionOptions.key = fs.readFileSync(this.options.ssl.keyFile);
  }
  if (this.options.ssl.certFile) {
    this.sslConnectionOptions.cert = fs.readFileSync(this.options.ssl.certFile);
  }
  if (this.options.ssl.caFile) {
    if (Array.isArray(this.options.ssl.caFile)) {
      this.sslConnectionOptions.ca = this.options.ssl.caFile.map(function(f){
        return fs.readFileSync(f);
      });
    } else {
      this.sslConnectionOptions.ca = fs.readFileSync(this.options.ssl.caFile);
    }
  }

  this.sslConnectionOptions.rejectUnauthorized = this.options.ssl.rejectUnauthorized;
  this.sslConnectionOptions.passphrase = this.options.ssl.passphrase;

  return this.sslConnectionOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._inboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._inboundHeartbeatTimerReset = function () {
  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }
  if (this.options.heartbeat) {
    var self = this;
    var gracePeriod = 2 * this.options.heartbeat;
    this._inboundHeartbeatTimer = setTimeout(function () {
      if(self.socket.readable || self.options.heartbeatForceReconnect){
        self.emit('error', new Error('no heartbeat or data in last ' + gracePeriod + ' seconds'));
      }
    }, gracePeriod * 1000);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._onMethod" id="apidoc.element.amqp.Connection.prototype._onMethod">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._onMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._onMethod = function (channel, method, args) {
  debug &amp;&amp; debug(channel + " &gt; " + method.name + " " + JSON.stringify(args));

  // Channel 0 is the control channel. If not zero then delegate to
  // one of the channel objects.

  if (channel &gt; 0) {
    if (!this.channels[channel]) {
      debug &amp;&amp; debug("Received message on untracked channel.");
      return;
    }
    if (!this.channels[channel]._onChannelMethod) {
      throw new Error('Channel ' + channel + ' has no _onChannelMethod method.');
    }
    this.channels[channel]._onChannelMethod(channel, method, args);
    return;
  }

  // channel 0

  switch (method) {
    // 2. The server responds, after the version string, with the
    // 'connectionStart' method (contains various useless information)
    case methods.connectionStart:
      // We check that they're serving us AMQP 0-9
      if (args.versionMajor !== 0 &amp;&amp; args.versionMinor != 9) {
        this.socket.end();
        this.emit('error', new Error("Bad server version"));
        return;
      }
      this.serverProperties = args.serverProperties;
      // 3. Then we reply with StartOk, containing our useless information.
      this._sendMethod(0, methods.connectionStartOk, {
        clientProperties: this.options.clientProperties,
        mechanism: this.options.authMechanism,
        response: this._saslResponse(),
        locale: 'en_US'
      });
      break;

    // 4. The server responds with a connectionTune request
    case methods.connectionTune:
      if (args.frameMax) {
          debug &amp;&amp; debug("tweaking maxFrameBuffer to " + args.frameMax);
          maxFrameBuffer = args.frameMax;
          this._sendBuffer = new Buffer(maxFrameBuffer);
          this.parser.setMaxFrameBuffer(maxFrameBuffer);
      }
      if (args.channelMax) {
          debug &amp;&amp; debug("tweaking channelMax to " + args.channelMax);
          channelMax = args.channelMax;
      }
      // 5. We respond with connectionTuneOk
      this._sendMethod(0, methods.connectionTuneOk, {
        channelMax: channelMax,
        frameMax: maxFrameBuffer,
        heartbeat: this.options.heartbeat || 0
      });
      // 6. Then we have to send a connectionOpen request
      this._sendMethod(0, methods.connectionOpen, {
        virtualHost: this.options.vhost
        // , capabilities: ''
        // , insist: true
        ,
        reserved1: '',
        reserved2: true
      });
      break;


    case methods.connectionOpenOk:
      // 7. Finally they respond with connectionOpenOk
      // Whew! That's why they call it the Advanced MQP.
      if (this._readyCallback) {
        this._readyCallback(this);
        this._readyCallback = null;
      }
      this.emit('ready');
      break;

    case methods.connectionClose:
      var e = new Error(args.replyText);
      e.code = args.replyCode;
      if (!this.listeners('close').length) {
        console.log('Unhandled connection error: ' + args.replyText);
      }
      this.socket.destroy(e);
      break;

    case methods.connectionCloseOk:
      debug &amp;&amp; debug("Received close-ok from server, closing socket");
      this.socket.end();
      break;

    case methods.connectionBlocked:
      debug &amp;&amp; debug('Received connection.blocked from server with reason: ' + args.reason);
      this._blocked = true;
      this._blockedReason = args.reason;
      this.emit('blocked');
      break;

    case methods.connectionUnblocked:
      debug &amp;&amp; debug('Received connection.unblocked from server');
      this._blocked = false;
      this._blockedReason = null;
      this.emit('unblocked');
      break;

    default:
      throw new Error("Uncaught method '" + method.name + "' with args " +
          JSON.stringify(args));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._outboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._outboundHeartbeatTimerReset = function () {
  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
  if (this.socket.writable &amp;&amp; this.options.heartbeat) {
    var self = this;
    this._outboundHeartbeatTimer = setTimeout(function () {
      self.heartbeat();
      self._outboundHeartbeatTimerReset();
    }, 1000 * this.options.heartbeat);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._parseURLOptions" id="apidoc.element.amqp.Connection.prototype._parseURLOptions">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._parseURLOptions
        <span class="apidocSignatureSpan">(connectionString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._parseURLOptions = function (connectionString) {
  var opts = {};
  opts.ssl = {};
  var url = URL.parse(connectionString);
  var scheme = url.protocol.substring(0, url.protocol.lastIndexOf(':'));
  if (scheme != 'amqp' &amp;&amp; scheme != 'amqps') {
    throw new Error('Connection URI must use amqp or amqps scheme. ' +
                    'For example, "amqp://bus.megacorp.internal:5766".');
  }
  opts.ssl.enabled = ('amqps' === scheme);
  opts.host = url.hostname;
  opts.port = url.port || defaultPorts[scheme];
  if (url.auth) {
    var auth = url.auth.split(':');
    auth[0] &amp;&amp; (opts.login = auth[0]);
    auth[1] &amp;&amp; (opts.password = auth[1]);
  }
  if (url.pathname) {
    opts.vhost = unescape(url.pathname.substr(1));
  }
  return opts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._saslResponse" id="apidoc.element.amqp.Connection.prototype._saslResponse">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._saslResponse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._saslResponse = function () {
  var response;
  if (this.options.authMechanism == 'AMQPLAIN')
    response = {
      LOGIN: this.options.login,
      PASSWORD: this.options.password
    };
  else if (this.options.authMechanism == 'PLAIN')
    response = "\0" + this.options.login + "\0" + this.options.password;
  else if (this.options.authMechanism == 'EXTERNAL')
    response = "\0";
  else if (this.options.authMechanism == 'ANONYMOUS')
    response = "\0";
  else
    response = this.options.response;

  return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendBody" id="apidoc.element.amqp.Connection.prototype._sendBody">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendBody
        <span class="apidocSignatureSpan">(channel, body, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._sendBody = function (channel, body, properties) {
  var r = this._bodyToBuffer(body);
  var props = r[0], buffer = r[1];

  properties = _.assignIn(props || {}, properties);

  this._sendHeader(channel, buffer.length, properties);

  var pos = 0, len = buffer.length;
  var metaSize = 8; // headerBytes = 7, frameEndBytes = 1
  var maxBodySize = maxFrameBuffer - metaSize;

  while (len &gt; 0) {
    var bodySize = len &lt; maxBodySize ? len : maxBodySize;
    var frameSize = bodySize + metaSize;

    var b = new Buffer(frameSize);
    b.used = 0;
    b[b.used++] = 3; // constants.frameBody
    serializer.serializeInt(b, 2, channel);
    serializer.serializeInt(b, 4, bodySize);
    buffer.copy(b, b.used, pos, pos+bodySize);
    b.used += bodySize;
    b[b.used++] = 206; // constants.frameEnd;
    this.write(b);

    len -= bodySize;
    pos += bodySize;
  }
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendHeader" id="apidoc.element.amqp.Connection.prototype._sendHeader">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendHeader
        <span class="apidocSignatureSpan">(channel, size, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._sendHeader = function (channel, size, properties) {
  var b = new Buffer(maxFrameBuffer); // FIXME allocating too much.
                                      // use freelist?
  b.used = 0;

  var classInfo = classes[60]; // always basic class.

  // 7 OCTET FRAME HEADER

  b[b.used++] = 2; // constants.frameHeader

  serializer.serializeInt(b, 2, channel);

  var lengthStart = b.used;

  serializer.serializeInt(b, 4, 0 /*dummy*/); // length

  var bodyStart = b.used;

  // HEADER'S BODY

  serializer.serializeInt(b, 2, classInfo.index);   // class 60 for Basic
  serializer.serializeInt(b, 2, 0);                 // weight, always 0 for rabbitmq
  serializer.serializeInt(b, 8, size);              // byte size of body

  // properties - first propertyFlags
  properties = _.defaults(properties || {}, {contentType: 'application/octet-stream'});
  var propertyFlags = 0;
  for (var i = 0; i &lt; classInfo.fields.length; i++) {
    if (properties[classInfo.fields[i].name]) propertyFlags |= 1 &lt;&lt; (15-i);
  }
  serializer.serializeInt(b, 2, propertyFlags);
  // now the actual properties.
  serializer.serializeFields(b, classInfo.fields, properties, false);

  //serializeTable(b, properties);

  var bodyEnd = b.used;

  // Go back to the header and write in the length now that we know it.
  b.used = lengthStart;
  serializer.serializeInt(b, 4, bodyEnd - bodyStart);
  b.used = bodyEnd;

  // 1 OCTET END

  b[b.used++] = 206; // constants.frameEnd;

  var s = new Buffer(b.used);
  b.copy(s);

  //debug &amp;&amp; debug('header sent: ' + JSON.stringify(s));

  this.write(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendMethod" id="apidoc.element.amqp.Connection.prototype._sendMethod">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._sendMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._sendMethod = function (channel, method, args) {
  debug &amp;&amp; debug(channel + " &lt; " + method.name + " " + JSON.stringify(args));
  var b = this._sendBuffer;
  b.used = 0;

  b[b.used++] = 1; // constants.frameMethod

  serializer.serializeInt(b, 2, channel);

  var lengthIndex = b.used;

  serializer.serializeInt(b, 4, 42); // replace with actual length.

  var startIndex = b.used;


  serializer.serializeInt(b, 2, method.classIndex); // short, classId
  serializer.serializeInt(b, 2, method.methodIndex); // short, methodId

  serializer.serializeFields(b, method.fields, args, true);

  var endIndex = b.used;

  // write in the frame length now that we know it.
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;

  b[b.used++] = 206; // constants.frameEnd;

  var c = new Buffer(b.used);
  b.copy(c);

  debug &amp;&amp; debug("sending frame: " + c.toJSON());

  this.write(c);

  this._outboundHeartbeatTimerReset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._startHandshake" id="apidoc.element.amqp.Connection.prototype._startHandshake">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype._startHandshake
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype._startHandshake = function () {
  debug &amp;&amp; debug("Initiating handshake...");
  this.write("AMQP" + String.fromCharCode(0,0,9,1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.addAllListeners" id="apidoc.element.amqp.Connection.prototype.addAllListeners">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.addAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.addAllListeners = function () {
  var self = this;
  var connectEvent = this.options.ssl.enabled ? 'secureConnect' : 'connect';


  self.addListener(connectEvent, function() {
    // In the case where this is a reconnection, do not trample on the existing
    // channels.
    // For your reference, channel 0 is the control channel.
    self.channels = self.channels || {0:self};
    self.queues = self.queues || {};
    self.exchanges = self.exchanges || {};

    self.parser = new AMQPParser('0-9-1', 'client');

    self.parser.onMethod = function (channel, method, args) {
      self._onMethod(channel, method, args);
    };

    self.parser.onContent = function (channel, data) {
      debug &amp;&amp; debug(channel + " &gt; content " + data.length);
      if (self.channels[channel] &amp;&amp; self.channels[channel]._onContent) {
        self.channels[channel]._onContent(channel, data);
      } else {
        debug &amp;&amp; debug("unhandled content: " + data);
      }
    };

    self.parser.onContentHeader = function (channel, classInfo, weight, properties, size) {
      debug &amp;&amp; debug(channel + " &gt; content header " + JSON.stringify([classInfo.name, weight, properties, size]));
      if (self.channels[channel] &amp;&amp; self.channels[channel]._onContentHeader) {
        self.channels[channel]._onContentHeader(channel, classInfo, weight, properties, size);
      } else {
        debug &amp;&amp; debug("unhandled content header");
      }
    };

    self.parser.onHeartBeat = function () {
      self.emit("heartbeat");
      debug &amp;&amp; debug("heartbeat");
    };

    self.parser.onError = function (e) {
      self.emit("error", e);
      self.emit("close");
    };

    // Remove readyEmitted flag so we can detect an auth error.
    self.readyEmitted = false;
  });

  self.addListener('data', function (data) {
    if(self.parser != null){
      try {
        self.parser.execute(data);
      } catch (exception) {
        self.emit('error', exception);
        return;
      }
    }
    self._inboundHeartbeatTimerReset();
  });

  var backoffTime = null;
  self.addListener('error', function backoff(e) {
    if (self._inboundHeartbeatTimer !== null) {
      clearTimeout(self._inboundHeartbeatTimer);
      self._inboundHeartbeatTimer = null;
    }
    if (self._outboundHeartbeatTimer !== null) {
      clearTimeout(self._outboundHeartbeatTimer);
      self._outboundHeartbeatTimer = null;
    }

    if (!self.connectionAttemptScheduled) {
      // Set to true, as we are presently in the process of scheduling one.
      self.connectionAttemptScheduled = true;

      // Kill the socket, if it hasn't been killed already.
      self.socket.end();

      // Reset parser state
      self.parser = null;

      // In order for our reconnection to be seamless, we have to notify the
      // channels that they are no longer connected so that nobody attempts
      // to send messages which would be doomed to fail.
      for (var channel in self.channels) {
        if (channel !== '0') {
          self.channels[channel].state = 'closed';
        }
      }
      // Queues are channels (so we have already marked them as closed), but
      // queues have special needs, since the subscriptions will no longer
      // be known to the server when we reconnect.  Mark the subscriptions as
      // closed so that we can resubscribe them once we are reconnected.
      for (var queue in self.queues) {
        for (var index in self.queues[queue].consumerTagOptions) {
          self.queues[queue].consumerTagOptions[index]['state'] = 'closed';
        }
      }

      // Begin reconnection attempts
      if (self.implOptions.reconnect) {
        // Don't thrash, use a backoff strategy.
        if (backoffTime === null) {
          // This is the first time we've failed since a successful connection,
          // so use the configured backoff time without any modification.
          backoffTime = self.implOptions.reconnectBackoffTime;
        } else if (self.implOptions.reconnectBackoffStrategy === 'exponential') {
          // If you've configured exponential backoff, we'll double the
          // backoff time each ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.connect" id="apidoc.element.amqp.Connection.prototype.connect">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.connect = function () {
  // If this is our first connection, add listeners.
  if (!this.socket) this.addAllListeners();

  this._createSocket();
  this._startHandshake();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.disconnect" id="apidoc.element.amqp.Connection.prototype.disconnect">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.disconnect = function () {
  debug &amp;&amp; debug("Sending disconnect request to server");
  this._sendMethod(0, methods.connectionClose, {
    'replyText': 'client disconnect',
    'replyCode': 200,
    'classId': 0,
    'methodId': 0
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.end" id="apidoc.element.amqp.Connection.prototype.end">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.end = function () {
  if (this.socket) {
    this.socket.end();
  }

  this.options.heartbeat = false;

  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }

  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchange" id="apidoc.element.amqp.Connection.prototype.exchange">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.exchange
        <span class="apidocSignatureSpan">(name, options, openCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.exchange = function (name, options, openCallback) {
  if (name === undefined) name = this.implOptions.defaultExchangeName;

  if (!options) options = {};
  if (name !== '' &amp;&amp; options.type === undefined) options.type = 'topic';

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit("error", exception);
    return;
  }
  var exchange = new Exchange(this, channel, name, options, openCallback);
  this.channels[channel] = exchange;
  this.exchanges[name] = exchange;
  return exchange;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchangeClosed" id="apidoc.element.amqp.Connection.prototype.exchangeClosed">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.exchangeClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.exchangeClosed = function (name) {
  if (this.exchanges[name]) delete this.exchanges[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.generateChannelId" id="apidoc.element.amqp.Connection.prototype.generateChannelId">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.generateChannelId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.generateChannelId = function () {
  // start from the last used slot id
  var channelId = this.channelCounter;
  while(true){
    // use values in range of 1..65535
    channelId = channelId % channelMax + 1;
    if(!this.channels[channelId]){
      break;
    }
    // after a full loop throw an Error
    if(channelId == this.channelCounter){
      throw new Error("No valid Channel Id values available");
    }
  }
  this.channelCounter = channelId;
  return this.channelCounter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.heartbeat" id="apidoc.element.amqp.Connection.prototype.heartbeat">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.heartbeat = function () {
  if(this.socket.writable) this.write(new Buffer([8,0,0,0,0,0,0,206]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.publish" id="apidoc.element.amqp.Connection.prototype.publish">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.publish
        <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.publish = function (routingKey, body, options, callback) {
  if (!this._defaultExchange) {
    this._defaultExchange = this.exchange();
  }

  var exchange = this._defaultExchange;
  if (exchange.state === 'open') {
    exchange.publish(routingKey, body, options, callback);
  } else {
    exchange.once('open', function() {
      exchange.publish(routingKey, body, options, callback);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queue" id="apidoc.element.amqp.Connection.prototype.queue">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.queue
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.queue = function (name) {
  var options, callback;
  if (typeof arguments[1] == 'object') {
    options = arguments[1];
    callback = arguments[2];
  } else {
    callback = arguments[1];
  }

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit("error", exception);
    return;
  }

  var q = new Queue(this, channel, name, options, callback);
  this.channels[channel] = q;
  return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queueClosed" id="apidoc.element.amqp.Connection.prototype.queueClosed">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.queueClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.queueClosed = function (name) {
  if (this.queues[name]) delete this.queues[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.reconnect" id="apidoc.element.amqp.Connection.prototype.reconnect">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.reconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.reconnect = function () {
  // Suspend activity on channels
  for (var channel in this.channels) {
    this.channels[channel].state = 'closed';
  }
  debug &amp;&amp; debug("Connection lost, reconnecting...");
  // Terminate socket activity
  if (this.socket) this.socket.end();
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setImplOptions" id="apidoc.element.amqp.Connection.prototype.setImplOptions">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.setImplOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.setImplOptions = function (options) {
  this.implOptions = _.assignIn({}, defaultImplOptions, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setOptions" id="apidoc.element.amqp.Connection.prototype.setOptions">
        function <span class="apidocSignatureSpan">amqp.</span>Connection.prototype.setOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection.prototype.setOptions = function (options) {
  var urlo = (options &amp;&amp; options.url) ? this._parseURLOptions(options.url) : {};
  var sslo = (options &amp;&amp; options.ssl &amp;&amp; options.ssl.enabled) ? defaultSslOptions : {};
  this.options = _.assignIn({}, defaultOptions, sslo, urlo, options || {});
  this.options.clientProperties =  _.assignIn({}, defaultClientProperties, (options &amp;&amp; options.clientProperties) || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel" id="apidoc.element.amqp.channel">
        function <span class="apidocSignatureSpan">amqp.</span>channel
        <span class="apidocSignatureSpan">(connection, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Channel(connection, channel) {
  events.EventEmitter.call(this);

  // Unlimited listeners. Helps when e.g. publishing high-volume messages,
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.reconnect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.createConnection" id="apidoc.element.amqp.createConnection">
        function <span class="apidocSignatureSpan">amqp.</span>createConnection
        <span class="apidocSignatureSpan">(options, implOptions, readyCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createConnection = function (options, implOptions, readyCallback) {
  var c = new Connection(options, implOptions, readyCallback);
  c.connect();
  return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
IMPORTANT: This module only works with node v0.4.0 and later.

An example of connecting to a server and listening on a queue.

```javascript
var amqp = require('amqp');

var connection = amqp.<span class="apidocCodeKeywordSpan">createConnection</span>({ host: 'dev.rabbitmq.com' });

// add this for better debuging
connection.on('error', function(e) {
  console.log("Error from amqp: ", e);
});

// Wait for connection to become established.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange" id="apidoc.element.amqp.exchange">
        function <span class="apidocSignatureSpan">amqp.</span>exchange
        <span class="apidocSignatureSpan">(connection, channel, name, options, openCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Exchange(connection, channel, name, options, openCallback) {
  Channel.call(this, connection, channel);
  this.name = name;
  this.binds = 0; // keep track of queues bound
  this.exchangeBinds = 0; // keep track of exchanges bound
  this.sourceExchanges = {};
  this.options = _.defaults(options || {}, {autoDelete: true});
  this._openCallback = openCallback;

  this._sequence = null;
  this._unAcked  = {};
  this._addedExchangeErrorHandler = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.<span class="apidocCodeKeywordSpan">exchange</span>()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
- [exchange.unbind(srcExchange, routingKey [, callback])](#exchangeunbindsrcexchange-routingkey--callback)
- [exchange.bind_headers(exchange, routing [, bindCallback])](#exchangebind_headersexchange-routing--bindcallback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.message" id="apidoc.element.amqp.message">
        function <span class="apidocSignatureSpan">amqp.</span>message
        <span class="apidocSignatureSpan">(queue, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(queue, args) {
  var msgProperties = definitions.classes[60].fields;

  events.EventEmitter.call(this);

  this.queue = queue;

  this.deliveryTag = args.deliveryTag;
  this.redelivered = args.redelivered;
  this.exchange    = args.exchange;
  this.routingKey  = args.routingKey;
  this.consumerTag = args.consumerTag;

  for (var i=0, l=msgProperties.length; i&lt;l; i++) {
    if (args[msgProperties[i].name]) {
      this[msgProperties[i].name] = args[msgProperties[i].name];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.parser" id="apidoc.element.amqp.parser">
        function <span class="apidocSignatureSpan">amqp.</span>parser
        <span class="apidocSignatureSpan">(version, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AMQPParser(version, type) {
  this.isClient = (type == 'client');
  this.state = this.isClient ? 'frameHeader' : 'protocolHeader';
  this.maxFrameBuffer = MAX_FRAME_BUFFER_DEFAULT;

  if (version != '0-9-1') this.throwError("Unsupported protocol version");

  var frameHeader = new Buffer(7);
  frameHeader.used = 0;
  var frameBuffer, frameType, frameChannel;

  var self = this;

  function header(data) {
    var fh = frameHeader;
    var needed = fh.length - fh.used;
    data.copy(fh, fh.used, 0, data.length);
    fh.used += data.length; // sloppy
    if (fh.used &gt;= fh.length) {
      fh.read = 0;
      frameType = fh[fh.read++];
      frameChannel = parseInt(fh, 2);
      var frameSize = parseInt(fh, 4);
      fh.used = 0; // for reuse
      if (frameSize &gt; self.maxFrameBuffer) {
        self.throwError("Oversized frame " + frameSize);
      }
      frameBuffer = new Buffer(frameSize);
      frameBuffer.used = 0;
      return frame(data.slice(needed));
    }
    else { // need more!
      return header;
    }
  }

  function frame(data) {
    var fb = frameBuffer;
    var needed = fb.length - fb.used;
    var sourceEnd = (fb.length &gt; data.length) ? data.length : fb.length;
    data.copy(fb, fb.used, 0, sourceEnd);
    fb.used += data.length;
    if (data.length &gt; needed) {
      return frameEnd(data.slice(needed));
    }
    else if (data.length == needed) {
      return frameEnd;
    }
    else {
      return frame;
    }
  }

  function frameEnd(data) {
    if (data.length &gt; 0) {
      if (data[0] === Indicators.FRAME_END) {
        switch (frameType) {
        case FrameType.METHOD:
          self._parseMethodFrame(frameChannel, frameBuffer);
          break;
        case FrameType.HEADER:
          self._parseHeaderFrame(frameChannel, frameBuffer);
          break;
        case FrameType.BODY:
          if (self.onContent) {
            self.onContent(frameChannel, frameBuffer);
          }
          break;
        case FrameType.HEARTBEAT:
          debug &amp;&amp; debug("heartbeat");
          if (self.onHeartBeat) self.onHeartBeat();
          break;
        default:
          self.throwError("Unhandled frame type " + frameType);
          break;
        }
        return header(data.slice(1));
      }
      else {
        self.throwError("Missing frame end marker");
      }
    }
    else {
      return frameEnd;
    }
  }

  self.parse = header;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue" id="apidoc.element.amqp.queue">
        function <span class="apidocSignatureSpan">amqp.</span>queue
        <span class="apidocSignatureSpan">(connection, channel, name, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue(connection, channel, name, options, callback) {
  Channel.call(this, connection, channel);

  var self = this;
  this.name = name;
  this._bindings = {};
  this.consumerTagListeners = {};
  this.consumerTagOptions = {};

  // route messages to subscribers based on consumerTag
  this.on('rawMessage', function(message) {
    if (message.consumerTag &amp;&amp; self.consumerTagListeners[message.consumerTag]) {
      self.consumerTagListeners[message.consumerTag](message);
    }
  });

  this.options = { autoDelete: true, closeChannelOnUnsubscribe: false };
  _.assignIn(this.options, options || {});

  this._openCallback = callback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.<span class="apidocCodeKeywordSpan">queue</span>(name[, options][, openCallback])](#connectionqueuename-options-opencallback
)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection" id="apidoc.module.amqp.Connection">module amqp.Connection</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.Connection" id="apidoc.element.amqp.Connection.Connection">
        function <span class="apidocSignatureSpan">amqp.</span>Connection
        <span class="apidocSignatureSpan">(connectionArgs, options, readyCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(connectionArgs, options, readyCallback) {
  EventEmitter.call(this);
  this.setOptions(connectionArgs);
  this.setImplOptions(options);

  if (typeof readyCallback === 'function') {
    this._readyCallback = readyCallback;
  }

  this.connectionAttemptScheduled = false;
  this._defaultExchange = null;
  this.channelCounter = 0;
  this._sendBuffer = new Buffer(maxFrameBuffer);

  this._blocked = false;
  this._blockedReason = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      });
  });
});
```

## Connection

`new amqp.<span class="apidocCodeKeywordSpan">Connection</span>()` Instantiates a new connection. Use
`connection.connect()` to connect to a server.

`amqp.createConnection()` returns an instance of `amqp.Connection`, which contains
an instance of `net.Socket` at its `socket` property. All events and methods which work on
`net.Socket` can also be used on an `amqp.Connection` instance. (e.g., the
events `'connect'` and `'close'`.)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.super_" id="apidoc.element.amqp.Connection.super_">
        function <span class="apidocSignatureSpan">amqp.Connection.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype" id="apidoc.module.amqp.Connection.prototype">module amqp.Connection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer" id="apidoc.element.amqp.Connection.prototype._bodyToBuffer">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_bodyToBuffer
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_bodyToBuffer = function (body) {
  // Handles 3 cases
  // - body is utf8 string
  // - body is instance of Buffer
  // - body is an object and its JSON representation is sent
  // Does not handle the case for streaming bodies.
  // Returns buffer.
  if (typeof(body) == 'string') {
    return [null, new Buffer(body, 'utf8')];
  } else if (body instanceof Buffer) {
    return [null, body];
  } else {
    var jsonBody = JSON.stringify(body);

    debug &amp;&amp; debug('sending json: ' + jsonBody);

    var props = {contentType: 'application/json'};
    return [props, new Buffer(jsonBody, 'utf8')];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._chooseHost" id="apidoc.element.amqp.Connection.prototype._chooseHost">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_chooseHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_chooseHost = function () {
  if(Array.isArray(this.options.host)){
    if(this.hosti == null){
      if(typeof this.options.hostPreference == 'number') {
        this.hosti = (this.options.hostPreference &lt; this.options.host.length) ?
          this.options.hostPreference : this.options.host.length-1;
      } else {
        this.hosti = parseInt(Math.random() * this.options.host.length, 10);
      }
    } else {
      // If this is already set, it looks like we want to choose another one.
      // Add one to hosti but don't overflow it.
      this.hosti = (this.hosti + 1) % this.options.host.length;
    }
    return this.options.host[this.hosti];
  } else {
    return this.options.host;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._createSocket" id="apidoc.element.amqp.Connection.prototype._createSocket">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_createSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createSocket = function () {
  var hostName = this._chooseHost(), self = this, port = this.options.port;
  var parsedHost = URL.parse(hostName);
  if(parsedHost.port){
    hostName = parsedHost.hostname;
    port = parsedHost.port;
  }

  var options = {
    port: port,
    host: hostName
  };

  // Disable tcp nagle's algo
  // Default: true, makes small messages faster
  var noDelay = this.options.noDelay || true;

  var resetConnectionTimeout = function () {
    debug &amp;&amp; debug('connected so resetting connection timeout');
    this.setTimeout(0);
  };

  // Connect socket
  if (this.options.ssl.enabled) {
    debug &amp;&amp; debug('making ssl connection');
    options = _.assignIn(options, this._getSSLOptions());
    this.socket = tls.connect(options, resetConnectionTimeout);
  } else {
    debug &amp;&amp; debug('making non-ssl connection');
    this.socket = net.connect(options, resetConnectionTimeout);
  }
  var connTimeout = this.options.connectionTimeout;
  if (connTimeout) {
    debug &amp;&amp; debug('setting connection timeout to ' + connTimeout);
    this.socket.setTimeout(connTimeout, function () {
      debug &amp;&amp; debug('connection timeout');
      this.destroy();
      var e = new Error('connection timeout');
      e.name = 'TimeoutError';
      self.emit('error', e);
    });
  }

  this.socket.setNoDelay(noDelay);

  // Proxy events.
  // Note that if we don't attach a 'data' event, no data will flow.
  var events = ['close', 'connect', 'data', 'drain', 'error', 'end', 'secureConnect', 'timeout'];
  _.forEach(events, function(event){
    self.socket.on(event, self.emit.bind(self, event));
  });

  // Proxy a few methods that we use / previously used.
  var methods = ['destroy', 'write', 'pause', 'resume', 'setEncoding', 'ref', 'unref', 'address'];
  _.forEach(methods, function(method){
    self[method] = function(){
      self.socket[method].apply(self.socket, arguments);
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._getSSLOptions" id="apidoc.element.amqp.Connection.prototype._getSSLOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_getSSLOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSSLOptions = function () {
  if (this.sslConnectionOptions) return this.sslConnectionOptions;
  this.sslConnectionOptions = {};

  if (this.options.ssl.pfxFile) {
    this.sslConnectionOptions.pfx = fs.readFileSync(this.options.ssl.pfxFile);
  }
  if (this.options.ssl.keyFile) {
    this.sslConnectionOptions.key = fs.readFileSync(this.options.ssl.keyFile);
  }
  if (this.options.ssl.certFile) {
    this.sslConnectionOptions.cert = fs.readFileSync(this.options.ssl.certFile);
  }
  if (this.options.ssl.caFile) {
    if (Array.isArray(this.options.ssl.caFile)) {
      this.sslConnectionOptions.ca = this.options.ssl.caFile.map(function(f){
        return fs.readFileSync(f);
      });
    } else {
      this.sslConnectionOptions.ca = fs.readFileSync(this.options.ssl.caFile);
    }
  }

  this.sslConnectionOptions.rejectUnauthorized = this.options.ssl.rejectUnauthorized;
  this.sslConnectionOptions.passphrase = this.options.ssl.passphrase;

  return this.sslConnectionOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_inboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_inboundHeartbeatTimerReset = function () {
  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }
  if (this.options.heartbeat) {
    var self = this;
    var gracePeriod = 2 * this.options.heartbeat;
    this._inboundHeartbeatTimer = setTimeout(function () {
      if(self.socket.readable || self.options.heartbeatForceReconnect){
        self.emit('error', new Error('no heartbeat or data in last ' + gracePeriod + ' seconds'));
      }
    }, gracePeriod * 1000);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._onMethod" id="apidoc.element.amqp.Connection.prototype._onMethod">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_onMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onMethod = function (channel, method, args) {
  debug &amp;&amp; debug(channel + " &gt; " + method.name + " " + JSON.stringify(args));

  // Channel 0 is the control channel. If not zero then delegate to
  // one of the channel objects.

  if (channel &gt; 0) {
    if (!this.channels[channel]) {
      debug &amp;&amp; debug("Received message on untracked channel.");
      return;
    }
    if (!this.channels[channel]._onChannelMethod) {
      throw new Error('Channel ' + channel + ' has no _onChannelMethod method.');
    }
    this.channels[channel]._onChannelMethod(channel, method, args);
    return;
  }

  // channel 0

  switch (method) {
    // 2. The server responds, after the version string, with the
    // 'connectionStart' method (contains various useless information)
    case methods.connectionStart:
      // We check that they're serving us AMQP 0-9
      if (args.versionMajor !== 0 &amp;&amp; args.versionMinor != 9) {
        this.socket.end();
        this.emit('error', new Error("Bad server version"));
        return;
      }
      this.serverProperties = args.serverProperties;
      // 3. Then we reply with StartOk, containing our useless information.
      this._sendMethod(0, methods.connectionStartOk, {
        clientProperties: this.options.clientProperties,
        mechanism: this.options.authMechanism,
        response: this._saslResponse(),
        locale: 'en_US'
      });
      break;

    // 4. The server responds with a connectionTune request
    case methods.connectionTune:
      if (args.frameMax) {
          debug &amp;&amp; debug("tweaking maxFrameBuffer to " + args.frameMax);
          maxFrameBuffer = args.frameMax;
          this._sendBuffer = new Buffer(maxFrameBuffer);
          this.parser.setMaxFrameBuffer(maxFrameBuffer);
      }
      if (args.channelMax) {
          debug &amp;&amp; debug("tweaking channelMax to " + args.channelMax);
          channelMax = args.channelMax;
      }
      // 5. We respond with connectionTuneOk
      this._sendMethod(0, methods.connectionTuneOk, {
        channelMax: channelMax,
        frameMax: maxFrameBuffer,
        heartbeat: this.options.heartbeat || 0
      });
      // 6. Then we have to send a connectionOpen request
      this._sendMethod(0, methods.connectionOpen, {
        virtualHost: this.options.vhost
        // , capabilities: ''
        // , insist: true
        ,
        reserved1: '',
        reserved2: true
      });
      break;


    case methods.connectionOpenOk:
      // 7. Finally they respond with connectionOpenOk
      // Whew! That's why they call it the Advanced MQP.
      if (this._readyCallback) {
        this._readyCallback(this);
        this._readyCallback = null;
      }
      this.emit('ready');
      break;

    case methods.connectionClose:
      var e = new Error(args.replyText);
      e.code = args.replyCode;
      if (!this.listeners('close').length) {
        console.log('Unhandled connection error: ' + args.replyText);
      }
      this.socket.destroy(e);
      break;

    case methods.connectionCloseOk:
      debug &amp;&amp; debug("Received close-ok from server, closing socket");
      this.socket.end();
      break;

    case methods.connectionBlocked:
      debug &amp;&amp; debug('Received connection.blocked from server with reason: ' + args.reason);
      this._blocked = true;
      this._blockedReason = args.reason;
      this.emit('blocked');
      break;

    case methods.connectionUnblocked:
      debug &amp;&amp; debug('Received connection.unblocked from server');
      this._blocked = false;
      this._blockedReason = null;
      this.emit('unblocked');
      break;

    default:
      throw new Error("Uncaught method '" + method.name + "' with args " +
          JSON.stringify(args));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Channel.prototype._onChannelMethod = function(channel, method, args) {
switch (method) {
  case methods.channelCloseOk:
    delete this.connection.channels[this.channel];
    this.state = 'closed';
    // TODO should this be falling through?
  default:
    this.<span class="apidocCodeKeywordSpan">_onMethod</span>(channel, method, args);
}
};

Channel.prototype.close = function(reason) {
this.state = 'closing';
this.connection._sendMethod(this.channel, methods.channelClose,
                            {'replyText': reason ? reason : 'Goodbye from node',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_outboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_outboundHeartbeatTimerReset = function () {
  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
  if (this.socket.writable &amp;&amp; this.options.heartbeat) {
    var self = this;
    this._outboundHeartbeatTimer = setTimeout(function () {
      self.heartbeat();
      self._outboundHeartbeatTimerReset();
    }, 1000 * this.options.heartbeat);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._parseURLOptions" id="apidoc.element.amqp.Connection.prototype._parseURLOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_parseURLOptions
        <span class="apidocSignatureSpan">(connectionString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseURLOptions = function (connectionString) {
  var opts = {};
  opts.ssl = {};
  var url = URL.parse(connectionString);
  var scheme = url.protocol.substring(0, url.protocol.lastIndexOf(':'));
  if (scheme != 'amqp' &amp;&amp; scheme != 'amqps') {
    throw new Error('Connection URI must use amqp or amqps scheme. ' +
                    'For example, "amqp://bus.megacorp.internal:5766".');
  }
  opts.ssl.enabled = ('amqps' === scheme);
  opts.host = url.hostname;
  opts.port = url.port || defaultPorts[scheme];
  if (url.auth) {
    var auth = url.auth.split(':');
    auth[0] &amp;&amp; (opts.login = auth[0]);
    auth[1] &amp;&amp; (opts.password = auth[1]);
  }
  if (url.pathname) {
    opts.vhost = unescape(url.pathname.substr(1));
  }
  return opts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._saslResponse" id="apidoc.element.amqp.Connection.prototype._saslResponse">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_saslResponse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_saslResponse = function () {
  var response;
  if (this.options.authMechanism == 'AMQPLAIN')
    response = {
      LOGIN: this.options.login,
      PASSWORD: this.options.password
    };
  else if (this.options.authMechanism == 'PLAIN')
    response = "\0" + this.options.login + "\0" + this.options.password;
  else if (this.options.authMechanism == 'EXTERNAL')
    response = "\0";
  else if (this.options.authMechanism == 'ANONYMOUS')
    response = "\0";
  else
    response = this.options.response;

  return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendBody" id="apidoc.element.amqp.Connection.prototype._sendBody">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendBody
        <span class="apidocSignatureSpan">(channel, body, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendBody = function (channel, body, properties) {
  var r = this._bodyToBuffer(body);
  var props = r[0], buffer = r[1];

  properties = _.assignIn(props || {}, properties);

  this._sendHeader(channel, buffer.length, properties);

  var pos = 0, len = buffer.length;
  var metaSize = 8; // headerBytes = 7, frameEndBytes = 1
  var maxBodySize = maxFrameBuffer - metaSize;

  while (len &gt; 0) {
    var bodySize = len &lt; maxBodySize ? len : maxBodySize;
    var frameSize = bodySize + metaSize;

    var b = new Buffer(frameSize);
    b.used = 0;
    b[b.used++] = 3; // constants.frameBody
    serializer.serializeInt(b, 2, channel);
    serializer.serializeInt(b, 4, bodySize);
    buffer.copy(b, b.used, pos, pos+bodySize);
    b.used += bodySize;
    b[b.used++] = 206; // constants.frameEnd;
    this.write(b);

    len -= bodySize;
    pos += bodySize;
  }
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // This interface is probably not appropriate for streaming large files.
    // (Of course it's arguable about whether AMQP is the appropriate
    // transport for large files.) The content header wants to know the size
    // of the data before sending it - so there's no point in trying to have a
    // general streaming interface - streaming messages of unknown size simply
    // isn't possible with AMQP. This is all to say, don't send big messages.
    // If you need to stream something large, chunk it yourself.
    self.connection.<span class="apidocCodeKeywordSpan">_sendBody</span>(self.channel, data, options);
  });

  if (self.options.confirm) self._awaitConfirm(task, callback);
  return task;
};

// registers tasks for confirms
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendHeader" id="apidoc.element.amqp.Connection.prototype._sendHeader">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendHeader
        <span class="apidocSignatureSpan">(channel, size, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendHeader = function (channel, size, properties) {
  var b = new Buffer(maxFrameBuffer); // FIXME allocating too much.
                                      // use freelist?
  b.used = 0;

  var classInfo = classes[60]; // always basic class.

  // 7 OCTET FRAME HEADER

  b[b.used++] = 2; // constants.frameHeader

  serializer.serializeInt(b, 2, channel);

  var lengthStart = b.used;

  serializer.serializeInt(b, 4, 0 /*dummy*/); // length

  var bodyStart = b.used;

  // HEADER'S BODY

  serializer.serializeInt(b, 2, classInfo.index);   // class 60 for Basic
  serializer.serializeInt(b, 2, 0);                 // weight, always 0 for rabbitmq
  serializer.serializeInt(b, 8, size);              // byte size of body

  // properties - first propertyFlags
  properties = _.defaults(properties || {}, {contentType: 'application/octet-stream'});
  var propertyFlags = 0;
  for (var i = 0; i &lt; classInfo.fields.length; i++) {
    if (properties[classInfo.fields[i].name]) propertyFlags |= 1 &lt;&lt; (15-i);
  }
  serializer.serializeInt(b, 2, propertyFlags);
  // now the actual properties.
  serializer.serializeFields(b, classInfo.fields, properties, false);

  //serializeTable(b, properties);

  var bodyEnd = b.used;

  // Go back to the header and write in the length now that we know it.
  b.used = lengthStart;
  serializer.serializeInt(b, 4, bodyEnd - bodyStart);
  b.used = bodyEnd;

  // 1 OCTET END

  b[b.used++] = 206; // constants.frameEnd;

  var s = new Buffer(b.used);
  b.copy(s);

  //debug &amp;&amp; debug('header sent: ' + JSON.stringify(s));

  this.write(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendMethod" id="apidoc.element.amqp.Connection.prototype._sendMethod">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendMethod = function (channel, method, args) {
  debug &amp;&amp; debug(channel + " &lt; " + method.name + " " + JSON.stringify(args));
  var b = this._sendBuffer;
  b.used = 0;

  b[b.used++] = 1; // constants.frameMethod

  serializer.serializeInt(b, 2, channel);

  var lengthIndex = b.used;

  serializer.serializeInt(b, 4, 42); // replace with actual length.

  var startIndex = b.used;


  serializer.serializeInt(b, 2, method.classIndex); // short, classId
  serializer.serializeInt(b, 2, method.methodIndex); // short, methodId

  serializer.serializeFields(b, method.fields, args, true);

  var endIndex = b.used;

  // write in the frame length now that we know it.
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;

  b[b.used++] = 206; // constants.frameEnd;

  var c = new Buffer(b.used);
  b.copy(c);

  debug &amp;&amp; debug("sending frame: " + c.toJSON());

  this.write(c);

  this._outboundHeartbeatTimerReset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._tasks = [];

  this.reconnect();
};
util.inherits(Channel, events.EventEmitter);

Channel.prototype.closeOK = function() {
  this.connection.<span class="apidocCodeKeywordSpan">_sendMethod</span>(this.channel, methods.channelCloseOk, {reserved1: "
;"});
};

Channel.prototype.reconnect = function () {
  this.connection._sendMethod(this.channel, methods.channelOpen, {reserved1: ""});
};

Channel.prototype._taskPush = function (reply, cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._startHandshake" id="apidoc.element.amqp.Connection.prototype._startHandshake">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_startHandshake
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_startHandshake = function () {
  debug &amp;&amp; debug("Initiating handshake...");
  this.write("AMQP" + String.fromCharCode(0,0,9,1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.addAllListeners" id="apidoc.element.amqp.Connection.prototype.addAllListeners">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>addAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addAllListeners = function () {
  var self = this;
  var connectEvent = this.options.ssl.enabled ? 'secureConnect' : 'connect';


  self.addListener(connectEvent, function() {
    // In the case where this is a reconnection, do not trample on the existing
    // channels.
    // For your reference, channel 0 is the control channel.
    self.channels = self.channels || {0:self};
    self.queues = self.queues || {};
    self.exchanges = self.exchanges || {};

    self.parser = new AMQPParser('0-9-1', 'client');

    self.parser.onMethod = function (channel, method, args) {
      self._onMethod(channel, method, args);
    };

    self.parser.onContent = function (channel, data) {
      debug &amp;&amp; debug(channel + " &gt; content " + data.length);
      if (self.channels[channel] &amp;&amp; self.channels[channel]._onContent) {
        self.channels[channel]._onContent(channel, data);
      } else {
        debug &amp;&amp; debug("unhandled content: " + data);
      }
    };

    self.parser.onContentHeader = function (channel, classInfo, weight, properties, size) {
      debug &amp;&amp; debug(channel + " &gt; content header " + JSON.stringify([classInfo.name, weight, properties, size]));
      if (self.channels[channel] &amp;&amp; self.channels[channel]._onContentHeader) {
        self.channels[channel]._onContentHeader(channel, classInfo, weight, properties, size);
      } else {
        debug &amp;&amp; debug("unhandled content header");
      }
    };

    self.parser.onHeartBeat = function () {
      self.emit("heartbeat");
      debug &amp;&amp; debug("heartbeat");
    };

    self.parser.onError = function (e) {
      self.emit("error", e);
      self.emit("close");
    };

    // Remove readyEmitted flag so we can detect an auth error.
    self.readyEmitted = false;
  });

  self.addListener('data', function (data) {
    if(self.parser != null){
      try {
        self.parser.execute(data);
      } catch (exception) {
        self.emit('error', exception);
        return;
      }
    }
    self._inboundHeartbeatTimerReset();
  });

  var backoffTime = null;
  self.addListener('error', function backoff(e) {
    if (self._inboundHeartbeatTimer !== null) {
      clearTimeout(self._inboundHeartbeatTimer);
      self._inboundHeartbeatTimer = null;
    }
    if (self._outboundHeartbeatTimer !== null) {
      clearTimeout(self._outboundHeartbeatTimer);
      self._outboundHeartbeatTimer = null;
    }

    if (!self.connectionAttemptScheduled) {
      // Set to true, as we are presently in the process of scheduling one.
      self.connectionAttemptScheduled = true;

      // Kill the socket, if it hasn't been killed already.
      self.socket.end();

      // Reset parser state
      self.parser = null;

      // In order for our reconnection to be seamless, we have to notify the
      // channels that they are no longer connected so that nobody attempts
      // to send messages which would be doomed to fail.
      for (var channel in self.channels) {
        if (channel !== '0') {
          self.channels[channel].state = 'closed';
        }
      }
      // Queues are channels (so we have already marked them as closed), but
      // queues have special needs, since the subscriptions will no longer
      // be known to the server when we reconnect.  Mark the subscriptions as
      // closed so that we can resubscribe them once we are reconnected.
      for (var queue in self.queues) {
        for (var index in self.queues[queue].consumerTagOptions) {
          self.queues[queue].consumerTagOptions[index]['state'] = 'closed';
        }
      }

      // Begin reconnection attempts
      if (self.implOptions.reconnect) {
        // Don't thrash, use a backoff strategy.
        if (backoffTime === null) {
          // This is the first time we've failed since a successful connection,
          // so use the configured backoff time without any modification.
          backoffTime = self.implOptions.reconnectBackoffTime;
        } else if (self.implOptions.reconnectBackoffStrategy === 'exponential') {
          // If you've configured exponential backoff, we'll double the
          // backoff time each ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.connect" id="apidoc.element.amqp.Connection.prototype.connect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  // If this is our first connection, add listeners.
  if (!this.socket) this.addAllListeners();

  this._createSocket();
  this._startHandshake();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
});
```

## Connection

`new amqp.Connection()` Instantiates a new connection. Use
`connection.<span class="apidocCodeKeywordSpan">connect</span>()` to connect to a server.

`amqp.createConnection()` returns an instance of `amqp.Connection`, which contains
an instance of `net.Socket` at its `socket` property. All events and methods which work on
`net.Socket` can also be used on an `amqp.Connection` instance. (e.g., the
events `'connect'` and `'close'`.)

### Connection options and URL
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.disconnect" id="apidoc.element.amqp.Connection.prototype.disconnect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function () {
  debug &amp;&amp; debug("Sending disconnect request to server");
  this._sendMethod(0, methods.connectionClose, {
    'replyText': 'client disconnect',
    'replyCode': 200,
    'classId': 0,
    'methodId': 0
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Table of Contents

- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.<span class="apidocCodeKeywordSpan">disconnect</span>()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.end" id="apidoc.element.amqp.Connection.prototype.end">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  if (this.socket) {
    this.socket.end();
  }

  this.options.heartbeat = false;

  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }

  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
    });

    m.addListener('end', function () {
var json, deliveryInfo = {}, msgProperties = classes[60].fields, i, l;

if (isJSON) {
  decoder.<span class="apidocCodeKeywordSpan">end</span>();
  try {
    json = JSON.parse(buffer);
  } catch (e) {
    json = null;
    deliveryInfo.parseError = e;
    deliveryInfo.rawData = buffer;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchange" id="apidoc.element.amqp.Connection.prototype.exchange">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchange
        <span class="apidocSignatureSpan">(name, options, openCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exchange = function (name, options, openCallback) {
  if (name === undefined) name = this.implOptions.defaultExchangeName;

  if (!options) options = {};
  if (name !== '' &amp;&amp; options.type === undefined) options.type = 'topic';

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit("error", exception);
    return;
  }
  var exchange = new Exchange(this, channel, name, options, openCallback);
  this.channels[channel] = exchange;
  this.exchanges[name] = exchange;
  return exchange;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.<span class="apidocCodeKeywordSpan">exchange</span>()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
- [exchange.unbind(srcExchange, routingKey [, callback])](#exchangeunbindsrcexchange-routingkey--callback)
- [exchange.bind_headers(exchange, routing [, bindCallback])](#exchangebind_headersexchange-routing--bindcallback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchangeClosed" id="apidoc.element.amqp.Connection.prototype.exchangeClosed">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchangeClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exchangeClosed = function (name) {
  if (this.exchanges[name]) delete this.exchanges[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._openCallback = null;
  }
  break;

case methods.channelClose:
  this.state = "closed";
  this.closeOK();
  this.connection.<span class="apidocCodeKeywordSpan">exchangeClosed</span>(this.name);
  var e = new Error(args.replyText);
  e.code = args.replyCode;
  this.emit('error', e);
  this.emit('close');
  break;

case methods.channelCloseOk:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.generateChannelId" id="apidoc.element.amqp.Connection.prototype.generateChannelId">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>generateChannelId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateChannelId = function () {
  // start from the last used slot id
  var channelId = this.channelCounter;
  while(true){
    // use values in range of 1..65535
    channelId = channelId % channelMax + 1;
    if(!this.channels[channelId]){
      break;
    }
    // after a full loop throw an Error
    if(channelId == this.channelCounter){
      throw new Error("No valid Channel Id values available");
    }
  }
  this.channelCounter = channelId;
  return this.channelCounter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.heartbeat" id="apidoc.element.amqp.Connection.prototype.heartbeat">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heartbeat = function () {
  if(this.socket.writable) this.write(new Buffer([8,0,0,0,0,0,0,206]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.publish" id="apidoc.element.amqp.Connection.prototype.publish">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>publish
        <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (routingKey, body, options, callback) {
  if (!this._defaultExchange) {
    this._defaultExchange = this.exchange();
  }

  var exchange = this._defaultExchange;
  if (exchange.state === 'open') {
    exchange.publish(routingKey, body, options, callback);
  } else {
    exchange.once('open', function() {
      exchange.publish(routingKey, body, options, callback);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Table of Contents

- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.<span class="apidocCodeKeywordSpan">publish</span>(routingKey, body, options, callback)](#connectionpublishroutingkey
-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queue" id="apidoc.element.amqp.Connection.prototype.queue">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queue
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (name) {
  var options, callback;
  if (typeof arguments[1] == 'object') {
    options = arguments[1];
    callback = arguments[2];
  } else {
    callback = arguments[1];
  }

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit("error", exception);
    return;
  }

  var q = new Queue(this, channel, name, options, callback);
  this.channels[channel] = q;
  return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.<span class="apidocCodeKeywordSpan">queue</span>(name[, options][, openCallback])](#connectionqueuename-options-opencallback
)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queueClosed" id="apidoc.element.amqp.Connection.prototype.queueClosed">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queueClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queueClosed = function (name) {
  if (this.queues[name]) delete this.queues[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Queue.prototype.destroy = function (options) {
var self = this;

options = options || {};
return this._taskPush(methods.queueDeleteOk, function () {
  self.connection.<span class="apidocCodeKeywordSpan">queueClosed</span>(self.name);
  if ('exchange' in self) {
    self.exchange.binds--;
  }
  self.connection._sendMethod(self.channel, methods.queueDelete,
      { reserved1: 0
      , queue: self.name
      , ifUnused: options.ifUnused ? true : false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.reconnect" id="apidoc.element.amqp.Connection.prototype.reconnect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>reconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnect = function () {
  // Suspend activity on channels
  for (var channel in this.channels) {
    this.channels[channel].state = 'closed';
  }
  debug &amp;&amp; debug("Connection lost, reconnecting...");
  // Terminate socket activity
  if (this.socket) this.socket.end();
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.<span class="apidocCodeKeywordSpan">reconnect</span>();
};
util.inherits(Channel, events.EventEmitter);

Channel.prototype.closeOK = function() {
  this.connection._sendMethod(this.channel, methods.channelCloseOk, {reserved1: ""});
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setImplOptions" id="apidoc.element.amqp.Connection.prototype.setImplOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setImplOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImplOptions = function (options) {
  this.implOptions = _.assignIn({}, defaultImplOptions, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setOptions" id="apidoc.element.amqp.Connection.prototype.setOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOptions = function (options) {
  var urlo = (options &amp;&amp; options.url) ? this._parseURLOptions(options.url) : {};
  var sslo = (options &amp;&amp; options.ssl &amp;&amp; options.ssl.enabled) ? defaultSslOptions : {};
  this.options = _.assignIn({}, defaultOptions, sslo, urlo, options || {});
  this.options.clientProperties =  _.assignIn({}, defaultClientProperties, (options &amp;&amp; options.clientProperties) || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._bodyToBuffer" id="apidoc.module.amqp.Connection.prototype._bodyToBuffer">module amqp.Connection.prototype._bodyToBuffer</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._bodyToBuffer._bodyToBuffer" id="apidoc.element.amqp.Connection.prototype._bodyToBuffer._bodyToBuffer">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_bodyToBuffer
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_bodyToBuffer = function (body) {
  // Handles 3 cases
  // - body is utf8 string
  // - body is instance of Buffer
  // - body is an object and its JSON representation is sent
  // Does not handle the case for streaming bodies.
  // Returns buffer.
  if (typeof(body) == 'string') {
    return [null, new Buffer(body, 'utf8')];
  } else if (body instanceof Buffer) {
    return [null, body];
  } else {
    var jsonBody = JSON.stringify(body);

    debug &amp;&amp; debug('sending json: ' + jsonBody);

    var props = {contentType: 'application/json'};
    return [props, new Buffer(jsonBody, 'utf8')];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._chooseHost" id="apidoc.module.amqp.Connection.prototype._chooseHost">module amqp.Connection.prototype._chooseHost</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._chooseHost._chooseHost" id="apidoc.element.amqp.Connection.prototype._chooseHost._chooseHost">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_chooseHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_chooseHost = function () {
  if(Array.isArray(this.options.host)){
    if(this.hosti == null){
      if(typeof this.options.hostPreference == 'number') {
        this.hosti = (this.options.hostPreference &lt; this.options.host.length) ?
          this.options.hostPreference : this.options.host.length-1;
      } else {
        this.hosti = parseInt(Math.random() * this.options.host.length, 10);
      }
    } else {
      // If this is already set, it looks like we want to choose another one.
      // Add one to hosti but don't overflow it.
      this.hosti = (this.hosti + 1) % this.options.host.length;
    }
    return this.options.host[this.hosti];
  } else {
    return this.options.host;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._createSocket" id="apidoc.module.amqp.Connection.prototype._createSocket">module amqp.Connection.prototype._createSocket</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._createSocket._createSocket" id="apidoc.element.amqp.Connection.prototype._createSocket._createSocket">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_createSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createSocket = function () {
  var hostName = this._chooseHost(), self = this, port = this.options.port;
  var parsedHost = URL.parse(hostName);
  if(parsedHost.port){
    hostName = parsedHost.hostname;
    port = parsedHost.port;
  }

  var options = {
    port: port,
    host: hostName
  };

  // Disable tcp nagle's algo
  // Default: true, makes small messages faster
  var noDelay = this.options.noDelay || true;

  var resetConnectionTimeout = function () {
    debug &amp;&amp; debug('connected so resetting connection timeout');
    this.setTimeout(0);
  };

  // Connect socket
  if (this.options.ssl.enabled) {
    debug &amp;&amp; debug('making ssl connection');
    options = _.assignIn(options, this._getSSLOptions());
    this.socket = tls.connect(options, resetConnectionTimeout);
  } else {
    debug &amp;&amp; debug('making non-ssl connection');
    this.socket = net.connect(options, resetConnectionTimeout);
  }
  var connTimeout = this.options.connectionTimeout;
  if (connTimeout) {
    debug &amp;&amp; debug('setting connection timeout to ' + connTimeout);
    this.socket.setTimeout(connTimeout, function () {
      debug &amp;&amp; debug('connection timeout');
      this.destroy();
      var e = new Error('connection timeout');
      e.name = 'TimeoutError';
      self.emit('error', e);
    });
  }

  this.socket.setNoDelay(noDelay);

  // Proxy events.
  // Note that if we don't attach a 'data' event, no data will flow.
  var events = ['close', 'connect', 'data', 'drain', 'error', 'end', 'secureConnect', 'timeout'];
  _.forEach(events, function(event){
    self.socket.on(event, self.emit.bind(self, event));
  });

  // Proxy a few methods that we use / previously used.
  var methods = ['destroy', 'write', 'pause', 'resume', 'setEncoding', 'ref', 'unref', 'address'];
  _.forEach(methods, function(method){
    self[method] = function(){
      self.socket[method].apply(self.socket, arguments);
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._getSSLOptions" id="apidoc.module.amqp.Connection.prototype._getSSLOptions">module amqp.Connection.prototype._getSSLOptions</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._getSSLOptions._getSSLOptions" id="apidoc.element.amqp.Connection.prototype._getSSLOptions._getSSLOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_getSSLOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSSLOptions = function () {
  if (this.sslConnectionOptions) return this.sslConnectionOptions;
  this.sslConnectionOptions = {};

  if (this.options.ssl.pfxFile) {
    this.sslConnectionOptions.pfx = fs.readFileSync(this.options.ssl.pfxFile);
  }
  if (this.options.ssl.keyFile) {
    this.sslConnectionOptions.key = fs.readFileSync(this.options.ssl.keyFile);
  }
  if (this.options.ssl.certFile) {
    this.sslConnectionOptions.cert = fs.readFileSync(this.options.ssl.certFile);
  }
  if (this.options.ssl.caFile) {
    if (Array.isArray(this.options.ssl.caFile)) {
      this.sslConnectionOptions.ca = this.options.ssl.caFile.map(function(f){
        return fs.readFileSync(f);
      });
    } else {
      this.sslConnectionOptions.ca = fs.readFileSync(this.options.ssl.caFile);
    }
  }

  this.sslConnectionOptions.rejectUnauthorized = this.options.ssl.rejectUnauthorized;
  this.sslConnectionOptions.passphrase = this.options.ssl.passphrase;

  return this.sslConnectionOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._inboundHeartbeatTimerReset" id="apidoc.module.amqp.Connection.prototype._inboundHeartbeatTimerReset">module amqp.Connection.prototype._inboundHeartbeatTimerReset</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset._inboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._inboundHeartbeatTimerReset._inboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_inboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_inboundHeartbeatTimerReset = function () {
  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }
  if (this.options.heartbeat) {
    var self = this;
    var gracePeriod = 2 * this.options.heartbeat;
    this._inboundHeartbeatTimer = setTimeout(function () {
      if(self.socket.readable || self.options.heartbeatForceReconnect){
        self.emit('error', new Error('no heartbeat or data in last ' + gracePeriod + ' seconds'));
      }
    }, gracePeriod * 1000);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._onMethod" id="apidoc.module.amqp.Connection.prototype._onMethod">module amqp.Connection.prototype._onMethod</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._onMethod._onMethod" id="apidoc.element.amqp.Connection.prototype._onMethod._onMethod">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_onMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onMethod = function (channel, method, args) {
  debug &amp;&amp; debug(channel + " &gt; " + method.name + " " + JSON.stringify(args));

  // Channel 0 is the control channel. If not zero then delegate to
  // one of the channel objects.

  if (channel &gt; 0) {
    if (!this.channels[channel]) {
      debug &amp;&amp; debug("Received message on untracked channel.");
      return;
    }
    if (!this.channels[channel]._onChannelMethod) {
      throw new Error('Channel ' + channel + ' has no _onChannelMethod method.');
    }
    this.channels[channel]._onChannelMethod(channel, method, args);
    return;
  }

  // channel 0

  switch (method) {
    // 2. The server responds, after the version string, with the
    // 'connectionStart' method (contains various useless information)
    case methods.connectionStart:
      // We check that they're serving us AMQP 0-9
      if (args.versionMajor !== 0 &amp;&amp; args.versionMinor != 9) {
        this.socket.end();
        this.emit('error', new Error("Bad server version"));
        return;
      }
      this.serverProperties = args.serverProperties;
      // 3. Then we reply with StartOk, containing our useless information.
      this._sendMethod(0, methods.connectionStartOk, {
        clientProperties: this.options.clientProperties,
        mechanism: this.options.authMechanism,
        response: this._saslResponse(),
        locale: 'en_US'
      });
      break;

    // 4. The server responds with a connectionTune request
    case methods.connectionTune:
      if (args.frameMax) {
          debug &amp;&amp; debug("tweaking maxFrameBuffer to " + args.frameMax);
          maxFrameBuffer = args.frameMax;
          this._sendBuffer = new Buffer(maxFrameBuffer);
          this.parser.setMaxFrameBuffer(maxFrameBuffer);
      }
      if (args.channelMax) {
          debug &amp;&amp; debug("tweaking channelMax to " + args.channelMax);
          channelMax = args.channelMax;
      }
      // 5. We respond with connectionTuneOk
      this._sendMethod(0, methods.connectionTuneOk, {
        channelMax: channelMax,
        frameMax: maxFrameBuffer,
        heartbeat: this.options.heartbeat || 0
      });
      // 6. Then we have to send a connectionOpen request
      this._sendMethod(0, methods.connectionOpen, {
        virtualHost: this.options.vhost
        // , capabilities: ''
        // , insist: true
        ,
        reserved1: '',
        reserved2: true
      });
      break;


    case methods.connectionOpenOk:
      // 7. Finally they respond with connectionOpenOk
      // Whew! That's why they call it the Advanced MQP.
      if (this._readyCallback) {
        this._readyCallback(this);
        this._readyCallback = null;
      }
      this.emit('ready');
      break;

    case methods.connectionClose:
      var e = new Error(args.replyText);
      e.code = args.replyCode;
      if (!this.listeners('close').length) {
        console.log('Unhandled connection error: ' + args.replyText);
      }
      this.socket.destroy(e);
      break;

    case methods.connectionCloseOk:
      debug &amp;&amp; debug("Received close-ok from server, closing socket");
      this.socket.end();
      break;

    case methods.connectionBlocked:
      debug &amp;&amp; debug('Received connection.blocked from server with reason: ' + args.reason);
      this._blocked = true;
      this._blockedReason = args.reason;
      this.emit('blocked');
      break;

    case methods.connectionUnblocked:
      debug &amp;&amp; debug('Received connection.unblocked from server');
      this._blocked = false;
      this._blockedReason = null;
      this.emit('unblocked');
      break;

    default:
      throw new Error("Uncaught method '" + method.name + "' with args " +
          JSON.stringify(args));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Channel.prototype._onChannelMethod = function(channel, method, args) {
switch (method) {
  case methods.channelCloseOk:
    delete this.connection.channels[this.channel];
    this.state = 'closed';
    // TODO should this be falling through?
  default:
    this.<span class="apidocCodeKeywordSpan">_onMethod</span>(channel, method, args);
}
};

Channel.prototype.close = function(reason) {
this.state = 'closing';
this.connection._sendMethod(this.channel, methods.channelClose,
                            {'replyText': reason ? reason : 'Goodbye from node',
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._outboundHeartbeatTimerReset" id="apidoc.module.amqp.Connection.prototype._outboundHeartbeatTimerReset">module amqp.Connection.prototype._outboundHeartbeatTimerReset</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset._outboundHeartbeatTimerReset" id="apidoc.element.amqp.Connection.prototype._outboundHeartbeatTimerReset._outboundHeartbeatTimerReset">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_outboundHeartbeatTimerReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_outboundHeartbeatTimerReset = function () {
  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
  if (this.socket.writable &amp;&amp; this.options.heartbeat) {
    var self = this;
    this._outboundHeartbeatTimer = setTimeout(function () {
      self.heartbeat();
      self._outboundHeartbeatTimerReset();
    }, 1000 * this.options.heartbeat);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._parseURLOptions" id="apidoc.module.amqp.Connection.prototype._parseURLOptions">module amqp.Connection.prototype._parseURLOptions</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._parseURLOptions._parseURLOptions" id="apidoc.element.amqp.Connection.prototype._parseURLOptions._parseURLOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_parseURLOptions
        <span class="apidocSignatureSpan">(connectionString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseURLOptions = function (connectionString) {
  var opts = {};
  opts.ssl = {};
  var url = URL.parse(connectionString);
  var scheme = url.protocol.substring(0, url.protocol.lastIndexOf(':'));
  if (scheme != 'amqp' &amp;&amp; scheme != 'amqps') {
    throw new Error('Connection URI must use amqp or amqps scheme. ' +
                    'For example, "amqp://bus.megacorp.internal:5766".');
  }
  opts.ssl.enabled = ('amqps' === scheme);
  opts.host = url.hostname;
  opts.port = url.port || defaultPorts[scheme];
  if (url.auth) {
    var auth = url.auth.split(':');
    auth[0] &amp;&amp; (opts.login = auth[0]);
    auth[1] &amp;&amp; (opts.password = auth[1]);
  }
  if (url.pathname) {
    opts.vhost = unescape(url.pathname.substr(1));
  }
  return opts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._saslResponse" id="apidoc.module.amqp.Connection.prototype._saslResponse">module amqp.Connection.prototype._saslResponse</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._saslResponse._saslResponse" id="apidoc.element.amqp.Connection.prototype._saslResponse._saslResponse">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_saslResponse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_saslResponse = function () {
  var response;
  if (this.options.authMechanism == 'AMQPLAIN')
    response = {
      LOGIN: this.options.login,
      PASSWORD: this.options.password
    };
  else if (this.options.authMechanism == 'PLAIN')
    response = "\0" + this.options.login + "\0" + this.options.password;
  else if (this.options.authMechanism == 'EXTERNAL')
    response = "\0";
  else if (this.options.authMechanism == 'ANONYMOUS')
    response = "\0";
  else
    response = this.options.response;

  return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._sendBody" id="apidoc.module.amqp.Connection.prototype._sendBody">module amqp.Connection.prototype._sendBody</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendBody._sendBody" id="apidoc.element.amqp.Connection.prototype._sendBody._sendBody">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendBody
        <span class="apidocSignatureSpan">(channel, body, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendBody = function (channel, body, properties) {
  var r = this._bodyToBuffer(body);
  var props = r[0], buffer = r[1];

  properties = _.assignIn(props || {}, properties);

  this._sendHeader(channel, buffer.length, properties);

  var pos = 0, len = buffer.length;
  var metaSize = 8; // headerBytes = 7, frameEndBytes = 1
  var maxBodySize = maxFrameBuffer - metaSize;

  while (len &gt; 0) {
    var bodySize = len &lt; maxBodySize ? len : maxBodySize;
    var frameSize = bodySize + metaSize;

    var b = new Buffer(frameSize);
    b.used = 0;
    b[b.used++] = 3; // constants.frameBody
    serializer.serializeInt(b, 2, channel);
    serializer.serializeInt(b, 4, bodySize);
    buffer.copy(b, b.used, pos, pos+bodySize);
    b.used += bodySize;
    b[b.used++] = 206; // constants.frameEnd;
    this.write(b);

    len -= bodySize;
    pos += bodySize;
  }
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // This interface is probably not appropriate for streaming large files.
    // (Of course it's arguable about whether AMQP is the appropriate
    // transport for large files.) The content header wants to know the size
    // of the data before sending it - so there's no point in trying to have a
    // general streaming interface - streaming messages of unknown size simply
    // isn't possible with AMQP. This is all to say, don't send big messages.
    // If you need to stream something large, chunk it yourself.
    self.connection.<span class="apidocCodeKeywordSpan">_sendBody</span>(self.channel, data, options);
  });

  if (self.options.confirm) self._awaitConfirm(task, callback);
  return task;
};

// registers tasks for confirms
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._sendHeader" id="apidoc.module.amqp.Connection.prototype._sendHeader">module amqp.Connection.prototype._sendHeader</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendHeader._sendHeader" id="apidoc.element.amqp.Connection.prototype._sendHeader._sendHeader">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendHeader
        <span class="apidocSignatureSpan">(channel, size, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendHeader = function (channel, size, properties) {
  var b = new Buffer(maxFrameBuffer); // FIXME allocating too much.
                                      // use freelist?
  b.used = 0;

  var classInfo = classes[60]; // always basic class.

  // 7 OCTET FRAME HEADER

  b[b.used++] = 2; // constants.frameHeader

  serializer.serializeInt(b, 2, channel);

  var lengthStart = b.used;

  serializer.serializeInt(b, 4, 0 /*dummy*/); // length

  var bodyStart = b.used;

  // HEADER'S BODY

  serializer.serializeInt(b, 2, classInfo.index);   // class 60 for Basic
  serializer.serializeInt(b, 2, 0);                 // weight, always 0 for rabbitmq
  serializer.serializeInt(b, 8, size);              // byte size of body

  // properties - first propertyFlags
  properties = _.defaults(properties || {}, {contentType: 'application/octet-stream'});
  var propertyFlags = 0;
  for (var i = 0; i &lt; classInfo.fields.length; i++) {
    if (properties[classInfo.fields[i].name]) propertyFlags |= 1 &lt;&lt; (15-i);
  }
  serializer.serializeInt(b, 2, propertyFlags);
  // now the actual properties.
  serializer.serializeFields(b, classInfo.fields, properties, false);

  //serializeTable(b, properties);

  var bodyEnd = b.used;

  // Go back to the header and write in the length now that we know it.
  b.used = lengthStart;
  serializer.serializeInt(b, 4, bodyEnd - bodyStart);
  b.used = bodyEnd;

  // 1 OCTET END

  b[b.used++] = 206; // constants.frameEnd;

  var s = new Buffer(b.used);
  b.copy(s);

  //debug &amp;&amp; debug('header sent: ' + JSON.stringify(s));

  this.write(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._sendMethod" id="apidoc.module.amqp.Connection.prototype._sendMethod">module amqp.Connection.prototype._sendMethod</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._sendMethod._sendMethod" id="apidoc.element.amqp.Connection.prototype._sendMethod._sendMethod">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_sendMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendMethod = function (channel, method, args) {
  debug &amp;&amp; debug(channel + " &lt; " + method.name + " " + JSON.stringify(args));
  var b = this._sendBuffer;
  b.used = 0;

  b[b.used++] = 1; // constants.frameMethod

  serializer.serializeInt(b, 2, channel);

  var lengthIndex = b.used;

  serializer.serializeInt(b, 4, 42); // replace with actual length.

  var startIndex = b.used;


  serializer.serializeInt(b, 2, method.classIndex); // short, classId
  serializer.serializeInt(b, 2, method.methodIndex); // short, methodId

  serializer.serializeFields(b, method.fields, args, true);

  var endIndex = b.used;

  // write in the frame length now that we know it.
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;

  b[b.used++] = 206; // constants.frameEnd;

  var c = new Buffer(b.used);
  b.copy(c);

  debug &amp;&amp; debug("sending frame: " + c.toJSON());

  this.write(c);

  this._outboundHeartbeatTimerReset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._tasks = [];

  this.reconnect();
};
util.inherits(Channel, events.EventEmitter);

Channel.prototype.closeOK = function() {
  this.connection.<span class="apidocCodeKeywordSpan">_sendMethod</span>(this.channel, methods.channelCloseOk, {reserved1: "
;"});
};

Channel.prototype.reconnect = function () {
  this.connection._sendMethod(this.channel, methods.channelOpen, {reserved1: ""});
};

Channel.prototype._taskPush = function (reply, cb) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype._startHandshake" id="apidoc.module.amqp.Connection.prototype._startHandshake">module amqp.Connection.prototype._startHandshake</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype._startHandshake._startHandshake" id="apidoc.element.amqp.Connection.prototype._startHandshake._startHandshake">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>_startHandshake
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_startHandshake = function () {
  debug &amp;&amp; debug("Initiating handshake...");
  this.write("AMQP" + String.fromCharCode(0,0,9,1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.addAllListeners" id="apidoc.module.amqp.Connection.prototype.addAllListeners">module amqp.Connection.prototype.addAllListeners</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.addAllListeners.addAllListeners" id="apidoc.element.amqp.Connection.prototype.addAllListeners.addAllListeners">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>addAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addAllListeners = function () {
  var self = this;
  var connectEvent = this.options.ssl.enabled ? 'secureConnect' : 'connect';


  self.addListener(connectEvent, function() {
    // In the case where this is a reconnection, do not trample on the existing
    // channels.
    // For your reference, channel 0 is the control channel.
    self.channels = self.channels || {0:self};
    self.queues = self.queues || {};
    self.exchanges = self.exchanges || {};

    self.parser = new AMQPParser('0-9-1', 'client');

    self.parser.onMethod = function (channel, method, args) {
      self._onMethod(channel, method, args);
    };

    self.parser.onContent = function (channel, data) {
      debug &amp;&amp; debug(channel + " &gt; content " + data.length);
      if (self.channels[channel] &amp;&amp; self.channels[channel]._onContent) {
        self.channels[channel]._onContent(channel, data);
      } else {
        debug &amp;&amp; debug("unhandled content: " + data);
      }
    };

    self.parser.onContentHeader = function (channel, classInfo, weight, properties, size) {
      debug &amp;&amp; debug(channel + " &gt; content header " + JSON.stringify([classInfo.name, weight, properties, size]));
      if (self.channels[channel] &amp;&amp; self.channels[channel]._onContentHeader) {
        self.channels[channel]._onContentHeader(channel, classInfo, weight, properties, size);
      } else {
        debug &amp;&amp; debug("unhandled content header");
      }
    };

    self.parser.onHeartBeat = function () {
      self.emit("heartbeat");
      debug &amp;&amp; debug("heartbeat");
    };

    self.parser.onError = function (e) {
      self.emit("error", e);
      self.emit("close");
    };

    // Remove readyEmitted flag so we can detect an auth error.
    self.readyEmitted = false;
  });

  self.addListener('data', function (data) {
    if(self.parser != null){
      try {
        self.parser.execute(data);
      } catch (exception) {
        self.emit('error', exception);
        return;
      }
    }
    self._inboundHeartbeatTimerReset();
  });

  var backoffTime = null;
  self.addListener('error', function backoff(e) {
    if (self._inboundHeartbeatTimer !== null) {
      clearTimeout(self._inboundHeartbeatTimer);
      self._inboundHeartbeatTimer = null;
    }
    if (self._outboundHeartbeatTimer !== null) {
      clearTimeout(self._outboundHeartbeatTimer);
      self._outboundHeartbeatTimer = null;
    }

    if (!self.connectionAttemptScheduled) {
      // Set to true, as we are presently in the process of scheduling one.
      self.connectionAttemptScheduled = true;

      // Kill the socket, if it hasn't been killed already.
      self.socket.end();

      // Reset parser state
      self.parser = null;

      // In order for our reconnection to be seamless, we have to notify the
      // channels that they are no longer connected so that nobody attempts
      // to send messages which would be doomed to fail.
      for (var channel in self.channels) {
        if (channel !== '0') {
          self.channels[channel].state = 'closed';
        }
      }
      // Queues are channels (so we have already marked them as closed), but
      // queues have special needs, since the subscriptions will no longer
      // be known to the server when we reconnect.  Mark the subscriptions as
      // closed so that we can resubscribe them once we are reconnected.
      for (var queue in self.queues) {
        for (var index in self.queues[queue].consumerTagOptions) {
          self.queues[queue].consumerTagOptions[index]['state'] = 'closed';
        }
      }

      // Begin reconnection attempts
      if (self.implOptions.reconnect) {
        // Don't thrash, use a backoff strategy.
        if (backoffTime === null) {
          // This is the first time we've failed since a successful connection,
          // so use the configured backoff time without any modification.
          backoffTime = self.implOptions.reconnectBackoffTime;
        } else if (self.implOptions.reconnectBackoffStrategy === 'exponential') {
          // If you've configured exponential backoff, we'll double the
          // backoff time each ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.connect" id="apidoc.module.amqp.Connection.prototype.connect">module amqp.Connection.prototype.connect</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.connect.connect" id="apidoc.element.amqp.Connection.prototype.connect.connect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  // If this is our first connection, add listeners.
  if (!this.socket) this.addAllListeners();

  this._createSocket();
  this._startHandshake();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
});
```

## Connection

`new amqp.Connection()` Instantiates a new connection. Use
`connection.<span class="apidocCodeKeywordSpan">connect</span>()` to connect to a server.

`amqp.createConnection()` returns an instance of `amqp.Connection`, which contains
an instance of `net.Socket` at its `socket` property. All events and methods which work on
`net.Socket` can also be used on an `amqp.Connection` instance. (e.g., the
events `'connect'` and `'close'`.)

### Connection options and URL
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.disconnect" id="apidoc.module.amqp.Connection.prototype.disconnect">module amqp.Connection.prototype.disconnect</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.disconnect.disconnect" id="apidoc.element.amqp.Connection.prototype.disconnect.disconnect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function () {
  debug &amp;&amp; debug("Sending disconnect request to server");
  this._sendMethod(0, methods.connectionClose, {
    'replyText': 'client disconnect',
    'replyCode': 200,
    'classId': 0,
    'methodId': 0
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Table of Contents

- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.<span class="apidocCodeKeywordSpan">disconnect</span>()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.end" id="apidoc.module.amqp.Connection.prototype.end">module amqp.Connection.prototype.end</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.end.end" id="apidoc.element.amqp.Connection.prototype.end.end">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  if (this.socket) {
    this.socket.end();
  }

  this.options.heartbeat = false;

  if (this._inboundHeartbeatTimer !== null) {
    clearTimeout(this._inboundHeartbeatTimer);
    this._inboundHeartbeatTimer = null;
  }

  if (this._outboundHeartbeatTimer !== null) {
    clearTimeout(this._outboundHeartbeatTimer);
    this._outboundHeartbeatTimer = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
    });

    m.addListener('end', function () {
var json, deliveryInfo = {}, msgProperties = classes[60].fields, i, l;

if (isJSON) {
  decoder.<span class="apidocCodeKeywordSpan">end</span>();
  try {
    json = JSON.parse(buffer);
  } catch (e) {
    json = null;
    deliveryInfo.parseError = e;
    deliveryInfo.rawData = buffer;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.exchange" id="apidoc.module.amqp.Connection.prototype.exchange">module amqp.Connection.prototype.exchange</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchange.exchange" id="apidoc.element.amqp.Connection.prototype.exchange.exchange">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchange
        <span class="apidocSignatureSpan">(name, options, openCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exchange = function (name, options, openCallback) {
  if (name === undefined) name = this.implOptions.defaultExchangeName;

  if (!options) options = {};
  if (name !== '' &amp;&amp; options.type === undefined) options.type = 'topic';

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit("error", exception);
    return;
  }
  var exchange = new Exchange(this, channel, name, options, openCallback);
  this.channels[channel] = exchange;
  this.exchanges[name] = exchange;
  return exchange;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.<span class="apidocCodeKeywordSpan">exchange</span>()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
- [exchange.unbind(srcExchange, routingKey [, callback])](#exchangeunbindsrcexchange-routingkey--callback)
- [exchange.bind_headers(exchange, routing [, bindCallback])](#exchangebind_headersexchange-routing--bindcallback)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.exchangeClosed" id="apidoc.module.amqp.Connection.prototype.exchangeClosed">module amqp.Connection.prototype.exchangeClosed</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.exchangeClosed.exchangeClosed" id="apidoc.element.amqp.Connection.prototype.exchangeClosed.exchangeClosed">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>exchangeClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exchangeClosed = function (name) {
  if (this.exchanges[name]) delete this.exchanges[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._openCallback = null;
  }
  break;

case methods.channelClose:
  this.state = "closed";
  this.closeOK();
  this.connection.<span class="apidocCodeKeywordSpan">exchangeClosed</span>(this.name);
  var e = new Error(args.replyText);
  e.code = args.replyCode;
  this.emit('error', e);
  this.emit('close');
  break;

case methods.channelCloseOk:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.generateChannelId" id="apidoc.module.amqp.Connection.prototype.generateChannelId">module amqp.Connection.prototype.generateChannelId</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.generateChannelId.generateChannelId" id="apidoc.element.amqp.Connection.prototype.generateChannelId.generateChannelId">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>generateChannelId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateChannelId = function () {
  // start from the last used slot id
  var channelId = this.channelCounter;
  while(true){
    // use values in range of 1..65535
    channelId = channelId % channelMax + 1;
    if(!this.channels[channelId]){
      break;
    }
    // after a full loop throw an Error
    if(channelId == this.channelCounter){
      throw new Error("No valid Channel Id values available");
    }
  }
  this.channelCounter = channelId;
  return this.channelCounter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.heartbeat" id="apidoc.module.amqp.Connection.prototype.heartbeat">module amqp.Connection.prototype.heartbeat</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.heartbeat.heartbeat" id="apidoc.element.amqp.Connection.prototype.heartbeat.heartbeat">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heartbeat = function () {
  if(this.socket.writable) this.write(new Buffer([8,0,0,0,0,0,0,206]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.publish" id="apidoc.module.amqp.Connection.prototype.publish">module amqp.Connection.prototype.publish</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.publish.publish" id="apidoc.element.amqp.Connection.prototype.publish.publish">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>publish
        <span class="apidocSignatureSpan">(routingKey, body, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (routingKey, body, options, callback) {
  if (!this._defaultExchange) {
    this._defaultExchange = this.exchange();
  }

  var exchange = this._defaultExchange;
  if (exchange.state === 'open') {
    exchange.publish(routingKey, body, options, callback);
  } else {
    exchange.once('open', function() {
      exchange.publish(routingKey, body, options, callback);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Table of Contents

- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.<span class="apidocCodeKeywordSpan">publish</span>(routingKey, body, options, callback)](#connectionpublishroutingkey
-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.queue" id="apidoc.module.amqp.Connection.prototype.queue">module amqp.Connection.prototype.queue</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queue.queue" id="apidoc.element.amqp.Connection.prototype.queue.queue">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queue
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (name) {
  var options, callback;
  if (typeof arguments[1] == 'object') {
    options = arguments[1];
    callback = arguments[2];
  } else {
    callback = arguments[1];
  }

  try{
    var channel = this.generateChannelId();
  }catch(exception){
    this.emit("error", exception);
    return;
  }

  var q = new Queue(this, channel, name, options, callback);
  this.channels[channel] = q;
  return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.<span class="apidocCodeKeywordSpan">queue</span>(name[, options][, openCallback])](#connectionqueuename-options-opencallback
)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.queueClosed" id="apidoc.module.amqp.Connection.prototype.queueClosed">module amqp.Connection.prototype.queueClosed</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.queueClosed.queueClosed" id="apidoc.element.amqp.Connection.prototype.queueClosed.queueClosed">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>queueClosed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queueClosed = function (name) {
  if (this.queues[name]) delete this.queues[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Queue.prototype.destroy = function (options) {
var self = this;

options = options || {};
return this._taskPush(methods.queueDeleteOk, function () {
  self.connection.<span class="apidocCodeKeywordSpan">queueClosed</span>(self.name);
  if ('exchange' in self) {
    self.exchange.binds--;
  }
  self.connection._sendMethod(self.channel, methods.queueDelete,
      { reserved1: 0
      , queue: self.name
      , ifUnused: options.ifUnused ? true : false
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.reconnect" id="apidoc.module.amqp.Connection.prototype.reconnect">module amqp.Connection.prototype.reconnect</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.reconnect.reconnect" id="apidoc.element.amqp.Connection.prototype.reconnect.reconnect">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>reconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnect = function () {
  // Suspend activity on channels
  for (var channel in this.channels) {
    this.channels[channel].state = 'closed';
  }
  debug &amp;&amp; debug("Connection lost, reconnecting...");
  // Terminate socket activity
  if (this.socket) this.socket.end();
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.<span class="apidocCodeKeywordSpan">reconnect</span>();
};
util.inherits(Channel, events.EventEmitter);

Channel.prototype.closeOK = function() {
  this.connection._sendMethod(this.channel, methods.channelCloseOk, {reserved1: ""});
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.setImplOptions" id="apidoc.module.amqp.Connection.prototype.setImplOptions">module amqp.Connection.prototype.setImplOptions</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setImplOptions.setImplOptions" id="apidoc.element.amqp.Connection.prototype.setImplOptions.setImplOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setImplOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImplOptions = function (options) {
  this.implOptions = _.assignIn({}, defaultImplOptions, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.Connection.prototype.setOptions" id="apidoc.module.amqp.Connection.prototype.setOptions">module amqp.Connection.prototype.setOptions</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.Connection.prototype.setOptions.setOptions" id="apidoc.element.amqp.Connection.prototype.setOptions.setOptions">
        function <span class="apidocSignatureSpan">amqp.Connection.prototype.</span>setOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOptions = function (options) {
  var urlo = (options &amp;&amp; options.url) ? this._parseURLOptions(options.url) : {};
  var sslo = (options &amp;&amp; options.ssl &amp;&amp; options.ssl.enabled) ? defaultSslOptions : {};
  this.options = _.assignIn({}, defaultOptions, sslo, urlo, options || {});
  this.options.clientProperties =  _.assignIn({}, defaultClientProperties, (options &amp;&amp; options.clientProperties) || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.channel" id="apidoc.module.amqp.channel">module amqp.channel</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.channel.channel" id="apidoc.element.amqp.channel.channel">
        function <span class="apidocSignatureSpan">amqp.</span>channel
        <span class="apidocSignatureSpan">(connection, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Channel(connection, channel) {
  events.EventEmitter.call(this);

  // Unlimited listeners. Helps when e.g. publishing high-volume messages,
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.reconnect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.super_" id="apidoc.element.amqp.channel.super_">
        function <span class="apidocSignatureSpan">amqp.channel.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.channel.prototype" id="apidoc.module.amqp.channel.prototype">module amqp.channel.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.channel.prototype._handleTaskReply" id="apidoc.element.amqp.channel.prototype._handleTaskReply">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_handleTaskReply
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleTaskReply = function (channel, method, args) {
  var task, i;

  for (i = 0; i &lt; this._tasks.length; i++) {
    if (this._tasks[i].reply == method) {
      task = this._tasks[i];
      this._tasks.splice(i, 1);
      task.promise.emitSuccess(args);
      this._tasksFlush();
      return true;
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype._onChannelMethod" id="apidoc.element.amqp.channel.prototype._onChannelMethod">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_onChannelMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onChannelMethod = function (channel, method, args) {
  switch (method) {
    case methods.channelCloseOk:
      delete this.connection.channels[this.channel];
      this.state = 'closed';
      // TODO should this be falling through?
    default:
      this._onMethod(channel, method, args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype._taskPush" id="apidoc.element.amqp.channel.prototype._taskPush">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_taskPush
        <span class="apidocSignatureSpan">(reply, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_taskPush = function (reply, cb) {
  var promise = new Promise();
  this._tasks.push({
    promise: promise,
    reply: reply,
    sent: false,
    cb: cb
  });
  this._tasksFlush();
  return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = _.assignIn({}, options || {});
options.routingKey = routingKey;
options.exchange   = self.name;
options.mandatory  = options.mandatory ? true : false;
options.immediate  = options.immediate ? true : false;
options.reserved1  = 0;

var task = this.<span class="apidocCodeKeywordSpan">_taskPush</span>(null, function () {
  self.connection._sendMethod(self.channel, methods.basicPublish, options);
  // This interface is probably not appropriate for streaming large files.
  // (Of course it's arguable about whether AMQP is the appropriate
  // transport for large files.) The content header wants to know the size
  // of the data before sending it - so there's no point in trying to have a
  // general streaming interface - streaming messages of unknown size simply
  // isn't possible with AMQP. This is all to say, don't send big messages.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype._tasksFlush" id="apidoc.element.amqp.channel.prototype._tasksFlush">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>_tasksFlush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_tasksFlush = function () {
  if (this.state != 'open') return;

  for (var i = 0; i &lt; this._tasks.length; i++) {
    var task = this._tasks[i];
    if (task.sent) continue;
    task.cb();
    task.sent = true;
    if (!task.reply) {
      // if we don't expect a reply, just delete it now
      this._tasks.splice(i, 1);
      i = i-1;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var promise = new Promise();
this._tasks.push({
  promise: promise,
  reply: reply,
  sent: false,
  cb: cb
});
this.<span class="apidocCodeKeywordSpan">_tasksFlush</span>();
return promise;
};

Channel.prototype._tasksFlush = function () {
if (this.state != 'open') return;

for (var i = 0; i &lt; this._tasks.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype.close" id="apidoc.element.amqp.channel.prototype.close">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>close
        <span class="apidocSignatureSpan">(reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (reason) {
  this.state = 'closing';
  this.connection._sendMethod(this.channel, methods.channelClose,
                              {'replyText': reason ? reason : 'Goodbye from node',
                               'replyCode': 200,
                               'classId': 0,
                               'methodId': 0});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.connection._sendMethod(self.channel, methods.basicCancel,
                                { reserved1: 0,
                                  consumerTag: consumerTag,
                                  noWait: false });
  })
  .addCallback(function () {
    if (self.options.closeChannelOnUnsubscribe) {
      self.<span class="apidocCodeKeywordSpan">close</span>();
    }
    delete self.consumerTagListeners[consumerTag];
    delete self.consumerTagOptions[consumerTag];
  });
};

Queue.prototype.subscribe = function (options, messageListener) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype.closeOK" id="apidoc.element.amqp.channel.prototype.closeOK">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>closeOK
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeOK = function () {
  this.connection._sendMethod(this.channel, methods.channelCloseOk, {reserved1: ""});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._openCallback(this);
    this._openCallback = null;
  }
  break;

case methods.channelClose:
  this.state = "closed";
  this.<span class="apidocCodeKeywordSpan">closeOK</span>();
  this.connection.exchangeClosed(this.name);
  var e = new Error(args.replyText);
  e.code = args.replyCode;
  this.emit('error', e);
  this.emit('close');
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.channel.prototype.reconnect" id="apidoc.element.amqp.channel.prototype.reconnect">
        function <span class="apidocSignatureSpan">amqp.channel.prototype.</span>reconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnect = function () {
  this.connection._sendMethod(this.channel, methods.channelOpen, {reserved1: ""});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.<span class="apidocCodeKeywordSpan">reconnect</span>();
};
util.inherits(Channel, events.EventEmitter);

Channel.prototype.closeOK = function() {
  this.connection._sendMethod(this.channel, methods.channelCloseOk, {reserved1: ""});
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.createConnection" id="apidoc.module.amqp.createConnection">module amqp.createConnection</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.createConnection.createConnection" id="apidoc.element.amqp.createConnection.createConnection">
        function <span class="apidocSignatureSpan">amqp.</span>createConnection
        <span class="apidocSignatureSpan">(options, implOptions, readyCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createConnection = function (options, implOptions, readyCallback) {
  var c = new Connection(options, implOptions, readyCallback);
  c.connect();
  return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
IMPORTANT: This module only works with node v0.4.0 and later.

An example of connecting to a server and listening on a queue.

```javascript
var amqp = require('amqp');

var connection = amqp.<span class="apidocCodeKeywordSpan">createConnection</span>({ host: 'dev.rabbitmq.com' });

// add this for better debuging
connection.on('error', function(e) {
  console.log("Error from amqp: ", e);
});

// Wait for connection to become established.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.exchange" id="apidoc.module.amqp.exchange">module amqp.exchange</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.exchange.exchange" id="apidoc.element.amqp.exchange.exchange">
        function <span class="apidocSignatureSpan">amqp.</span>exchange
        <span class="apidocSignatureSpan">(connection, channel, name, options, openCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Exchange(connection, channel, name, options, openCallback) {
  Channel.call(this, connection, channel);
  this.name = name;
  this.binds = 0; // keep track of queues bound
  this.exchangeBinds = 0; // keep track of exchanges bound
  this.sourceExchanges = {};
  this.options = _.defaults(options || {}, {autoDelete: true});
  this._openCallback = openCallback;

  this._sequence = null;
  this._unAcked  = {};
  this._addedExchangeErrorHandler = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.<span class="apidocCodeKeywordSpan">exchange</span>()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
- [exchange.unbind(srcExchange, routingKey [, callback])](#exchangeunbindsrcexchange-routingkey--callback)
- [exchange.bind_headers(exchange, routing [, bindCallback])](#exchangebind_headersexchange-routing--bindcallback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.super_" id="apidoc.element.amqp.exchange.super_">
        function <span class="apidocSignatureSpan">amqp.exchange.</span>super_
        <span class="apidocSignatureSpan">(connection, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Channel(connection, channel) {
  events.EventEmitter.call(this);

  // Unlimited listeners. Helps when e.g. publishing high-volume messages,
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.reconnect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.exchange.prototype" id="apidoc.module.amqp.exchange.prototype">module amqp.exchange.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype._awaitConfirm" id="apidoc.element.amqp.exchange.prototype._awaitConfirm">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_awaitConfirm
        <span class="apidocSignatureSpan">(task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _awaitConfirm(task, callback) {
  if (!this._addedExchangeErrorHandler) {
    // if connection fails, we want to ack error all unacked publishes.
    this.connection.on('error', createExchangeErrorHandlerFor(this));
    this.on('error', createExchangeErrorHandlerFor(this));
    this._addedExchangeErrorHandler = true;
  }

  debug &amp;&amp; debug('awaiting confirmation for ' + this._sequence);
  task.sequence = this._sequence;
  this._unAcked[this._sequence] = task;
  this._sequence++;

  if ('function' != typeof callback) return;

  task.once('ack error', function (err) {
    task.removeAllListeners();
    callback(true, err);
  });

  task.once('ack', function () {
    task.removeAllListeners();
    callback(false);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // of the data before sending it - so there's no point in trying to have a
  // general streaming interface - streaming messages of unknown size simply
  // isn't possible with AMQP. This is all to say, don't send big messages.
  // If you need to stream something large, chunk it yourself.
  self.connection._sendBody(self.channel, data, options);
});

if (self.options.confirm) self.<span class="apidocCodeKeywordSpan">_awaitConfirm</span>(task, callback);
return task;
};

// registers tasks for confirms
Exchange.prototype._awaitConfirm = function _awaitConfirm (task, callback) {
if (!this._addedExchangeErrorHandler) {
  // if connection fails, we want to ack error all unacked publishes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype._confirmSelect" id="apidoc.element.amqp.exchange.prototype._confirmSelect">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_confirmSelect
        <span class="apidocSignatureSpan">(channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_confirmSelect = function (channel) {
  this.connection._sendMethod(channel, methods.confirmSelect, { noWait: false });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._addedExchangeErrorHandler = true;
      }

      // Pre-baked exchanges don't need to be declared
      if (/^$|(amq\.)/.test(this.name)) {
//If confirm mode is specified we have to set it no matter the exchange.
if (this.options.confirm) {
  this.<span class="apidocCodeKeywordSpan">_confirmSelect</span>(channel);
  return;
}

this.state = 'open';
// - issue #33 fix
if (this._openCallback) {
 this._openCallback(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype._onMethod" id="apidoc.element.amqp.exchange.prototype._onMethod">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_onMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onMethod = function (channel, method, args) {
  this.emit(method.name, args);

  if (this._handleTaskReply.apply(this, arguments))
    return true;

  var cb;

  switch (method) {
    case methods.channelOpenOk:
      this._sequence = null;

      if (!this._addedExchangeErrorHandler) {
        var errorHandler = createExchangeErrorHandlerFor(this);
        this.connection.on('error', errorHandler);
        this.on('error', errorHandler);
        this._addedExchangeErrorHandler = true;
      }

      // Pre-baked exchanges don't need to be declared
      if (/^$|(amq\.)/.test(this.name)) {
        //If confirm mode is specified we have to set it no matter the exchange.
        if (this.options.confirm) {
          this._confirmSelect(channel);
          return;
        }

        this.state = 'open';
        // - issue #33 fix
        if (this._openCallback) {
         this._openCallback(this);
         this._openCallback = null;
        }
        // --
        this.emit('open');

      // For if we want to delete a exchange,
      // we dont care if all of the options match.
      } else if (this.options.noDeclare) {
        if (this.options.confirm) {
          this._confirmSelect(channel);
          this.state = 'open';

          if (this._openCallback) {
           this._openCallback(this);
           this._openCallback = null;
          }

          this.emit('open');
        }
      } else {
        this.connection._sendMethod(channel, methods.exchangeDeclare,
            { reserved1:  0
            , reserved2:  false
            , reserved3:  false
            , exchange:   this.name
            , type:       this.options.type || 'topic'
            , passive:    !!this.options.passive
            , durable:    !!this.options.durable
            , autoDelete: !!this.options.autoDelete
            , internal:   !!this.options.internal
            , noWait:     false
            , "arguments":this.options.arguments || {}
            });
        this.state = 'declaring';
      }
      break;

    case methods.exchangeDeclareOk:
      if (this.options.confirm) {
        this._confirmSelect(channel);
      } else {

        this.state = 'open';
        this.emit('open');
        if (this._openCallback) {
          this._openCallback(this);
          this._openCallback = null;
        }
      }
      break;

    case methods.confirmSelectOk:
      this._sequence = 1;

      this.state = 'open';
      this.emit('open');
      if (this._openCallback) {
        this._openCallback(this);
        this._openCallback = null;
      }
      break;

    case methods.channelClose:
      this.state = "closed";
      this.closeOK();
      this.connection.exchangeClosed(this.name);
      var e = new Error(args.replyText);
      e.code = args.replyCode;
      this.emit('error', e);
      this.emit('close');
      break;

    case methods.channelCloseOk:
      this.connection.exchangeClosed(this.name);
      this.emit('close');
      break;


    case methods.basicAck:
      this.emit('basic-ack', args);
      var sequenceNumber = args.deliveryTag.readUInt32BE(4), tag;
      debug &amp;&amp; debug("basic-ack, sequence: ", sequenceNumber);

      if (sequenceNumber === 0 &amp;&amp; args.multiple === true) {
        // we must ack everything
        for (tag in this._unAcked) {
          this._unAcked[tag].emit('ack');
          delete this._unAcked[tag];
        }
      } else if (sequenceNumber !== 0 &amp;&amp; args.multiple === true) {
        // we must ack everything before the delivery tag
        for (tag in this._unAcked) {
          if (tag &lt;= sequenceNumber) {
            this._unAcked[tag].emit('ack');
            delete this._unAcked[tag];
          }
        }
      } else if (this._unAcked[sequenceNumber] &amp;&amp; args.multiple === false) {
        // simple single ack
        this._unAcked[sequenceNumber].emit('ack');
        delete this._unAcked[sequenceNumber];
      }
      break;

    case methods.basicReturn:
      this.emit('basic-return', args);
      break;

    case methods.exchangeBindOk:
      if (this._bindCallback) {
        // setting this._bindCa ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Channel.prototype._onChannelMethod = function(channel, method, args) {
switch (method) {
  case methods.channelCloseOk:
    delete this.connection.channels[this.channel];
    this.state = 'closed';
    // TODO should this be falling through?
  default:
    this.<span class="apidocCodeKeywordSpan">_onMethod</span>(channel, method, args);
}
};

Channel.prototype.close = function(reason) {
this.state = 'closing';
this.connection._sendMethod(this.channel, methods.channelClose,
                            {'replyText': reason ? reason : 'Goodbye from node',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype._readyToPublishWithConfirms" id="apidoc.element.amqp.exchange.prototype._readyToPublishWithConfirms">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>_readyToPublishWithConfirms
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readyToPublishWithConfirms = function () {
  return this._sequence != null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (this.state !== 'open') {
  this._sequence = null;
  return callback(true, new Error('Can not publish: exchange is not open'));
}

if (this.options.confirm &amp;&amp; !this.<span class="apidocCodeKeywordSpan">_readyToPublishWithConfirms</span>()) {
  return callback(true, new Error('Not yet ready to publish with confirms'));
}

options = _.assignIn({}, options || {});
options.routingKey = routingKey;
options.exchange   = self.name;
options.mandatory  = options.mandatory ? true : false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.bind" id="apidoc.element.amqp.exchange.prototype.bind">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>bind
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind = function () {
  var self = this;

  // Two arguments are required. The binding to the destination
  // exchange/routingKey will be established.

  var exchange    = arguments[0]
    , routingKey  = arguments[1]
    , callback    = arguments[2]
  ;

  if (callback) this._bindCallback = callback;

  var source = exchange instanceof Exchange ? exchange.name : exchange;
  var destination = self.name;

  if(source in self.connection.exchanges) {
    self.sourceExchanges[source] = self.connection.exchanges[source];
    self.connection.exchanges[source].exchangeBinds++;
  }

  self.connection._sendMethod(self.channel, methods.exchangeBind,
      { reserved1: 0
      , destination: destination
      , source: source
      , routingKey: routingKey
      , noWait: false
      , "arguments": {}
      });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.<span class="apidocCodeKeywordSpan">bind</span>([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.bind_headers" id="apidoc.element.amqp.exchange.prototype.bind_headers">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>bind_headers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind_headers = function () {
  var self = this;

  // Two arguments are required. The binding to the destination
  // exchange/routingKey will be established.

  var exchange = arguments[0]
    , routing  = arguments[1]
    , callback = arguments[2]
  ;

  if (callback) this._bindCallback = callback;

  var source = exchange instanceof Exchange ? exchange.name : exchange;
  var destination = self.name;

  if (source in self.connection.exchanges) {
    self.sourceExchanges[source] = self.connection.exchanges[source];
    self.connection.exchanges[source].exchangeBinds++;
  }

  self.connection._sendMethod(self.channel, methods.exchangeBind,
    { reserved1: 0
        , destination: destination
        , source: source
        , routingKey: ''
        , noWait: false
        , "arguments": routing
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.<span class="apidocCodeKeywordSpan">bind_headers</span>([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.cleanup" id="apidoc.element.amqp.exchange.prototype.cleanup">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>cleanup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanup = function () {
  if (this.binds === 0) { // don't keep reference open if unused
    this.connection.exchangeClosed(this.name);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.destroy" id="apidoc.element.amqp.exchange.prototype.destroy">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>destroy
        <span class="apidocSignatureSpan">(ifUnused)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (ifUnused) {
  var self = this;
  return this._taskPush(methods.exchangeDeleteOk, function () {
    self.connection.exchangeClosed(self.name);
    self.connection._sendMethod(self.channel, methods.exchangeDelete,
        { reserved1: 0
        , exchange: self.name
        , ifUnused: ifUnused ? true : false
        , noWait: false
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.<span class="apidocCodeKeywordSpan">destroy</span>(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.publish" id="apidoc.element.amqp.exchange.prototype.publish">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>publish
        <span class="apidocSignatureSpan">(routingKey, data, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (routingKey, data, options, callback) {
  var self = this;
  callback = callback || function() {};

  if (this.connection._blocked) {
    return callback(true, new Error('Connection is blocked, server reason: ' + this.connection._blockedReason));
  }

  if (this.state !== 'open') {
    this._sequence = null;
    return callback(true, new Error('Can not publish: exchange is not open'));
  }

  if (this.options.confirm &amp;&amp; !this._readyToPublishWithConfirms()) {
    return callback(true, new Error('Not yet ready to publish with confirms'));
  }

  options = _.assignIn({}, options || {});
  options.routingKey = routingKey;
  options.exchange   = self.name;
  options.mandatory  = options.mandatory ? true : false;
  options.immediate  = options.immediate ? true : false;
  options.reserved1  = 0;

  var task = this._taskPush(null, function () {
    self.connection._sendMethod(self.channel, methods.basicPublish, options);
    // This interface is probably not appropriate for streaming large files.
    // (Of course it's arguable about whether AMQP is the appropriate
    // transport for large files.) The content header wants to know the size
    // of the data before sending it - so there's no point in trying to have a
    // general streaming interface - streaming messages of unknown size simply
    // isn't possible with AMQP. This is all to say, don't send big messages.
    // If you need to stream something large, chunk it yourself.
    self.connection._sendBody(self.channel, data, options);
  });

  if (self.options.confirm) self._awaitConfirm(task, callback);
  return task;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Table of Contents

- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.<span class="apidocCodeKeywordSpan">publish</span>(routingKey, body, options, callback)](#connectionpublishroutingkey
-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.exchange.prototype.unbind" id="apidoc.element.amqp.exchange.prototype.unbind">
        function <span class="apidocSignatureSpan">amqp.exchange.prototype.</span>unbind
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbind = function () {
  var self = this;

  // Both arguments are required. The binding to the destination
  // exchange/routingKey will be unbound.

  var exchange    = arguments[0]
    , routingKey  = arguments[1]
    , callback    = arguments[2]
  ;

  if (callback) this._unbindCallback = callback;

  return this._taskPush(methods.exchangeUnbindOk, function () {
    var source = exchange instanceof Exchange ? exchange.name : exchange;
    var destination = self.name;

    if (source in self.connection.exchanges) {
      delete self.sourceExchanges[source];
      self.connection.exchanges[source].exchangeBinds--;
    }

    self.connection._sendMethod(self.channel, methods.exchangeUnbind,
        { reserved1: 0
        , destination: destination
        , source: source
        , routingKey: routingKey
        , noWait: false
        , "arguments": {}
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.<span class="apidocCodeKeywordSpan">unbind</span>([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.jspack" id="apidoc.module.amqp.jspack">module amqp.jspack</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.jspack.jspack" id="apidoc.element.amqp.jspack.jspack">
        function <span class="apidocSignatureSpan">amqp.</span>jspack
        <span class="apidocSignatureSpan">(bigEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jspack = function (bigEndian) {
  this.bigEndian = bigEndian;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.message" id="apidoc.module.amqp.message">module amqp.message</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.message.message" id="apidoc.element.amqp.message.message">
        function <span class="apidocSignatureSpan">amqp.</span>message
        <span class="apidocSignatureSpan">(queue, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(queue, args) {
  var msgProperties = definitions.classes[60].fields;

  events.EventEmitter.call(this);

  this.queue = queue;

  this.deliveryTag = args.deliveryTag;
  this.redelivered = args.redelivered;
  this.exchange    = args.exchange;
  this.routingKey  = args.routingKey;
  this.consumerTag = args.consumerTag;

  for (var i=0, l=msgProperties.length; i&lt;l; i++) {
    if (args[msgProperties[i].name]) {
      this[msgProperties[i].name] = args[msgProperties[i].name];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.message.super_" id="apidoc.element.amqp.message.super_">
        function <span class="apidocSignatureSpan">amqp.message.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.message.prototype" id="apidoc.module.amqp.message.prototype">module amqp.message.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.message.prototype.acknowledge" id="apidoc.element.amqp.message.prototype.acknowledge">
        function <span class="apidocSignatureSpan">amqp.message.prototype.</span>acknowledge
        <span class="apidocSignatureSpan">(all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acknowledge = function (all) {
  this.queue.connection._sendMethod(this.queue.channel, definitions.methods.basicAck,
      { reserved1: 0
      , deliveryTag: this.deliveryTag
      , multiple: all ? true : false
      });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can also use the prefetchCount option to increase the window of how
many messages the server will send you before you need to ack (quality of service).
`{ ack: true, prefetchCount: 1 }` is the default and will only send you one
message before you ack. Setting prefetchCount to 0 will make that window unlimited.
If this option is used `q.shift()` should not be called. Instead the listener
function should take four parameters `(message, headers, deliveryInfo, ack)` and
`ack.<span class="apidocCodeKeywordSpan">acknowledge</span>()` should be called to ack a single message.

The `routingKeyInPayload` and `deliveryKeyInPayload` options determine
if the reception process will inject the routingKey and deliveryKey,
respectively, into the JSON payload received.  These default to unset
thus adopting the parent connection's values (which default to false).
Setting these to true provide backward compatibility for older
applications.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.message.prototype.reject" id="apidoc.element.amqp.message.prototype.reject">
        function <span class="apidocSignatureSpan">amqp.message.prototype.</span>reject
        <span class="apidocSignatureSpan">(requeue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (requeue) {
  this.queue.connection._sendMethod(this.queue.channel, definitions.methods.basicReject,
      { deliveryTag: this.deliveryTag
      , requeue: requeue ? true : false
      });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Queue.prototype.subscribeJSON = Queue.prototype.subscribe;

/* Acknowledges the last message */
Queue.prototype.shift = function (reject, requeue) {
  if (this._lastMessage) {
    if (reject) {
      this._lastMessage.<span class="apidocCodeKeywordSpan">reject</span>(requeue ? true : false);
    } else {
      this._lastMessage.acknowledge();
    }
    this._lastMessage = null;
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.parser" id="apidoc.module.amqp.parser">module amqp.parser</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.parser.parser" id="apidoc.element.amqp.parser.parser">
        function <span class="apidocSignatureSpan">amqp.</span>parser
        <span class="apidocSignatureSpan">(version, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AMQPParser(version, type) {
  this.isClient = (type == 'client');
  this.state = this.isClient ? 'frameHeader' : 'protocolHeader';
  this.maxFrameBuffer = MAX_FRAME_BUFFER_DEFAULT;

  if (version != '0-9-1') this.throwError("Unsupported protocol version");

  var frameHeader = new Buffer(7);
  frameHeader.used = 0;
  var frameBuffer, frameType, frameChannel;

  var self = this;

  function header(data) {
    var fh = frameHeader;
    var needed = fh.length - fh.used;
    data.copy(fh, fh.used, 0, data.length);
    fh.used += data.length; // sloppy
    if (fh.used &gt;= fh.length) {
      fh.read = 0;
      frameType = fh[fh.read++];
      frameChannel = parseInt(fh, 2);
      var frameSize = parseInt(fh, 4);
      fh.used = 0; // for reuse
      if (frameSize &gt; self.maxFrameBuffer) {
        self.throwError("Oversized frame " + frameSize);
      }
      frameBuffer = new Buffer(frameSize);
      frameBuffer.used = 0;
      return frame(data.slice(needed));
    }
    else { // need more!
      return header;
    }
  }

  function frame(data) {
    var fb = frameBuffer;
    var needed = fb.length - fb.used;
    var sourceEnd = (fb.length &gt; data.length) ? data.length : fb.length;
    data.copy(fb, fb.used, 0, sourceEnd);
    fb.used += data.length;
    if (data.length &gt; needed) {
      return frameEnd(data.slice(needed));
    }
    else if (data.length == needed) {
      return frameEnd;
    }
    else {
      return frame;
    }
  }

  function frameEnd(data) {
    if (data.length &gt; 0) {
      if (data[0] === Indicators.FRAME_END) {
        switch (frameType) {
        case FrameType.METHOD:
          self._parseMethodFrame(frameChannel, frameBuffer);
          break;
        case FrameType.HEADER:
          self._parseHeaderFrame(frameChannel, frameBuffer);
          break;
        case FrameType.BODY:
          if (self.onContent) {
            self.onContent(frameChannel, frameBuffer);
          }
          break;
        case FrameType.HEARTBEAT:
          debug &amp;&amp; debug("heartbeat");
          if (self.onHeartBeat) self.onHeartBeat();
          break;
        default:
          self.throwError("Unhandled frame type " + frameType);
          break;
        }
        return header(data.slice(1));
      }
      else {
        self.throwError("Missing frame end marker");
      }
    }
    else {
      return frameEnd;
    }
  }

  self.parse = header;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.parser.prototype" id="apidoc.module.amqp.parser.prototype">module amqp.parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.parser.prototype._parseHeaderFrame" id="apidoc.element.amqp.parser.prototype._parseHeaderFrame">
        function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>_parseHeaderFrame
        <span class="apidocSignatureSpan">(channel, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseHeaderFrame = function (channel, buffer) {
  buffer.read = 0;

  var classIndex = parseInt(buffer, 2);
  var weight = parseInt(buffer, 2);
  var size = parseInt(buffer, 8);

  var classInfo = classes[classIndex];

  if (classInfo.fields.length &gt; 15) {
    this.throwError("TODO: support more than 15 properties");
  }

  var propertyFlags = parseInt(buffer, 2);

  var fields = [];
  for (var i = 0; i &lt; classInfo.fields.length; i++) {
    var field = classInfo.fields[i];
    // groan.
    if (propertyFlags &amp; (1 &lt;&lt; (15-i))) fields.push(field);
  }

  var properties = parseFields(buffer, fields);

  if (this.onContentHeader) {
    this.onContentHeader(channel, classInfo, weight, properties, size);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (data.length &gt; 0) {
if (data[0] === Indicators.FRAME_END) {
  switch (frameType) {
  case FrameType.METHOD:
    self._parseMethodFrame(frameChannel, frameBuffer);
    break;
  case FrameType.HEADER:
    self.<span class="apidocCodeKeywordSpan">_parseHeaderFrame</span>(frameChannel, frameBuffer);
    break;
  case FrameType.BODY:
    if (self.onContent) {
      self.onContent(frameChannel, frameBuffer);
    }
    break;
  case FrameType.HEARTBEAT:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.parser.prototype._parseMethodFrame" id="apidoc.element.amqp.parser.prototype._parseMethodFrame">
        function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>_parseMethodFrame
        <span class="apidocSignatureSpan">(channel, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseMethodFrame = function (channel, buffer) {
  buffer.read = 0;
  var classId = parseInt(buffer, 2),
     methodId = parseInt(buffer, 2);

  // Make sure that this is a method that we understand.
  if (!methodTable[classId] || !methodTable[classId][methodId]) {
    this.throwError("Received unknown [classId, methodId] pair [" +
               classId + ", " + methodId + "]");
  }

  var method = methodTable[classId][methodId];

  if (!method) this.throwError("bad method?");

  var args = parseFields(buffer, method.fields);

  if (this.onMethod) {
    debug &amp;&amp; debug("Executing method", channel, method, args);
    this.onMethod(channel, method, args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function frameEnd(data) {
  if (data.length &gt; 0) {
    if (data[0] === Indicators.FRAME_END) {
      switch (frameType) {
      case FrameType.METHOD:
        self.<span class="apidocCodeKeywordSpan">_parseMethodFrame</span>(frameChannel, frameBuffer);
        break;
      case FrameType.HEADER:
        self._parseHeaderFrame(frameChannel, frameBuffer);
        break;
      case FrameType.BODY:
        if (self.onContent) {
          self.onContent(frameChannel, frameBuffer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.parser.prototype.execute" id="apidoc.element.amqp.parser.prototype.execute">
        function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>execute
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execute = function (data) {
  // This function only deals with dismantling and buffering the frames.
  // It delegates to other functions for parsing the frame-body.
  debug &amp;&amp; debug('execute: ' + data.toString('hex'));
  this.parse = this.parse(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.parser.prototype.setMaxFrameBuffer" id="apidoc.element.amqp.parser.prototype.setMaxFrameBuffer">
        function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>setMaxFrameBuffer
        <span class="apidocSignatureSpan">(maxFrameBuffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxFrameBuffer = function (maxFrameBuffer) {
  this.maxFrameBuffer = maxFrameBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.parser.prototype.throwError" id="apidoc.element.amqp.parser.prototype.throwError">
        function <span class="apidocSignatureSpan">amqp.parser.prototype.</span>throwError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwError = function (error) {
  if (this.onError) this.onError(error);
  else throw new Error(error);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// of emitting the callbacks. Since this is an internal class, that should
// be fine.
var AMQPParser = module.exports = function AMQPParser (version, type) {
this.isClient = (type == 'client');
this.state = this.isClient ? 'frameHeader' : 'protocolHeader';
this.maxFrameBuffer = MAX_FRAME_BUFFER_DEFAULT;

if (version != '0-9-1') this.<span class="apidocCodeKeywordSpan">throwError</span>("Unsupported protocol version&amp;#
x22;);

var frameHeader = new Buffer(7);
frameHeader.used = 0;
var frameBuffer, frameType, frameChannel;

var self = this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.promise" id="apidoc.module.amqp.promise">module amqp.promise</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.promise.Promise" id="apidoc.element.amqp.promise.Promise">
        function <span class="apidocSignatureSpan">amqp.promise.</span>Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise = function () {
  events.EventEmitter.call(this);
  this._blocking = false;
  this.hasFired = false;
  this.hasAcked = false;
  this._values = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.queue" id="apidoc.module.amqp.queue">module amqp.queue</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.queue.queue" id="apidoc.element.amqp.queue.queue">
        function <span class="apidocSignatureSpan">amqp.</span>queue
        <span class="apidocSignatureSpan">(connection, channel, name, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue(connection, channel, name, options, callback) {
  Channel.call(this, connection, channel);

  var self = this;
  this.name = name;
  this._bindings = {};
  this.consumerTagListeners = {};
  this.consumerTagOptions = {};

  // route messages to subscribers based on consumerTag
  this.on('rawMessage', function(message) {
    if (message.consumerTag &amp;&amp; self.consumerTagListeners[message.consumerTag]) {
      self.consumerTagListeners[message.consumerTag](message);
    }
  });

  this.options = { autoDelete: true, closeChannelOnUnsubscribe: false };
  _.assignIn(this.options, options || {});

  this._openCallback = callback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Installation](#installation)
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.<span class="apidocCodeKeywordSpan">queue</span>(name[, options][, openCallback])](#connectionqueuename-options-opencallback
)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.super_" id="apidoc.element.amqp.queue.super_">
        function <span class="apidocSignatureSpan">amqp.queue.</span>super_
        <span class="apidocSignatureSpan">(connection, channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Channel(connection, channel) {
  events.EventEmitter.call(this);

  // Unlimited listeners. Helps when e.g. publishing high-volume messages,
  // 10 is far too low.
  this.setMaxListeners(0);

  this.channel = channel;
  this.connection = connection;
  this._tasks = [];

  this.reconnect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.queue.prototype" id="apidoc.module.amqp.queue.prototype">module amqp.queue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.queue.prototype._onContent" id="apidoc.element.amqp.queue.prototype._onContent">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onContent
        <span class="apidocSignatureSpan">(channel, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onContent = function (channel, data) {
  this.currentMessage.read += data.length;
  this.currentMessage.emit('data', data);
  if (this.currentMessage.read == this.currentMessage.size) {
    this.currentMessage.emit('end');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype._onContentHeader" id="apidoc.element.amqp.queue.prototype._onContentHeader">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onContentHeader
        <span class="apidocSignatureSpan">(channel, classInfo, weight, properties, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onContentHeader = function (channel, classInfo, weight, properties, size) {
  _.assignIn(this.currentMessage, properties);
  this.currentMessage.read = 0;
  this.currentMessage.size = size;

  this.emit('rawMessage', this.currentMessage);
  if (size === 0) {
    // If the message has no body, directly emit 'end'
    this.currentMessage.emit('end');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype._onMethod" id="apidoc.element.amqp.queue.prototype._onMethod">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>_onMethod
        <span class="apidocSignatureSpan">(channel, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onMethod = function (channel, method, args) {
  var self = this;
  this.emit(method.name, args);
  if (this._handleTaskReply.apply(this, arguments)) return;

  switch (method) {
    case methods.channelOpenOk:
      if (this.options.noDeclare) {
        this.state = 'open';

        if (this._openCallback) {
         this._openCallback(this);
         this._openCallback = null;
        }

        this.emit('open');
      } else {
        if (this.name.indexOf('amq.') == 0) {
          this.name = '';
        }
        this.connection._sendMethod(channel, methods.queueDeclare,
            { reserved1: 0
            , queue: this.name
            , passive: !!this.options.passive
            , durable: !!this.options.durable
            , exclusive: !!this.options.exclusive
            , autoDelete: !!this.options.autoDelete
            , noWait: false
            , "arguments": this.options.arguments || {}
            });
        this.state = "declare queue";
      }
      break;

    case methods.queueDeclareOk:
      this.state = 'open';
      this.name = args.queue;
      this.connection.queues[this.name] = this;

      // Rebind to previously bound exchanges, if present.
      // Important this is called *before* openCallback, otherwise bindings will happen twice.
      // Run test-purge to make sure you got this right
      _.forEach(this._bindings, function(exchange, exchangeName){
        _.forEach(exchange, function(count, routingKey){
          self.bind(exchangeName, routingKey);
        });
      });

      // Call opening callback (passed in function)
      // FIXME use eventemitter - maybe we call a namespaced event here
      if (this._openCallback) {
        this._openCallback(this, args.messageCount, args.consumerCount);
        this._openCallback = null;
      }

      // TODO this is legacy interface, remove me
      this.emit('open', args.queue, args.messageCount, args.consumerCount);

      // If this is a reconnect, we must re-subscribe our queue listeners.
      var consumerTags = Object.keys(this.consumerTagListeners);
      for (var index in consumerTags) {
        if (consumerTags.hasOwnProperty(index)) {
          if (this.consumerTagOptions[consumerTags[index]]['state'] === 'closed') {
            this.subscribeRaw(this.consumerTagOptions[consumerTags[index]], this.consumerTagListeners[consumerTags[index]]);
            // Having called subscribeRaw, we are now a new consumer with a new consumerTag.
            delete this.consumerTagListeners[consumerTags[index]];
            delete this.consumerTagOptions[consumerTags[index]];
          }
        }
      }
      break;

    case methods.basicConsumeOk:
      debug &amp;&amp; debug('basicConsumeOk', util.inspect(args, null));
      break;

    case methods.queueBindOk:
      if (this._bindCallback) {
        // setting this._bindCallback to null before calling the callback allows for a subsequent bind within the callback
        // FIXME use eventemitter
        var cb = this._bindCallback;
        this._bindCallback = null;
        cb(this);
      }
      break;

    case methods.queueUnbindOk:
      break;

    case methods.basicQosOk:
      break;

    case methods.confirmSelectOk:
      this._sequence = 1;
      this.confirm = true;
      break;

    case methods.channelClose:
      this.state = "closed";
      this.closeOK();
      this.connection.queueClosed(this.name);
      var e = new Error(args.replyText);
      e.code = args.replyCode;
      this.emit('error', e);
      this.emit('close');
      break;

    case methods.channelCloseOk:
      this.connection.queueClosed(this.name);
      this.emit('close');
      break;

    case methods.basicDeliver:
      this.currentMessage = new Message(this, args);
      break;

    case methods.queueDeleteOk:
      break;

    case methods.basicCancel:
      this.close("Closed due to basicCancel received on consumer (" + args.consumerTag + ")");
      break;

    default:
      throw new Error("Uncaught method '" + method.name + "' with args " +
          JSON.stringify(args) + "; tasks = " + JSON.stringify(this._ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Channel.prototype._onChannelMethod = function(channel, method, args) {
switch (method) {
  case methods.channelCloseOk:
    delete this.connection.channels[this.channel];
    this.state = 'closed';
    // TODO should this be falling through?
  default:
    this.<span class="apidocCodeKeywordSpan">_onMethod</span>(channel, method, args);
}
};

Channel.prototype.close = function(reason) {
this.state = 'closing';
this.connection._sendMethod(this.channel, methods.channelClose,
                            {'replyText': reason ? reason : 'Goodbye from node',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.bind" id="apidoc.element.amqp.queue.prototype.bind">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>bind
        <span class="apidocSignatureSpan">(exchange, routingKey, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind = function (exchange, routingKey, callback) {
  var self = this;

  // The first argument, exchange is optional.
  // If not supplied the connection will use the 'amq.topic'
  // exchange.
  if (routingKey === undefined || _.isFunction(routingKey)) {
    callback = routingKey;
    routingKey = exchange;
    exchange = 'amq.topic';
  }

  if (_.isFunction(callback)) this._bindCallback = callback;

  var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;

  if (exchangeName in self.connection.exchanges) {
    this.exchange = self.connection.exchanges[exchangeName];
    this.exchange.binds++;
  }

  // Record this binding so we can restore it upon reconnect.
  if (!this._bindings[exchangeName]) {
    this._bindings[exchangeName] = {};
  }

  if (!this._bindings[exchangeName][routingKey]) {
    this._bindings[exchangeName][routingKey] = 0;
  }

  this._bindings[exchangeName][routingKey]++;

  self.connection._sendMethod(self.channel, methods.queueBind,
      { reserved1: 0
      , queue: self.name
      , exchange: exchangeName
      , routingKey: routingKey
      , noWait: false
      , "arguments": {}
      });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.<span class="apidocCodeKeywordSpan">bind</span>([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.bind_headers" id="apidoc.element.amqp.queue.prototype.bind_headers">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>bind_headers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind_headers = function () {
  var self = this;

  // The first argument, exchange is optional.
  // If not supplied the connection will use the default 'amq.headers'
  // exchange.

  var exchange, matchingPairs;

  if (arguments.length == 2) {
    exchange = arguments[0];
    matchingPairs = arguments[1];
  } else {
    exchange = 'amq.headers';
    matchingPairs = arguments[0];
  }


  return this._taskPush(methods.queueBindOk, function () {
    var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;
    self.connection._sendMethod(self.channel, methods.queueBind,
        { reserved1: 0
        , queue: self.name
        , exchange: exchangeName
        , routingKey: ''
        , noWait: false
        , "arguments": matchingPairs
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.<span class="apidocCodeKeywordSpan">bind_headers</span>([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.destroy" id="apidoc.element.amqp.queue.prototype.destroy">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>destroy
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (options) {
  var self = this;

  options = options || {};
  return this._taskPush(methods.queueDeleteOk, function () {
    self.connection.queueClosed(self.name);
    if ('exchange' in self) {
      self.exchange.binds--;
    }
    self.connection._sendMethod(self.channel, methods.queueDelete,
        { reserved1: 0
        , queue: self.name
        , ifUnused: options.ifUnused ? true : false
        , ifEmpty: options.ifEmpty ? true : false
        , noWait: false
        , "arguments": {}
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.<span class="apidocCodeKeywordSpan">destroy</span>(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
- [exchange.destroy(ifUnused = true)](#exchangedestroyifunused--true)
- [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.flow" id="apidoc.element.amqp.queue.prototype.flow">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>flow
        <span class="apidocSignatureSpan">(active)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flow = function (active) {
  var self = this;
  return this._taskPush(methods.channelFlowOk, function () {
    self.connection._sendMethod(self.channel, methods.channelFlow, {'active': active });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.purge" id="apidoc.element.amqp.queue.prototype.purge">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>purge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purge = function () {
  var self = this;
  return this._taskPush(methods.queuePurgeOk, function () {
    self.connection._sendMethod(self.channel, methods.queuePurge,
                                 { reserved1 : 0,
                                 queue: self.name,
                                 noWait: false});
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.shift" id="apidoc.element.amqp.queue.prototype.shift">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>shift
        <span class="apidocSignatureSpan">(reject, requeue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function (reject, requeue) {
  if (this._lastMessage) {
    if (reject) {
      this._lastMessage.reject(requeue ? true : false);
    } else {
      this._lastMessage.acknowledge();
    }
    this._lastMessage = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.<span class="apidocCodeKeywordSpan">shift</span>([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.subscribe" id="apidoc.element.amqp.queue.prototype.subscribe">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(options, messageListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (options, messageListener) {
  var self = this;

  // Optional options
  if (typeof options === "function") {
    messageListener = options;
    options = {};
  }

  options = _.defaults(options || {}, {
    ack: false,
    prefetchCount: 1,
    routingKeyInPayload: self.connection.options.routingKeyInPayload,
    deliveryTagInPayload: self.connection.options.deliveryTagInPayload
  });

  // basic consume
  var rawOptions = {
      noAck: !options.ack,
      exclusive: options.exclusive
  };

  if (options.ack) {
    rawOptions['prefetchCount'] = options.prefetchCount;
  }

  return this.subscribeRaw(rawOptions, function (m) {
    var contentType = m.contentType;
    var decoder = new StringDecoder('utf8');

    if (contentType == null &amp;&amp; m.headers &amp;&amp; m.headers.properties) {
      contentType = m.headers.properties.content_type;
    }

    var isJSON = contentType == 'text/json' ||
                 contentType == 'application/json';

    var buffer;

    if (isJSON) {
      buffer = "";
    } else {
      buffer = new Buffer(m.size);
      buffer.used = 0;
    }

    self._lastMessage = m;

    m.addListener('data', function (d) {
      if (isJSON) {
        buffer += decoder.write(d);
      } else {
        d.copy(buffer, buffer.used);
        buffer.used += d.length;
      }
    });

    m.addListener('end', function () {
      var json, deliveryInfo = {}, msgProperties = classes[60].fields, i, l;

      if (isJSON) {
        decoder.end();
        try {
          json = JSON.parse(buffer);
        } catch (e) {
          json = null;
          deliveryInfo.parseError = e;
          deliveryInfo.rawData = buffer;
        }
      } else {
        json = { data: buffer, contentType: m.contentType };
      }

      for (i = 0, l = msgProperties.length; i&lt;l; i++) {
        if (m[msgProperties[i].name]) {
          deliveryInfo[msgProperties[i].name] = m[msgProperties[i].name];
        }
      }

      deliveryInfo.queue = m.queue ? m.queue.name : null;
      deliveryInfo.deliveryTag = m.deliveryTag;
      deliveryInfo.redelivered = m.redelivered;
      deliveryInfo.exchange = m.exchange;
      deliveryInfo.routingKey = m.routingKey;
      deliveryInfo.consumerTag = m.consumerTag;

      if (options.routingKeyInPayload) json._routingKey = m.routingKey;
      if (options.deliveryTagInPayload) json._deliveryTag = m.deliveryTag;

      var headers = {};
      for (i in this.headers) {
        if (this.headers.hasOwnProperty(i)) {
          if (this.headers[i] instanceof Buffer) {
            headers[i] = this.headers[i].toString();
          } else {
            headers[i] = this.headers[i];
          }
        }
      }

      if (messageListener) messageListener(json, headers, deliveryInfo, m);
      self.emit('message', json, headers, deliveryInfo, m);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Synopsis](#synopsis)
- [Connection](#connection)
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.<span class="apidocCodeKeywordSpan">subscribe</span>([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.subscribeJSON" id="apidoc.element.amqp.queue.prototype.subscribeJSON">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribeJSON
        <span class="apidocSignatureSpan">(options, messageListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeJSON = function (options, messageListener) {
  var self = this;

  // Optional options
  if (typeof options === "function") {
    messageListener = options;
    options = {};
  }

  options = _.defaults(options || {}, {
    ack: false,
    prefetchCount: 1,
    routingKeyInPayload: self.connection.options.routingKeyInPayload,
    deliveryTagInPayload: self.connection.options.deliveryTagInPayload
  });

  // basic consume
  var rawOptions = {
      noAck: !options.ack,
      exclusive: options.exclusive
  };

  if (options.ack) {
    rawOptions['prefetchCount'] = options.prefetchCount;
  }

  return this.subscribeRaw(rawOptions, function (m) {
    var contentType = m.contentType;
    var decoder = new StringDecoder('utf8');

    if (contentType == null &amp;&amp; m.headers &amp;&amp; m.headers.properties) {
      contentType = m.headers.properties.content_type;
    }

    var isJSON = contentType == 'text/json' ||
                 contentType == 'application/json';

    var buffer;

    if (isJSON) {
      buffer = "";
    } else {
      buffer = new Buffer(m.size);
      buffer.used = 0;
    }

    self._lastMessage = m;

    m.addListener('data', function (d) {
      if (isJSON) {
        buffer += decoder.write(d);
      } else {
        d.copy(buffer, buffer.used);
        buffer.used += d.length;
      }
    });

    m.addListener('end', function () {
      var json, deliveryInfo = {}, msgProperties = classes[60].fields, i, l;

      if (isJSON) {
        decoder.end();
        try {
          json = JSON.parse(buffer);
        } catch (e) {
          json = null;
          deliveryInfo.parseError = e;
          deliveryInfo.rawData = buffer;
        }
      } else {
        json = { data: buffer, contentType: m.contentType };
      }

      for (i = 0, l = msgProperties.length; i&lt;l; i++) {
        if (m[msgProperties[i].name]) {
          deliveryInfo[msgProperties[i].name] = m[msgProperties[i].name];
        }
      }

      deliveryInfo.queue = m.queue ? m.queue.name : null;
      deliveryInfo.deliveryTag = m.deliveryTag;
      deliveryInfo.redelivered = m.redelivered;
      deliveryInfo.exchange = m.exchange;
      deliveryInfo.routingKey = m.routingKey;
      deliveryInfo.consumerTag = m.consumerTag;

      if (options.routingKeyInPayload) json._routingKey = m.routingKey;
      if (options.deliveryTagInPayload) json._deliveryTag = m.deliveryTag;

      var headers = {};
      for (i in this.headers) {
        if (this.headers.hasOwnProperty(i)) {
          if (this.headers[i] instanceof Buffer) {
            headers[i] = this.headers[i].toString();
          } else {
            headers[i] = this.headers[i];
          }
        }
      }

      if (messageListener) messageListener(json, headers, deliveryInfo, m);
      self.emit('message', json, headers, deliveryInfo, m);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.subscribeRaw" id="apidoc.element.amqp.queue.prototype.subscribeRaw">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>subscribeRaw
        <span class="apidocSignatureSpan">(options, messageListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeRaw = function (options, messageListener) {
  var self = this;

  // multiple method signatures
  if (typeof options === "function") {
    messageListener = options;
    options = {};
  }

  var consumerTag = 'node-amqp-' + process.pid + '-' + Math.random();
  this.consumerTagListeners[consumerTag] = messageListener;

  options = options || {};
  options['state'] = 'opening';
  this.consumerTagOptions[consumerTag] = options;
  if (options.prefetchCount !== undefined) {
    self.connection._sendMethod(self.channel, methods.basicQos,
        { reserved1: 0
        , prefetchSize: 0
        , prefetchCount: options.prefetchCount
        , global: false
        });
  }

  return this._taskPush(methods.basicConsumeOk, function () {
    self.connection._sendMethod(self.channel, methods.basicConsume,
        { reserved1: 0
        , queue: self.name
        , consumerTag: consumerTag
        , noLocal: !!options.noLocal
        , noAck: !!options.noAck
        , exclusive: !!options.exclusive
        , noWait: false
        , "arguments": {}
        });
    self.consumerTagOptions[consumerTag]['state'] = 'open';
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Connection](#connection)
  - [Connection options and URL](#connection-options-and-url)
  - [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
  - [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
  - [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
  - [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
  - [queue.<span class="apidocCodeKeywordSpan">subscribeRaw</span>([options,] listener)](#queuesubscriberawoptions-listener)
  - [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
  - [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
  - [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
  - [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
  - [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
  - [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.unbind" id="apidoc.element.amqp.queue.prototype.unbind">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unbind
        <span class="apidocSignatureSpan">(exchange, routingKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbind = function (exchange, routingKey) {
  var self = this;

  // The first argument, exchange is optional.
  // If not supplied the connection will use the default 'amq.topic'
  // exchange.
  if (routingKey === undefined) {
    routingKey = exchange;
    exchange = 'amq.topic';
  }

  var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;

  // Decrement binding count.
  this._bindings[exchangeName][routingKey]--;
  if (!this._bindings[exchangeName][routingKey]) {
    delete this._bindings[exchangeName][routingKey];
  }

  // If there are no more bindings to this exchange, delete the key for the exchange.
  if (!_.keys(this._bindings[exchangeName]).length){
    delete this._bindings[exchangeName];
  }

  return this._taskPush(methods.queueUnbindOk, function () {
    self.connection._sendMethod(self.channel, methods.queueUnbind,
        { reserved1: 0
        , queue: self.name
        , exchange: exchangeName
        , routingKey: routingKey
        , noWait: false
        , "arguments": {}
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.<span class="apidocCodeKeywordSpan">unbind</span>([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
- [connection.exchange()](#connectionexchange)
- [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options-opencallback)
- [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.unbind_headers" id="apidoc.element.amqp.queue.prototype.unbind_headers">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unbind_headers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbind_headers = function () {
  var self = this;

  // The first argument, exchange is optional.
  // If not supplied the connection will use the default 'amq.topic'
  // exchange.

  var exchange, matchingPairs;

  if (arguments.length === 2) {
    exchange = arguments[0];
    matchingPairs = arguments[1];
  } else {
    exchange = 'amq.headers';
    matchingPairs = arguments[0];
  }

  return this._taskPush(methods.queueUnbindOk, function () {
    var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;
    self.connection._sendMethod(self.channel, methods.queueUnbind,
        { reserved1: 0
        , queue: self.name
        , exchange: exchangeName
        , routingKey: ''
        , noWait: false
        , "arguments": matchingPairs
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
bound it will not receive any messages.

This method is to be used on an "headers"-type exchange. The routing
argument must contain the routing keys and the `x-match` value (`all` or `any`).

If the `exchange` argument is left out `'amq.headers'` will be used.

### queue.<span class="apidocCodeKeywordSpan">unbind_headers</span>([exchange,] routing)

This method unbinds a queue from an exchange.  Whilst a queue is
bound it will continue receive messages that have matching headers.

This method is to be used on an "headers"-type exchange. The routing
argument must contain the routing keys and the `x-match` value (`all` or `any`).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.queue.prototype.unsubscribe" id="apidoc.element.amqp.queue.prototype.unsubscribe">
        function <span class="apidocSignatureSpan">amqp.queue.prototype.</span>unsubscribe
        <span class="apidocSignatureSpan">(consumerTag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function (consumerTag) {
  var self = this;
  return this._taskPush(methods.basicCancelOk, function () {
    self.connection._sendMethod(self.channel, methods.basicCancel,
                                { reserved1: 0,
                                  consumerTag: consumerTag,
                                  noWait: false });
  })
  .addCallback(function () {
    if (self.options.closeChannelOnUnsubscribe) {
      self.close();
    }
    delete self.consumerTagListeners[consumerTag];
    delete self.consumerTagOptions[consumerTag];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Connection options and URL](#connection-options-and-url)
- [connection.publish(routingKey, body, options, callback)](#connectionpublishroutingkey-body-options-callback)
- [connection.disconnect()](#connectiondisconnect)
- [Queue](#queue)
- [connection.queue(name[, options][, openCallback])](#connectionqueuename-options-opencallback)
- [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)
- [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)
- [queue.<span class="apidocCodeKeywordSpan">unsubscribe</span>(consumerTag)](#queueunsubscribeconsumertag)
- [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)
- [queue.bind([exchange,] routing)](#queuebindexchange-routing-callback)
- [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)
- [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)
- [queue.destroy(options)](#queuedestroyoptions)
- [Exchange](#exchange)
- [exchange.on('open', callback)](#exchangeonopen-callback)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amqp.serializer" id="apidoc.module.amqp.serializer">module amqp.serializer</a></h1>


    <h2>
        <a href="#apidoc.element.amqp.serializer.getCode" id="apidoc.element.amqp.serializer.getCode">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>getCode
        <span class="apidocSignatureSpan">(dec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCode = function (dec) {
  var hexArray = "0123456789ABCDEF".split('');
  var code1 = Math.floor(dec / 16);
  var code2 = dec - code1 * 16;
  return hexArray[code2];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.isBigInt" id="apidoc.element.amqp.serializer.isBigInt">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>isBigInt
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBigInt = function (value) {
  return value &gt; 0xffffffff;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'string':
  b[b.used++] = 'S'.charCodeAt(0);
  serializer.serializeLongString(b, value);
  break;

case 'number':
  if (!serializer.isFloat(value)) {
    if (serializer.<span class="apidocCodeKeywordSpan">isBigInt</span>(value)) {
      // 64-bit uint
      b[b.used++] = 'l'.charCodeAt(0);
      serializer.serializeInt(b, 8, value);
    } else {
      //32-bit uint
      b[b.used++] = 'I'.charCodeAt(0);
      serializer.serializeInt(b, 4, value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.isFloat" id="apidoc.element.amqp.serializer.isFloat">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>isFloat
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFloat = function (value){
  return value === +value &amp;&amp; value !== (value|0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    switch (typeof(value)) {
case 'string':
  b[b.used++] = 'S'.charCodeAt(0);
  serializer.serializeLongString(b, value);
  break;

case 'number':
  if (!serializer.<span class="apidocCodeKeywordSpan">isFloat</span>(value)) {
    if (serializer.isBigInt(value)) {
      // 64-bit uint
      b[b.used++] = 'l'.charCodeAt(0);
      serializer.serializeInt(b, 8, value);
    } else {
      //32-bit uint
      b[b.used++] = 'I'.charCodeAt(0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeArray" id="apidoc.element.amqp.serializer.serializeArray">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeArray
        <span class="apidocSignatureSpan">(b, arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeArray = function (b, arr) {
  // Save our position so that we can go back and write the byte length of this array
  // at the beginning of the packet (once we have serialized all elements).
  var lengthIndex = b.used;
  b.used += 4; // sizeof long
  var startIndex = b.used;

  var len = arr.length;
  for (var i = 0; i &lt; len; i++) {
    serializer.serializeValue(b, arr[i]);
  }

  var endIndex = b.used;
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      b[b.used++] = 'T'.charCodeAt(0);
      serializer.serializeDate(b, value);
    } else if (value instanceof Buffer) {
      b[b.used++] = 'x'.charCodeAt(0);
      serializer.serializeBuffer(b, value);
    } else if (Array.isArray(value)) {
      b[b.used++] = 'A'.charCodeAt(0);
      serializer.<span class="apidocCodeKeywordSpan">serializeArray</span>(b, value);
    } else if (typeof(value) === 'object') {
      b[b.used++] = 'F'.charCodeAt(0);
      serializer.serializeTable(b, value);
    } else {
      throw new Error("unsupported type in amqp table: " + typeof(value));
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeBase64" id="apidoc.element.amqp.serializer.serializeBase64">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeBase64
        <span class="apidocSignatureSpan">(b, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeBase64 = function (b, buffer) {
  serializer.serializeLongString(b, buffer.toString('base64'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeBuffer" id="apidoc.element.amqp.serializer.serializeBuffer">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeBuffer
        <span class="apidocSignatureSpan">(b, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeBuffer = function (b, buffer) {
  serializer.serializeInt(b, 4, buffer.length);
  buffer.copy(b, b.used, 0);
  b.used += buffer.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      default:
if (value instanceof Date) {
  b[b.used++] = 'T'.charCodeAt(0);
  serializer.serializeDate(b, value);
} else if (value instanceof Buffer) {
  b[b.used++] = 'x'.charCodeAt(0);
  serializer.<span class="apidocCodeKeywordSpan">serializeBuffer</span>(b, value);
} else if (Array.isArray(value)) {
  b[b.used++] = 'A'.charCodeAt(0);
  serializer.serializeArray(b, value);
} else if (typeof(value) === 'object') {
  b[b.used++] = 'F'.charCodeAt(0);
  serializer.serializeTable(b, value);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeDate" id="apidoc.element.amqp.serializer.serializeDate">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeDate
        <span class="apidocSignatureSpan">(b, date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeDate = function (b, date) {
  serializer.serializeInt(b, 8, date.valueOf() / 1000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  b[b.used++] = 't'.charCodeAt(0);
  b[b.used++] = value;
  break;

default:
  if (value instanceof Date) {
    b[b.used++] = 'T'.charCodeAt(0);
    serializer.<span class="apidocCodeKeywordSpan">serializeDate</span>(b, value);
  } else if (value instanceof Buffer) {
    b[b.used++] = 'x'.charCodeAt(0);
    serializer.serializeBuffer(b, value);
  } else if (Array.isArray(value)) {
    b[b.used++] = 'A'.charCodeAt(0);
    serializer.serializeArray(b, value);
  } else if (typeof(value) === 'object') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeFields" id="apidoc.element.amqp.serializer.serializeFields">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeFields
        <span class="apidocSignatureSpan">(buffer, fields, args, strict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeFields = function (buffer, fields, args, strict) {
  var bitField = 0;
  var bitIndex = 0;
  for (var i = 0; i &lt; fields.length; i++) {
    var field = fields[i];
    var domain = field.domain;
    if (!(field.name in args)) {
      if (strict) {
        throw new Error("Missing field '" + field.name + "' of type '" + domain + "' while executing AMQP method '" +
          arguments.callee.caller.arguments[1].name + "'");
      }
      continue;
    }

    var param = args[field.name];

    //debug("domain: " + domain + " param: " + param);

    switch (domain) {
      case 'bit':
        if (typeof(param) != "boolean") {
          throw new Error("Unmatched field " + JSON.stringify(field));
        }

        if (param) bitField |= (1 &lt;&lt; bitIndex);
        bitIndex++;

        if (!fields[i+1] || fields[i+1].domain != 'bit') {
          //debug('SET bit field ' + field.name + ' 0x' + bitField.toString(16));
          buffer[buffer.used++] = bitField;
          bitField = 0;
          bitIndex = 0;
        }
        break;

      case 'octet':
        if (typeof(param) != "number" || param &gt; 0xFF) {
          throw new Error("Unmatched field " + JSON.stringify(field));
        }
        buffer[buffer.used++] = param;
        break;

      case 'short':
        if (typeof(param) != "number" || param &gt; 0xFFFF) {
          throw new Error("Unmatched field " + JSON.stringify(field));
        }
        serializer.serializeInt(buffer, 2, param);
        break;

      case 'long':
        if (typeof(param) != "number" || param &gt; 0xFFFFFFFF) {
          throw new Error("Unmatched field " + JSON.stringify(field));
        }
        serializer.serializeInt(buffer, 4, param);
        break;

      // In a previous version this shared code with 'longlong', which caused problems when passed Date
      // integers. Nobody expects to pass a Buffer here, 53 bits is still 28 million years after 1970, we'll be fine.
      case 'timestamp':
        serializer.serializeInt(buffer, 8, param);
        break;

      case 'longlong':
        for (var j = 0; j &lt; 8; j++) {
          buffer[buffer.used++] = param[j];
        }
        break;

      case 'shortstr':
        if (typeof(param) != "string" || param.length &gt; 0xFF) {
          throw new Error("Unmatched field " + JSON.stringify(field));
        }
        serializer.serializeShortString(buffer, param);
        break;

      case 'longstr':
        serializer.serializeLongString(buffer, param);
        break;

      case 'table':
        if (typeof(param) != "object") {
          throw new Error("Unmatched field " + JSON.stringify(field));
        }
        serializer.serializeTable(buffer, param);
        break;

      default:
        throw new Error("Unknown domain value type " + domain);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeFloat" id="apidoc.element.amqp.serializer.serializeFloat">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeFloat
        <span class="apidocSignatureSpan">(b, size, value, bigEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeFloat = function (b, size, value, bigEndian) {
  var jp = new jspack(bigEndian);

  switch(size) {
    case 4:
      var x = jp.Pack('f', [value]);
      for (var i = 0; i &lt; x.length; ++i)
        b[b.used++] = x[i];
      break;

    case 8:
      var x = jp.Pack('d', [value]);
      for (var i = 0; i &lt; x.length; ++i)
        b[b.used++] = x[i];
      break;

    default:
      throw new Error("Unknown floating point size");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      //32-bit uint
      b[b.used++] = 'I'.charCodeAt(0);
      serializer.serializeInt(b, 4, value);
    }
  } else {
    //64-bit float
    b[b.used++] = 'd'.charCodeAt(0);
    serializer.<span class="apidocCodeKeywordSpan">serializeFloat</span>(b, 8, value);
  }
  break;

case 'boolean':
  b[b.used++] = 't'.charCodeAt(0);
  b[b.used++] = value;
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeInt" id="apidoc.element.amqp.serializer.serializeInt">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeInt
        <span class="apidocSignatureSpan">(b, size, int)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeInt = function (b, size, int) {
  if (b.used + size &gt; b.length) {
    throw new Error("write out of bounds");
  }

  // Only 4 cases - just going to be explicit instead of looping.

  switch (size) {
    // octet
    case 1:
      b[b.used++] = int;
      break;

    // short
    case 2:
      b[b.used++] = (int &amp; 0xFF00) &gt;&gt; 8;
      b[b.used++] = (int &amp; 0x00FF) &gt;&gt; 0;
      break;

    // long
    case 4:
      b[b.used++] = (int &amp; 0xFF000000) &gt;&gt; 24;
      b[b.used++] = (int &amp; 0x00FF0000) &gt;&gt; 16;
      b[b.used++] = (int &amp; 0x0000FF00) &gt;&gt; 8;
      b[b.used++] = (int &amp; 0x000000FF) &gt;&gt; 0;
      break;


    // long long
    case 8:
      b[b.used++] = (int &amp; 0xFF00000000000000) &gt;&gt; 56;
      b[b.used++] = (int &amp; 0x00FF000000000000) &gt;&gt; 48;
      b[b.used++] = (int &amp; 0x0000FF0000000000) &gt;&gt; 40;
      b[b.used++] = (int &amp; 0x000000FF00000000) &gt;&gt; 32;
      b[b.used++] = (int &amp; 0x00000000FF000000) &gt;&gt; 24;
      b[b.used++] = (int &amp; 0x0000000000FF0000) &gt;&gt; 16;
      b[b.used++] = (int &amp; 0x000000000000FF00) &gt;&gt; 8;
      b[b.used++] = (int &amp; 0x00000000000000FF) &gt;&gt; 0;
      break;

    default:
      throw new Error("Bad size");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

serializeLongString: function(b, string) {
  // we accept string, object, or buffer for this parameter.
  // in the case of string we serialize it to utf8.
  if (typeof(string) == 'string') {
    var byteLength = Buffer.byteLength(string, 'utf8');
    serializer.<span class="apidocCodeKeywordSpan">serializeInt</span>(b, 4, byteLength);
    b.write(string, b.used, 'utf8');
    b.used += byteLength;
  } else if (typeof(string) == 'object') {
    serializer.serializeTable(b, string);
  } else {
    // data is Buffer
    var byteLength = string.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeLongString" id="apidoc.element.amqp.serializer.serializeLongString">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeLongString
        <span class="apidocSignatureSpan">(b, string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeLongString = function (b, string) {
  // we accept string, object, or buffer for this parameter.
  // in the case of string we serialize it to utf8.
  if (typeof(string) == 'string') {
    var byteLength = Buffer.byteLength(string, 'utf8');
    serializer.serializeInt(b, 4, byteLength);
    b.write(string, b.used, 'utf8');
    b.used += byteLength;
  } else if (typeof(string) == 'object') {
    serializer.serializeTable(b, string);
  } else {
    // data is Buffer
    var byteLength = string.length;
    serializer.serializeInt(b, 4, byteLength);
    b.write(string, b.used); // memcpy
    b.used += byteLength;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
serializeBuffer: function(b, buffer) {
  serializer.serializeInt(b, 4, buffer.length);
  buffer.copy(b, b.used, 0);
  b.used += buffer.length;
},

serializeBase64: function(b, buffer) {
  serializer.<span class="apidocCodeKeywordSpan">serializeLongString</span>(b, buffer.toString('base64'));
},

isBigInt: function(value) {
  return value &gt; 0xffffffff;
},

getCode: function(dec) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeShortString" id="apidoc.element.amqp.serializer.serializeShortString">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeShortString
        <span class="apidocSignatureSpan">(b, string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeShortString = function (b, string) {
  if (typeof(string) != "string") {
    throw new Error("param must be a string");
  }
  var byteLength = Buffer.byteLength(string, 'utf8');
  if (byteLength &gt; 0xFF) {
    throw new Error("String too long for 'shortstr' parameter");
  }
  if (1 + byteLength + b.used &gt;= b.length) {
    throw new Error("Not enough space in buffer for 'shortstr'");
  }
  b[b.used++] = byteLength;
  b.write(string, b.used, 'utf8');
  b.used += byteLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// at the beginning of the packet (once we know how many entries there are).
var lengthIndex = b.used;
b.used += 4; // sizeof long
var startIndex = b.used;

for (var key in object) {
  if (!object.hasOwnProperty(key)) continue;
  serializer.<span class="apidocCodeKeywordSpan">serializeShortString</span>(b, key);
  serializer.serializeValue(b, object[key]);
}

var endIndex = b.used;
b.used = lengthIndex;
serializer.serializeInt(b, 4, endIndex - startIndex);
b.used = endIndex;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeTable" id="apidoc.element.amqp.serializer.serializeTable">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeTable
        <span class="apidocSignatureSpan">(b, object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeTable = function (b, object) {
  if (typeof(object) != "object") {
    throw new Error("param must be an object");
  }

  // Save our position so that we can go back and write the length of this table
  // at the beginning of the packet (once we know how many entries there are).
  var lengthIndex = b.used;
  b.used += 4; // sizeof long
  var startIndex = b.used;

  for (var key in object) {
    if (!object.hasOwnProperty(key)) continue;
    serializer.serializeShortString(b, key);
    serializer.serializeValue(b, object[key]);
  }

  var endIndex = b.used;
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// in the case of string we serialize it to utf8.
if (typeof(string) == 'string') {
  var byteLength = Buffer.byteLength(string, 'utf8');
  serializer.serializeInt(b, 4, byteLength);
  b.write(string, b.used, 'utf8');
  b.used += byteLength;
} else if (typeof(string) == 'object') {
  serializer.<span class="apidocCodeKeywordSpan">serializeTable</span>(b, string);
} else {
  // data is Buffer
  var byteLength = string.length;
  serializer.serializeInt(b, 4, byteLength);
  b.write(string, b.used); // memcpy
  b.used += byteLength;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amqp.serializer.serializeValue" id="apidoc.element.amqp.serializer.serializeValue">
        function <span class="apidocSignatureSpan">amqp.serializer.</span>serializeValue
        <span class="apidocSignatureSpan">(b, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeValue = function (b, value) {
  switch (typeof(value)) {
    case 'string':
      b[b.used++] = 'S'.charCodeAt(0);
      serializer.serializeLongString(b, value);
      break;

    case 'number':
      if (!serializer.isFloat(value)) {
        if (serializer.isBigInt(value)) {
          // 64-bit uint
          b[b.used++] = 'l'.charCodeAt(0);
          serializer.serializeInt(b, 8, value);
        } else {
          //32-bit uint
          b[b.used++] = 'I'.charCodeAt(0);
          serializer.serializeInt(b, 4, value);
        }
      } else {
        //64-bit float
        b[b.used++] = 'd'.charCodeAt(0);
        serializer.serializeFloat(b, 8, value);
      }
      break;

    case 'boolean':
      b[b.used++] = 't'.charCodeAt(0);
      b[b.used++] = value;
      break;

    default:
      if (value instanceof Date) {
        b[b.used++] = 'T'.charCodeAt(0);
        serializer.serializeDate(b, value);
      } else if (value instanceof Buffer) {
        b[b.used++] = 'x'.charCodeAt(0);
        serializer.serializeBuffer(b, value);
      } else if (Array.isArray(value)) {
        b[b.used++] = 'A'.charCodeAt(0);
        serializer.serializeArray(b, value);
      } else if (typeof(value) === 'object') {
        b[b.used++] = 'F'.charCodeAt(0);
        serializer.serializeTable(b, value);
      } else {
        throw new Error("unsupported type in amqp table: " + typeof(value));
      }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var lengthIndex = b.used;
  b.used += 4; // sizeof long
  var startIndex = b.used;

  for (var key in object) {
    if (!object.hasOwnProperty(key)) continue;
    serializer.serializeShortString(b, key);
    serializer.<span class="apidocCodeKeywordSpan">serializeValue</span>(b, object[key]);
  }

  var endIndex = b.used;
  b.used = lengthIndex;
  serializer.serializeInt(b, 4, endIndex - startIndex);
  b.used = endIndex;
},
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>